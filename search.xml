<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[语音合成小工具]]></title>
    <url>%2F%2FTxtToSpeech%2F</url>
    <content type="text"><![CDATA[摘要本软件是基于Qt5开发的，实现的功能是文本转语音合成的功能。 操作步骤： [v] 加载TXT [v] 选择发音人 [v] 点击语音合成 或者 [v] 直接编辑最右边文本框 [v] 选择发音人 [v] 点击语音合成 软件的整体演示效果软件的整体的操作流程如下gif所示 语音合成的效果，随机演示效果声音如下： 代码讲解以下代码为选择发音人的列表 123456789101112self.voice_name_selecct = &#123; '讯飞小燕': 'xiaoyan', '讯飞许久': 'aisjiuxu','讯飞小萍': 'aisxping', '讯飞小婧': 'aisjinger', '讯飞许小宝': 'aisbabyxu','讯飞小东': 'x_xiaodong', '讯飞小王': 'x_xiaowang','讯飞萌萌': 'x_mengmengneutral', '讯飞宁宁': 'x_ningning','讯飞小南': 'x_xiaonan', '讯飞玲姐姐': 'x_xiaoling', '讯飞小坤': 'x_xiaokun', '讯飞小梅': 'x_xiaomei', '讯飞小瑞': 'x_xiaonuo_novel', '讯飞小师': 'x_xiaoshi_cts', '讯飞小梦': 'x_xiaomeng', '讯飞小施': 'x_xiaoshi', '讯飞小强': 'x_xiaoqiang', '讯飞一峰': 'x_yifeng', '讯飞小媛': 'x_xiaoyuan', '讯飞晓倩': 'x_xiaoqian', '讯飞小莹': 'x_xiaoying', '讯飞小乔': 'x_xiaoqiao', '讯飞小瑶': 'x_xiaoyao', '讯飞萌萌-悲伤': 'x_mengmengsad', '讯飞小春': 'x_mengchun', '讯飞马叔': 'x_laoma', '讯飞小蓉': 'x_xiaorong', '讯飞芳芳': 'x_xiaofang', '讯飞晓峰': 'x_xiaofeng', '讯飞小魏': 'x_xiaowei', '讯飞楠楠': 'x_nannan', '讯飞小肥': 'x_xiaofei', '讯飞小雪': 'x_xiaoxue', '讯飞晓琳': 'x_xiaolin', '讯飞小包': 'x_xiaobao', '讯飞小华': 'x_xiaoyang_story', '讯飞宋宝宝': 'x_xiaosong', '讯飞玉儿': 'x_yuer', '讯飞萌萌-高兴': 'x_mengmenghappy' &#125; 以下代码为软件背景发音的代码段 12345678910111213141516171819202122232425262728293031@pyqtSlot() def on_pushButton_hec_clicked(self): """ Slot documentation goes here. """ # # TODO: not implemented yet # raise NotImplementedError print("语音合成") yuyin_app = yuyi_hec() str_voice_name = self.comboBox_voice_name.currentText() InText_neirong = self.plainTextEdit.toPlainText().strip() print("zhi:", str_voice_name) if not InText_neirong: print("空文本警告") self.label_tips.setText("空文本警告,非法请求！") return 0 else: self.label_tips.setText("请求结果显示窗：") yuyin_app.yuyinhec(InText_neirong, self.voice_name_selecct[str_voice_name]) self.textEdit_tips.setText("语音合成结果提示：\n"+yuyin_app.Erro_Tips) #os.system('./output.mp3') file = r'./output.mp3' try: pygame.mixer.init() track = pygame.mixer.music.load(file) pygame.mixer.music.play() except: self.textEdit_tips.setText("错误代码：\n"+yuyin_app.Erro_Tips) # time.sleep(5) # pygame.mixer.music.stop() API的调用12345678910111213141516171819202122232425class yuyi_hec(object): def __init__(self): # API请求地址、API KEY、APP ID等参数，提前填好备用 self.api_url = "http://api.xfyun.cn/v1/service/v1/tts" self.API_KEY = "38f30ffa5f297b12bb271e164736cd49" self.APP_ID = "5d82345d" self.OUTPUT_FILE = "./output.mp3" # 输出音频的保存路径，请根据自己的情况替换 # TEXT = "苟利国家生死以，岂因祸福避趋之" self.TEXT = "教育数据挖掘是一种这些数据，wake，orange是4种工具。周德清小姐姐, you are so cute, and you roommate is extremely the excellent one!" self.Erro_Tips = "" # 发送HTTP POST请求 def getBody(self, text): data = &#123;'text': text&#125; return data def yuyinhec(self,InText,str_voice_name): # 构造输出音频配置参数 Param = &#123; "auf": "audio/L16;rate=16000", # 音频采样率 "aue": "lame", # 音频编码，raw(生成wav)或lame(生成mp3) "voice_name": str_voice_name,# "x_xiaowei", # x_xiaowei "speed": "50", # 语速[0,100] "volume": "77", # 音量[0,100] "pitch": "50", # 音高[0,100] "engine_type": "aisound" # 引擎类型。aisound（普通效果），intp65（中文），intp65_en（英文） &#125; 其中比较重要的是如下三条秘钥的代码,对应着你的账号中的秘钥地址 1234self.api_url = "http://api.xfyun.cn/v1/service/v1/tts"self.API_KEY = "38f30ffa5f297b12bb271e164736cd49"self.APP_ID = "5d82345d"self.OUTPUT_FILE = "./output.mp3" # 输出音频的保存路径，请根据]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>TxtToSpeech</tag>
        <tag>Tool</tag>
        <tag>Qt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入一串字符串统计字符个数]]></title>
    <url>%2F%2Fstaticstringnum%2F</url>
    <content type="text"><![CDATA[摘要题目：1.利用键盘录入,输入一个字符串,统计该字符串中各个字符的数量,并输出。 Edit By Porter, 积水成渊,蛟龙生焉。 方法一(python)直接统计英文字符，大写和小写思路： 1、建立26个英文字母的大写和小写部分 2、分别对输入数据进行轮寻 3、查找这些字母中重复字母的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051'''牛客网的输入输出格式--'''import sys'''直接统计英文字符，大写和小写思路：1、建立26个英文字母的大写和小写部分2、分别对输入数据进行轮寻3、查找这些字母中重复字母的个数。'''data="Thdddfffffffhhhhhbbbbbbbbb"def inputstr(): datastr = [] print('请输入数据:') while True: line = sys.stdin.readline().strip() if not line: break datastr.append(line) # print("-".join(datastr)) return datastrdef numstr(data): list_num = [] # A-z 26 list_num_ = [] # a-z 26 out_dict = &#123;&#125; for i in range(26): list_num.append(chr(ord('A') + i)) list_num_.append(chr(ord('a') + i)) k = 0 for j in range(len(data)): if list_num[i] == data[j]: k += 1 out_dict[list_num[i]] = k k = 0 for j in range(len(data)): if list_num_[i] == data[j]: k += 1 out_dict[list_num_[i]] = k return out_dictif __name__ == "__main__": outline = inputstr()[0] out_dict = numstr(outline) for key in out_dict.keys(): print(key, out_dict[key]) # print(dict.keys(), type(dict.keys())) 输入输出演示 123456789101112/home/porter/tempprogram/bishi/venv/bin/python /home/porter/tempprogram/bishi/test2.py请输入数据:dfhgjhGGhjjG 2f 1j 3d 1g 1h 3Process finished with exit code 0 方法二(python)直接统计英文字符，大写和小写包括数字符号等思路： 1、统计输入字符串中的字符不一样的字符 2、分别对不一样的字符在整个输入字符列表中进行遍历 3、查找这些字母中重复字母的个数。 12345678910111213141516171819202122232425262728293031323334353637383940414243import sys'''直接统计英文字符，大写和小写包括数字符号等思路：1、统计输入字符串中的字符不一样的字符2、分别对不一样的字符在整个输入字符列表中进行遍历3、查找这些字母中重复字母的个数。'''datastr = ['asddfgghhh']def inputstr(): global datastr datastr = [] print('请输入数据:') while True: line = sys.stdin.readline().strip() if not line: break datastr.append(line) # print("-".join(datastr)) # return datastrdef tongji(datain): datadifferent = [] data_out = &#123;&#125; # 统计差异字母 for data in datain: if data not in datadifferent: datadifferent.append(data) print(datadifferent) for i in range(len(datadifferent)): k = 0 for data in datain: if data == datadifferent[i]: k += 1 data_out[data] = k print(data_out)if __name__ == '__main__': inputstr() tongji(datastr[0]) 输入输出演示 1234567请输入数据:asdfghhhhhhhhh['a', 's', 'd', 'f', 'g', 'h']&#123;'d': 1, 's': 1, 'f': 1, 'h': 9, 'a': 1, 'g': 1&#125;Process finished with exit code 0 方法三(python)直接统计英文字符，大写和小写包括数字符号等思路： 1、将输入的字符串按照 2、分别对不一样的字符在整个输入字符列表中进行遍历 3、查找这些字母中重复字母的个数。 方法三的代码是方法二的另一种简单的实现方法 12345678910111213141516171819202122232425262728293031323334353637import sys'''直接统计英文字符，大写和小写包括数字符号等思路：1、统计输入字符串中的字符不一样的字符2、分别对不一样的字符在整个输入字符列表中进行遍历3、查找这些字母中重复字母的个数。'''datastr = ['asddfgghhh']def inputstr(): global datastr datastr = [] print('请输入数据:') while True: line = sys.stdin.readline().strip() if not line: break datastr.append(line)def tongji(datain): datadifferent = [] data_out = &#123;&#125; # 统计差异字母 for data in datain: if data not in datadifferent: datadifferent.append(data) data_out[data] = 1 else: data_out[data] = data_out[data]+1 print(datadifferent) print(data_out)if __name__ == '__main__': inputstr() tongji(datastr[0]) 输入输出演示1234567请输入数据:fffghhh['f', 'g', 'h']&#123;'g': 1, 'h': 3, 'f': 3&#125;Process finished with exit code 0 上面的代码实现是python的实现方式，接下来我将进行C/C++的方式进行实现 方法一(c/c++)直接统计英文字符，大写和小写包括数字符号等思路： 1、将输入的字符串按照 2、分别对不一样的字符在整个输入字符列表中进行遍历 3、查找这些字母中重复字母的个数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* * 输入字符串数组不超过20个字符的输入 shurustr * 存储不同字符串的一个命名数组 chayimingm * 按照对应位置存储的差异字符对应的数目的字符数组 chayinum * 均为20个字符空间大小 * * 算法，使用统计差异字符的符号，并存储到命名数组 chayimingm * 通过差异命名数组 chayimingm 中的元素，来轮询 输入字符串 shurustr 中的字符 * * */#define N 26char shurustr[N]=&#123;'\0'&#125;;//输入字符串的存储变量char chayimingm[N]=&#123;'\0'&#125;,chayinum[N]=&#123;0&#125;; //输出字符串的变量存储区void tongji(char *p)&#123; for(;*p!='\0';p++) &#123; for(int i=0;i&lt;N;i++) &#123; if(*p == chayimingm[i]) &#123; chayinum[i] += 1; break; &#125; else &#123; if(chayimingm[i] == '\0') &#123; chayimingm[i] = *p; chayinum[i] = 1; break; &#125; &#125; &#125; &#125; for(int i=0;i&lt;N;i++) &#123; if(chayimingm[i] == '\0')break; printf("字符:%c 的个数为:%d\n",chayimingm[i],chayinum[i]); &#125;&#125;int main(void)&#123; printf("请输入字符串:\n"); scanf("%s",shurustr); printf("输出的字符串为：%s \n", shurustr); tongji(shurustr); return 0;&#125; 输入输出演示123456789请输入字符串:aaassskkkkggc 输出的字符串为：aaassskkkkggc 字符:a 的个数为:3字符:s 的个数为:3字符:k 的个数为:4字符:g 的个数为:2字符:c 的个数为:1按 &lt;RETURN&gt; 来关闭窗口... 方法二(c/c++)直接统计英文字符，大写和小写包括数字符号等思路 输入字符串数组不超过20个字符的输入 shurustr 存储不同字符串的一个命名数组 chayimingm 按照对应位置存储的差异字符对应的数目的字符数组 chayinum 均为20个字符空间大小 算法，分别匹配26个英文大写字母和英文小写字母 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* * 输入字符串数组不超过20个字符的输入 shurustr * 存储不同字符串的一个命名数组 chayimingm * 按照对应位置存储的差异字符对应的数目的字符数组 chayinum * 均为20个字符空间大小 * * 算法，分别匹配26个英文大写字母和英文小写字母 * */#define N 40int chayimingm_up[26] = &#123;0&#125;;int chayimingm_small[26] = &#123;0&#125;;void tongji_xiaoxie(char *shurustr)&#123; char tempchar = 'A'; printf("开始计算\n"); for(int i=0;i&lt;26;i++) &#123; chayimingm_up[i] = 0;// printf("数据为：%c\n",tempchar); for(int j=0;j&lt;N;j++) &#123; if(tempchar == shurustr[j]) &#123; chayimingm_up[i]+=1; &#125; &#125; tempchar +=1; &#125; tempchar = 'a'; for(int i=0;i&lt;26;i++) &#123; chayimingm_small[i] = 0;// printf("数据为：%c\n",tempchar); for(int j=0;j&lt;N;j++) &#123; if(tempchar == shurustr[j]) &#123; chayimingm_small[i]+=1; &#125; &#125; tempchar +=1; &#125; tempchar = 'a'; for(int i=0;i&lt;26;i++) &#123; if(chayimingm_small[i]&gt;0) &#123; printf("字符:%c 个数为:%d ",tempchar, chayimingm_small[i]); &#125; tempchar +=1; &#125; tempchar = 'A'; for(int i=0;i&lt;26;i++) &#123; if(chayimingm_up[i]&gt;0) &#123; printf("字符:%c 个数为:%d ",tempchar, chayimingm_up[i]); &#125; tempchar +=1; &#125;&#125;int main(void)&#123; char strin[40]=&#123;'\0'&#125;; printf("请输入字符串：\n"); scanf("%s",strin); printf("输入的字符串为：%s \n",strin); tongji_xiaoxie(strin); return 0;&#125; 代码效果演示12345请输入字符串：sddffffffdddssll输入的字符串为：sddffffffdddssll 开始计算字符:d 个数为:5 字符:f 个数为:6 字符:l 个数为:2 字符:s 个数为:3 按 &lt;RETURN&gt; 来关闭窗口...]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>writen</tag>
        <tag>exam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆和栈的相关笔记]]></title>
    <url>%2F%2FheapAndStack%2F</url>
    <content type="text"><![CDATA[摘要在计算机领域，堆栈是一个不容忽视的概念，堆栈是一种数据结构。 堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。 在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。 堆栈中的物体具有一个特性：第一个放入堆栈中的物体总是被最后拿出来， 这个特性通常称为先进后出 (FILO—First-In/Last-Out)。 堆栈中定义了一些操作， 两个最重要的是PUSH和POP。 PUSH（入栈）操作：堆栈指针（SP）加1，然后在堆栈的顶部加入一 个元素。POP（出栈）操作相反，出栈则先将SP所指示的内部ram单元中内容送入直接地址寻址的单元中（目的位置），然后再将堆栈指针（SP）减1。这两种操作实现了数据项的插入和删除。 栈简介栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。参考如下代码： 123456int main()&#123; int b; //栈 char s[] = "abc"; //栈 char *p2; //栈&#125; 其中函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量，比如上面代码中变量s的地址小于变量b的地址，p2地址小于s的地址。栈中存储的数据的生命周期随着函数的执行完成而结束。 ———————————————— 版权声明：本文为CSDN博主「Dablelv」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/K346K346/article/details/80849966 堆简介堆由程序员分配释放， 若程序员不释放，程序结束时由OS回收，分配方式倒是类似于链表。参考如下代码： 12345678910111213141516int main()&#123; //C中使用malloc函数申请 char* p1 = (char *)malloc(10); cout&lt;&lt;(int*)p1&lt;&lt;endl; //输出：00000000003BA0C0 //使用free()释放 free(p1); //C++中用new运算符申请 char p2 = new char[10]; cout&lt;&lt;(int*)p2&lt;&lt;endl; //输出：00000000003BA0C0 //使用delete运算符释放 delete[] p2;&#125; 其中p1所指的10字节的内存空间与p2所指的10字节内存空间都是存在于堆的。堆的内存地址生长方向与栈相反，由低到高，但需要注意的是，后申请的内存空间并不一定在先申请的内存空间的后面，即p2指向的地址并不一定大于p1所指向的内存地址，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存，从而导致先后分配的内存空间在地址上不存在先后关系。堆中存储的数据的若未释放，则其生命周期等同于程序的生命周期。 关于堆上内存空间的分配过程，首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表。 堆和栈的区别堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别： （1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏； （2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB； （3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。 （4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。 （5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。 （6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。 从以上可以看到，堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。 无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>writen</tag>
        <tag>exam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为软件笔试---汽水瓶编程]]></title>
    <url>%2F%2Fhuawei-qishuiping%2F</url>
    <content type="text"><![CDATA[摘要题目：有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？ 思路及解决输入描述: 输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1&lt;=n&lt;=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。 输出描述: 对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。 输入例子1:1234310810 输出例子1:1231540 python 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849'''有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？'''import sysdef data_capture(): data = [] while True: # print("请输入数据:") line = sys.stdin.readline().strip() if line == '0' or not line: # print("输入的数据为：", data) break else: # tmp = list(map(int, line.split(" "))) tmp = int(line) data.append(tmp) return datadef get_result(data_in): data_he = 0 data_kong = 0 while True: data_he = data_he + data_in//3 data_kong = data_in % 3 + data_in // 3 data_in = data_in // 3 + data_in % 3 if data_in &lt; 2: break elif data_in == 2: data_he = data_he + 1 break # print("可以喝: %d , 留有空瓶：%d" % (data_he, data_kong)) print(data_he) return data_heif __name__ == "__main__": get_data = [] data_get = data_capture() for k in data_get: get_value = get_result(k) get_data.append(get_value)]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>writen</tag>
        <tag>exam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python在线笔试学习笔记]]></title>
    <url>%2F%2Fwritenexam%2F</url>
    <content type="text"><![CDATA[摘要本文主要介绍一些算法笔试过程中的几个输入输出python语句的代码格式 Edit By Porter, 积水成渊,蛟龙生焉。 字符串型单行输入123import sysline = sys.stdin.readline().strip()print(line)#输出的字符串 多行输入1234567891011121314151617import sysif __name__ == "__main__": data=[]while True: line = sys.stdin.readline().strip() if not line: break data.append(line)print("-".join(data)) 比如输入1 2 3输出：1-2-3 数值型输入数字12n=int(input())print(n)#输出为数字 单行输入输出为数组12l=list(map(int,input().split(" ")))print(l) 输出形式为矩阵12345678910import sysif __name__ == "__main__": data=[]while True: line = sys.stdin.readline().strip() if not line: break tmp = list(map(int, line.split(" "))) data.append(tmp)print(data)]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>writen</tag>
        <tag>exam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方便的在线高速文件共享]]></title>
    <url>%2F%2Ffiletosendanyway%2F</url>
    <content type="text"><![CDATA[摘要[v] 百度网盘，上传下载都要客户端很不方便； [v] 打印店还要带u盘？病毒太多，u盘携带易丢 [v] 下载速度太慢，上传速度也太慢 [v] 分享个文件超过多大后还要登录账号或者依靠客户端才能下载 烦恼如此之多，如何解决 生活中你是否遇到过这么多的不如意，下面介绍几个免费，免注册，免VIP高速在线上传下载的文件分享神奇。 推荐使用场所： 打印店打印资料，电脑分享文档，音乐，视频；淘宝资料发货(可设置过期时间和过期的下载次数)；危险亚健康的数据(加密性好，无记录账号等个人信息，谁知道是谁传的，就是安全)；传你所不敢传，分享你所不敢分享；方便才是王道。 以上都是废话，下面才是干获，如何使用，客官还请见下文 第一个、超高颜值的—牛奶快传牛奶快传,是我很喜欢的一个文件分享网站，特点如下： 安全、可加密等特点就不说了 免注册即可高速上传和下载文档 支持批量上传 共享可以是链接和取件码 取件码形式下载文件(我最喜欢的，省去了短连接转换) 提供免费的5G私人网盘(仅需邮箱就可以注册拥有) 我们感受下上下传的速度吧 取件码形式下载文件共享还可以直接登录这个短的官网首页，输入你共享文件生成的共享取件码即可下载文件,这是我认为最方便的一点，很喜欢 支持批量上传不仅上传飞快，还支持文件的批量上传。下载文件时也几乎是满速状态，完全不会出现像某盘那样的限速问题。 提供免费的5G私人网盘如果你想要私人网盘空间，你可以随便搞个邮箱就注册拥有私人空间了 第二个、Firefox Sendsend.firefox.com,也是一个很不错的文件分享网站，特点如下： 安全、可加密等特点就不说了 免注册即可高速上传和下载文档 共享可以是链接 非注册用户可上传最大 1G 的文件，注册后可上传 2.5G 的文件，文件均保留 24 小时。 但这款工具的最大特点，是安全性强。可选择文件有效的时间、天数、下载次数。 但是呢，这个不能取件码式下载文件,但是也有很方便的解决办法哦 不错就是短连接配合使用。 推荐使用短连接suo.im,可以设置短连接的失效时间，比较不错的。 短连接使用步骤： 用Firefox Send 生成共享文件链接，然后打开suo.im短连接网,然后执行生成短连接即可。 第三个、Sendanywhere（这个需要翻墙）Sendanywhere,这个是我曾经使用的，加密性很好，给朋友共享病毒发毒瘤啥的，很方便呀，大文件也可以，由于这款软件不具备国内小朋友们玩，能出去的就自己探索下吧，功能不小，很方便呀。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>file</tag>
        <tag>share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[anaconda运行出错现象及解决办法]]></title>
    <url>%2F%2FanacondaError%2F</url>
    <content type="text"><![CDATA[摘要本文记录ubuntu环境下的anaconda错误的现象及解决办法，为后期作死，做点善事。 出错一、由于ubuntu操作系统更新或者qt版本问题导致（PyQt5分段错误（核心转储））执行如下命令解决 1conda install -c anaconda pyqt]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>anaconda</tag>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[argparse模块使用学习笔记]]></title>
    <url>%2F%2Fargparsenotes%2F</url>
    <content type="text"><![CDATA[摘要argparse是一个命令行参数解析模块，本文主要介绍python的终端交互模块argparse模块的一些简单而常用的使用方法。 首先导入一个简单的例子 123import argparseparser = argparse.ArgumentParser()parser.parse_args() 以上的简单例子，就构成了，一个简单的命令行参数解析的例子。通过执行 1python test.py --help 将会有了参数用法的提示说明输出。 下面开始正式的介绍这个模块的用法 为你的程序添加描述12345import argparseparser = argparse.ArgumentParser()parser.add_argument('--echo')parser.description = '这是个测试脚本'args = parser.parse_args() parser.description 是一个程序的描述性语句。 最终终端输入 1python test.py --help 执行该语句就会有相应的脚本描述被打印出来 必选参数和选择性填入的参数语法123456789import argparseparser = argparse.ArgumentParser()#该参数是必须在终端有输入parser.add_argument("ParA", help="我是A",type=int) #该参数是在终端可以有选择性输入的参数parser.add_argument("--ParB", help="我是A",type=int) args = parser.parse_args()print(args.ParA)print(args.ParB) 在参数的定义前面,未加双横线，表示终端中必须要有的一个参数；加了双横线表示，终端输入中可以不适用该参数。 提取命令行中输入参数的类型123456789import argparseparser = argparse.ArgumentParser()parser.add_argument("ParA", help="我是A",type=int)parser.add_argument("ParB", help="我是B",type=int)args = parser.parse_args()if args.ParA == 1: print('您的ParA参数输入正确，确实是1')else print('请输入正确的参数，参数的输入不应该是&#123;&#125;'%) 对于需要输入int类型的参数，只需要写入type=int. 下面使用一个完整的例子123456import argparseparser = argparse.ArgumentParser()parser.add_argument('--echo')parser.description = '这是个测试脚本'args = parser.parse_args()print(args.echo) 我们针对这个例子，在终端中输入如下命令，将会有相应的效果。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>python moudle</tag>
        <tag>argparse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-neat网页代码压缩去空格]]></title>
    <url>%2F%2Fhtmlyasuo%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要本文主要介绍，网页空间压缩的办法，去除html或其他脚本中的空格和无用的换行符，注释等，以减少网页文件的响应速度，实现web的快速响应。 安装和配置 错误解决 附录 安装和配置 在你网站的根目录安装npm模块 1npm install hexo-neat --save 配置站点文件_config.yml 123456789101112131415161718192021222324252627# 网页压缩，去掉空格，提升响应速度# hexo-neat https://github.com/rozbo/hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude: - '**/index.h' # 压缩css neat_css: enable: true exclude: - '**/*.min.css' - '**/*cntl.css'# 压缩jsneat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/*.cntl.js' - '**/jquery.fancybox.pack.js' - '**/index.js' - '**/love.js' 这里exlude是排除的选项，根据自己的来合理调整 具体的配置语法，见hexo-neat 错误解决通过上面的配置后，我们还是会编译出错，常见错误及解决办法如下 错误现象 遇到尖括号就报错啥的 12345FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Parse Error: &lt;--&gt; C2: Cool label&lt;/p&gt;&lt;ul&gt;&lt;li&gt;具体使用&lt;a href="https://github.com/knsv/mermaid"&gt;帮助文档请移步github&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 解决办法查找这个文件node_modules/hexo-neat/index.js [ x ] 我的文件路径为： 1/GitHub_Projects/porterpan.github.io/node_modules/hexo-neat/index.js [ x ] 改写里面的代码： 123 ignoreCustomComments: [/^\s*more/],///&lt;[^&gt;]*&gt;/去除所有的标签 ignoreCustomFragments: [/&lt;[^&gt;]*&gt;/,/&lt;img[^&gt;]*&gt;/], ignoreCustomFragments: [/&lt;[^&gt;]&gt;/,/&lt;img[^&gt;]&gt;/],是新加的。忽略尖括号和图像链接 改变的整个代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* global hexo */var assign = require('object-assign');//module.exports = function (hexo) &#123; if (true === hexo.config.neat_enable) &#123; // HTML minifier hexo.config.neat_html = assign(&#123; enable: true, exclude: [], ignoreCustomComments: [/^\s*more/], ///&lt;[^&gt;]*&gt;/去除所有的标签 ignoreCustomFragments: [/&lt;[^&gt;]*&gt;/,/&lt;img[^&gt;]*&gt;/], removeComments: true, removeCommentsFromCDATA: true, collapseWhitespace: true, collapseBooleanAttributes: true, removeEmptyAttributes: true, minifyJS: true, minifyCSS: true, &#125;, hexo.config.neat_html); // Css minifier hexo.config.neat_css = assign(&#123; enable: true, exclude: ['*.min.css'] &#125;, hexo.config.neat_css); // Js minifier hexo.config.neat_js = assign(&#123; enable: true, mangle: true, output: &#123;&#125;, compress: &#123;&#125;, exclude: ['*.min.js'] &#125;, hexo.config.neat_js, &#123; fromString: true &#125;); var filter = require('./lib/filter'); hexo.extend.filter.register('after_render:html', filter.logic_html); hexo.extend.filter.register('after_render:css', filter.logic_css); hexo.extend.filter.register('after_render:js', filter.logic_js); &#125;//&#125; 附录常见的正则表达式及注释 12345678910protected void Page_Load(object sender, EventArgs e) &#123; //string regexstr = @"&lt;[^&gt;]*&gt;"; //去除所有的标签 //@"&lt;script[^&gt;]*?&gt;.*?&lt;/script &gt;" //去除所有脚本，中间部分也删除 // string regexstr = @"&lt;img[^&gt;]*&gt;"; //去除图片的正则 // string regexstr = @"&lt;(?!br).*?&gt;"; //去除所有标签，只剩br // string regexstr = @"&lt;table[^&gt;]*?&gt;.*?&lt;/table&gt;"; //去除table里面的所有内容 string regexstr = @"&lt;(?!img|br|p|/p).*?&gt;"; //去除所有标签，只剩img,br,p str = Regex.Replace(str, regexstr, string.Empty, RegexOptions.IgnoreCase); &#125;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>网站压缩</tag>
        <tag>hexo-neat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于本修改过主题的blog写作格式]]></title>
    <url>%2F%2Fbolgwriteformat%2F</url>
    <content type="text"><![CDATA[摘要本文记录写博客文章，在我修改后的主题中的写作格式，格式固定后按照格式写作，可以保证效果最佳。 Edit By Porter, 积水成渊,蛟龙生焉。 文章开头的写作格式-[x] title: 基于本修改过主题的blog写作格式 在博客中显示的文章题目 -[x]localimage: image1 暂时该参数未使用 -[x]urlname: installgitbook 打开该文章后，显示该文章的网址后缀 -[x]categories:-[x] summary 文章归类 -[x]tags: [System Conf,Github] 文章标签 -[x]date: 2018-6-10 22:55:03 文章写作时间 1234567title: 基于本修改过主题的blog写作格式localimage: image1urlname: installgitbookcategories: summary tags: [System Conf,Github]date: 2018-6-10 22:55:03 完整的开头格式1234567891011121314151617---title: 基于本修改过主题的blog写作格式localimage: image1urlname: installgitbookcategories: summary tags: [System Conf,Github]date: 2018-6-10 22:55:03---# 摘要本文记录了 Ubuntu18安装Gitbook的相关步骤，和某些关键的终点输入指令，本文不是指导如何调试代码和修复代码，本文给出了一种安装的方法，具体修复方法见文中内容所示。- [x] Edit By Porter, 积水成渊,蛟龙生焉。&lt;!-- more --&gt; 文章本地图片加载本部分分两种本地图片加载的方式 文章在post下的本地图片加载（md）在该模式下，文章中的图片要放在以image[x]开头的图片文件夹中，并且文件夹image[x]要放在source目录下。 引用图片的格式为： 1![peek 软件安装演示效果](./image1/Peek_yanshi.gif) 而文章要放在，_post路径下。 文章在source目录下的本地图片加载（html）这种模式下，请仿照，diary路径下。的html来操作就好 解析本地图片加载的代码优化加载本地图片是需要通过修改index.js文件实现 12porterpan.github.io/node_modules/hexo-asset-image/index.js 代码修改后的整体代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;function getLocation(str, n) &#123; var index=str.lastIndexOf('/'); for (var i = 0; i &lt; n-1; i++) &#123; index=str.lastIndexOf('/',index-1); &#125; var location=str.substring(index+1); return location;&#125;hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; var beginPos = getPosition(link, '/', 4); // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". var endPos = link.lastIndexOf('/'); link = link.substring(beginPos, endPos); // link = getLocation(data.permalink, 3); // link = link.split('/')[0] console.info&amp;&amp;console.info("yuanshi link:" + data.permalink+"del link: "+link); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); var src_temp = getLocation(src, 3); console.info&amp;&amp;console.info("yuanshi src:" + src+" del src: "+src_temp); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); //$(this).attr('src', config.root + link + src); //notes: src is image name,and config.root is localhost:port,the middle cahr string is my local image Repository if(src_temp.split('/')[1].substring(0,5)=="image")&#123; link = src_temp.split('/')[1]+'/'; &#125;else&#123; var link_temp = getLocation(data.permalink, 3); link = link_temp.split('/')[1]+'/'; // link = '' // src = src_temp &#125; if(src_temp.substring(0,5) =="img/a")&#123; link="diary/img/"; console.info&amp;&amp;console.info("judement the seventh capture!"); &#125; $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + "==" + link + "==" + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); console.info&amp;&amp;console.info('config file = porterpan.github.io/node_modules/hexo-asset-image/index.js') &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;);]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字节跳动笔试-算法岗（2019/07/31）]]></title>
    <url>%2F%2Fzjtdbs%2F</url>
    <content type="text"><![CDATA[摘要本文章介绍的字节跳动2019年的笔试过程回忆，本次笔试分为两个考题，因为面试的算法岗，所以笔试都为编程题。 代码可选，c/c++/java/python 等 内容包括如下： 第一道题，关于排序 第二道题关于发牌 本人第一次参加这种刷题，可能代码比较乱，但是功能都已实现，仅供参考，谢谢批评指正 Edit By Porter, 积水成渊,蛟龙生焉。 字节跳动笔试（2019/07/31）字节跳动笔试题目回忆 第一道题，对一串数据进行排序 比如给一串数: [-1, 3, 2, 4, 5, -6, -7, -9], 输出为：[3, -1, 2, -6, -4, -9, 5, 7] 题目要求：我们输入一串数据后, 我们能够对其排序，开始第一个是正数，后面的是正数和负数交替穿插，要求排序后的正负数排列顺序不能改变 实现代码如下：123456789101112131415161718192021222324252627282930313233343536#coding=utf-8import sysdef sort(n): n_p = [] # 正数 n_n = [] sort_resut = [] count = 0 for i in n: if i &gt;= 0: n_p.append(i) else: n_n.append(i) if n[0] &gt;= 0: flag_flip = 1 # 正数 else: flag_flip = 0 # 负数 for i_num in range(len(n)): if i_num &lt; len(n_p): sort_resut.append(n_p[i_num]) if i_num &lt; len(n_n): sort_resut.append(n_n[i_num]) return sort_resutif __name__ == "__main__": ''' zjtd 第一题 ''' for line in sys.stdin: n_input = line.split() n_input = list(map(int, n_input)) sort_resut = sort(n_input) print(sort_resut) 第二道题，对发牌进行推算原来的牌的顺序 手上一碟牌(从上往下堆叠) 第一步，先发最上一张牌到桌子上 第二步，从手中剩下的一叠牌中，最上面的一张放到手上一叠牌的最下面 反复第一第二步骤进行发牌到桌子上也是从上到下堆成一叠 直到牌发完 题目要求：需要输入两个参数： 输入行数n，代表你将要把整个数据分几行输入 发牌的数据，分成n行输入 能正确推算出手上原来出牌的顺序 示例：手中一碟牌按照如上要求发完叠到桌子上 桌子上的从上到下牌为：[4, 2, 3, 1] 请推算原来手上的牌从上到下的顺序： 举例输入参数n=2 牌的数据为[4, 2, 3, 1] 所以输入终端应该下面代码操作所示。 计算结果为：[1, 2, 3, 4] 实现代码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#coding=utf-8import sysdef sortresult(pai_list = [4, 2, 3, 1]): list_result = [] while (True): list_len = len(pai_list) # list_len_j = int(list_len) for j in range(list_len): num_j = j * 2 if list_len - num_j - 1 &gt;= 0: list_result.append(pai_list[list_len - num_j - 1]) else: break # print("ff:", pai_list) number = [] for i in range(list_len): num_j = i * 2 if list_len - num_j - 1 &gt;= 0: number.append(list_len - num_j - 1) else: break # print("ff:index", number, 'list:', pai_list) for del_index in number: pai_list.pop(del_index) if list_len &lt;= 1: break return list_resultif __name__ == "__main__": ''' zjtd 第二题 ''' pai_list = [] n = input() for i in range(int(n)): line = sys.stdin.readline().strip().split(' ') for li in range(0, len(line)): values = line[li] values = int(values) pai_list.append(values) list_result = sortresult(pai_list) print("result:", list_result)]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>算法岗</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加Gitment评论功能]]></title>
    <url>%2F%2FhexoFitment%2F</url>
    <content type="text"><![CDATA[摘要 修改代码 添加gitment 设置githubOAuth 初始化评论 常见问题 修改代码我们要加入gitment评论功能，需要修改yelee 该脚本的路径为： 1GitHub_Projects/porterpan.github.io/themes/yelee/layout/_partial/article.ejs 这个文件中需要修改的地方为原该脚本的82行 123456789101112131415161718192021222324&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; &lt;% if (theme.duoshuo.on) &#123; %&gt; &lt;%- partial('comments/duoshuo', &#123; key: post.path, title: post.title, url: config.url+url_for(post.path), &#125;) %&gt; &lt;% &#125; else if (theme.youyan.on) &#123; %&gt; &lt;%- partial('comments/youyan') %&gt; &lt;% &#125; else if (theme.disqus.on) &#123; %&gt; &lt;%- partial('comments/disqus', &#123; shortname: theme.disqus.shortname &#125;) %&gt; &lt;% &#125; else if (config.disqus_shortname) &#123; %&gt; &lt;%- partial('comments/disqus', &#123; shortname: config.disqus_shortname &#125;) %&gt; &lt;% &#125; if (theme.gitment_on) &#123; %&gt; &lt;%- partial('comments/gitment', &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;% &#125; %&gt; 也就是添加的 1234567if (theme.gitment_on) &#123; %&gt; &lt;%- partial('comments/gitment', &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;% &#125; %&gt; 这句判断。 添加gitment然后去下载itment.ejs 将gitment.ejs放到该路径中即可： 1GitHub_Projects/porterpan.github.io/themes/yelee/layout/_partial/comments/gitment.ejs gitment.ejs 文件内容为 123456789101112131415161718192021222324252627&lt;div id="gitment-ctn"&gt;&lt;/div&gt; &lt;!--汉化--&gt;&lt;link rel="stylesheet" href="https://porterpan.github.io/gitment/link_src/gitment.css"&gt;&lt;script src="https://porterpan.github.io/gitment/link_src/gitment.js"&gt;&lt;/script&gt;&lt;!--&lt;link rel="stylesheet" href="gitment/gitment.css"&gt;&lt;script src="gitment/gitment.js"&gt;&lt;/script&gt;--&gt;&lt;!--原型--&gt;&lt;!--&lt;link rel="stylesheet" href="//imsun.github.io/gitment/style/default.css"&gt;&lt;script src="//imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt;--&gt;&lt;script&gt;var gitment = new Gitment(&#123; id: "&lt;%=url%&gt;", owner: '&lt;%=theme.gitment_owner%&gt;', repo: '&lt;%=theme.gitment_repo%&gt;', oauth: &#123; client_id: '&lt;%=theme.gitment_oauth.client_id%&gt;', client_secret: '&lt;%=theme.gitment_oauth.client_secret%&gt;', &#125;,&#125;)gitment.render('gitment-ctn')&lt;/script&gt; 设置githubOAuthgithub 网页的OAuth的配置如下图 之后我们应该把本地的地址改为你仓库的地址 根目录的_config.yml配置如下 初始化评论提示未初始化 1Error: Comments Not Initialized 解决办法：直接登录你的github,进入存放评论的仓库，选择Issue菜单，新建一条评论即可，如下图 或者直接在页面登录你的github账号进行初始化 常见问题配置成功后的效果 注意 如果你的网页后缀字符长度超过50个字符，就会提示未初始化，或者初始化不成功，如下图，后缀超过了50个 解决办法 将你的网址缩短，具体怎么缩短，看我这篇文章如何把博客文章缩短，取消之前的带中文路径办法 更加详细的办法，直接看我这个第50次提交版本的源代码，研究下]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>评论插件</tag>
        <tag>Gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo Yelee网址修改为简短的英文]]></title>
    <url>%2F%2FhexoYeleeUrl%2F</url>
    <content type="text"><![CDATA[摘要hexoYelee将以前时间或者文件夹的中文命名修改为简短的英文 -[x] 第一步、修改_config.yml文件内容-[x] 第二步、为每篇文章添加urlname属性 第一步、修改_config.yml文件内容 permalink: /:urlname/ 1234# permalink: :year/:month/:day/:title/# 设置网页显示的地址后缀为文章中自定义的urlname,需要在文章开头加入 urlname: 标签permalink: /:urlname/permalink_defaults: blogs.porterpan.top/ 将permalink:设置为 /:urlname/ 第二步、为每篇文章添加urlname属性 urlname: hexoYeleeUrl 具体内容如下 12345678---title: hexo Yelee网址修改为简短的英文urlname: hexoYeleeUrlcategories: hexotags: [url,英文网址]date: 2019-7-28 22:55:07--- 编译执行以下代码，本地查看效果 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s ok改名成功]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>url</tag>
        <tag>英文网址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter notebook 使用]]></title>
    <url>%2F%2FjupyterGrammer%2F</url>
    <content type="text"><![CDATA[摘要 本文主要介绍jupyter notebook 工具的相关的使用操作, jupyter notebook是一个交互式的笔记本，本身示意web应用，支持40+中语言。 jupyter notebook 安装扩展插件jupyter notebook markdown 文本jupyter notebook markdown字体颜色红色字体 1&lt;font color = red&gt;红色字体&lt;/font&gt; 字体颜色可以举例列举如下，w3c仅仅支持如下16中颜色名。 aqua、black、blue、fuchsia、gray、green、lime、maroon、navy、olive、purple、red、silver、teal、white、yellow。 但是由于是web应用所以支持w3school上罗列的所有颜色。 蓝色斜体蓝色+斜体 123*&lt;font color = blue&gt;蓝色+斜体&lt;/font&gt;*或_&lt;font color = blue&gt;蓝色+斜体&lt;/font&gt;_ 绿色加粗斜体绿色+加粗+斜体 12345***&lt;font color=green&gt;绿色+加粗+斜体&lt;/font&gt;***或_**&lt;font color=green&gt;绿色+加粗+斜体&lt;/font&gt;**_或___&lt;font color=green&gt;绿色+加粗+斜体&lt;/font&gt;___ 改变字体大小5号雅黑 1&lt;font color=steel size=5 face=雅黑&gt;5号雅黑&lt;/font&gt; 文本进行高亮黄色高亮显示 1&lt;mark style=background-color:yellow&gt;改变高亮颜色&lt;/mark&gt; 叠加字体和高亮叠加字体的变化 1&lt;mark style=background-color:yellow&gt;&lt;font color=red size=4 face=雅黑&gt;叠加字体的变化&lt;font&gt;&lt;/mark&gt;]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PDF在线预览嵌入到文章中的模板]]></title>
    <url>%2F%2Fpdfqianruyulan%2F</url>
    <content type="text"><![CDATA[摘要本节主要记录CIFAR-10 图像分类的相关学习笔记，该项目实战代码主要包括，2层卷积层，3层全连接层。 内容包括如下： 需要用到的python基础语法 TensorFlow样本读取机制 TensorFlow代码实现10类图像分类的相关函数和实现过程 提示本部分是一个PDF手稿，暂时未整理排版，只能在电脑端预览本部分的PDF笔记,手机上的PDF笔记将不会显示出来。 Edit By Porter, 积水成渊,蛟龙生焉。 开始放入在线预览PDF PDF在线预览代码截止 以下为正常显示的内容，上方的空白div不可删除 123&lt;div id="pdf1-view1" class=" pdfobject-container" style="height:400px"&gt;&lt;embed class="pdfobject" src="/TensorFlow-index/CIFAR-10 - Colaboratory.pdf#navpanes=1&amp;amp;view=FitH&amp;amp;pagemode=thumbs&amp;amp;page=3" type="application/pdf" style="overflow: auto; width: 100%; height: 180%;" internalinstanceid="29"&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CIFAR-10 图像分类Notes]]></title>
    <url>%2F%2Fcifar10notes%2F</url>
    <content type="text"><![CDATA[摘要CIFAR-10 图像分类PDF笔记本节主要记录CIFAR-10 图像分类的相关学习笔记，该项目实战代码主要包括，2层卷积层，3层全连接层。 内容包括如下： 需要用到的python基础语法 TensorFlow样本读取机制 TensorFlow代码实现10类图像分类的相关函数和实现过程 提示本部分是一个PDF手稿，暂时未整理排版，只能在电脑端预览本部分的PDF笔记,手机上的PDF笔记将不会显示出来。 Edit By Porter, 积水成渊,蛟龙生焉。 以下为截取我部分PDF笔记中的内容 二、TensorFlow读取机制图解 假设我们的硬盘中有一个图片数据集0001.jpg，0002.jpg，0003.jpg……我们只需要把它们读取到内存中，然后提供给GPU或是CPU进行计算就可以了。这听起来很容易，但事实远没有那么简单。事实上，我们必须要把数据先读入后才能进行计算，假设读入用时0.1s，计算用时0.9s，那么就意味着每过1s，GPU都会有0.1s无事可做，这就大大降低了运算的效率。 如何解决这个问题？方法就是将读入数据和计算分别放在两个线程中，将数据读入内存的一个队列，如下图所示： TensorFlow使用文件名队列+内存队列双队列的形式读入文件，可以很好地管理epoch。下面我们用图片的形式来说明这个机制的运行方式。如下图，还是以数据集A.jpg, B.jpg, C.jpg为例，假定我们要跑一个epoch，那么我们就在文件名队列中把A、B、C各放入一次，并在之后标注队列结束。 对于文件名队列，我们使用tf.train.string_input_producer函数。这个函数需要传入一个文件名list，系统会自动将它转为一个文件名队列。 num_epochs：它就是我们上文中提到的epoch数 shuffle：是指在一个epoch内文件的顺序是否被打乱。 12345678910tf.train.string_input_producer( string_tensor, num_epochs=None, shuffle=True, seed=None, capacity=32, shared_name=None, name=None, cancel_op=None) 2.1 tf.WholeFileReader()读取队列目录中的所有文件，并把文件 全部内容 提取出key和value返回。 通常该函数一般用在一个文件就是一个图片的情况下。 读取的代码如下 12345678910111213# 输入文件列表filename = ['A.jpg', 'B.jpg', 'C.jpg']# 创建文件队列filename_queue = tf.train.string_input_producer(filename, shuffle=False, num_epochs=5)# 创建reader对象reader = tf.WholeFileReader()# 从队列中读取key和value值key, value = reader.read(filename_queue)# 初始化变量tf.local_variables_initializer().run()# 入栈线程启动threads = tf.train.start_queue_runners(sess=sess) 如果要使用,请在队列(Queue)中的排列文件名.Read的输出将是一个文件名(key)和该文件的内容(value). 2.2 tf.FixedLengthRecordReader()固定长度记录一个或多个二进制文件，送入队列中。 tf.FixedLengthRecordReader( record_bytes, header_bytes=None, footer_bytes=None, hop_bytes=None, name=None, encoding=None) record_bytes: 整形数，输出的Record中每个文件的长度 1234567891011121314label_bytes = 1 # 2 for CIFAR-100result.height = 32result.width = 32result.depth = 3image_bytes = result.height * result.width * result.depth# Every record consists of a label followed by the image, with a# fixed number of bytes for each.record_bytes = label_bytes + image_bytes# Read a record, getting filenames from the filename_queue. No# header or footer in the CIFAR-10 format, so we leave header_bytes# and footer_bytes at their default of 0.reader = tf.FixedLengthRecordReader(record_bytes=record_bytes)result.key, value = reader.read(filename_queue)]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[古诗词验证码使用百度api自动识别]]></title>
    <url>%2F%2Fgushiciyanzheng%2F</url>
    <content type="text"><![CDATA[摘要本文主要介绍，通过百度的文本识别api，实现爬虫登录中的古诗词验证码自动识别功能。不涉及具体的图像识别代码，本文识别图像中的文本直接通过百度图像本文识别api实现。 本文将围绕这几步展开 百度文本识别的api创建 百度文本识别api调用接口介绍 百度古诗词查询的接口介绍 python爬虫web页面数据清洗 基于百度api的古诗词完整代码 Edit By Porter, 积水成渊,蛟龙生焉。 百度文本识别的api创建创建步骤为： 进入百度AI，右上角点击控制台选择登录 在你的控制台中点击左边栏的文字识别，如下图 进入文字识别后，选择创建应用，如下图 随便填写下，由于我们使用的爬虫可以不用文字识别包，这都不重要了，随便填。 ok应用创建成功 我们会用到三个应用接口参数[AppID, API Key, Secret Key]，如下图所示 我们接下来进行api调用 百度文本识别api调用接口介绍第一步、安装百度文本识别接口的python轮子1pip install baidu-aip 请注意本文是在python3版本下实现的，如果你默认是python2 请用pip3 install baidu-aip 替代上面的命令 第二步、新建AipOcr 对象12345678from aip import AipOcr""" 你的 APPID AK SK """APP_ID = '你的 App ID'API_KEY = '你的 Api Key'SECRET_KEY = '你的 Secret Key'client = AipOcr(APP_ID, API_KEY, SECRET_KEY) 第三步、获取验证码图像1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-import requestsimport http.cookiejar as cookielibfrom PIL import Imageheaders = &#123; 'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Connection': 'keep-alive', 'Cookie': 'ASP.NET_SessionId=jwe1ekgshmlwzy2forzsubsd', 'Host': 'mm.buy.com.cn', 'Referer': 'http://buy.mm.com.cn/mimi/zhaozhao/neiyi/Default.aspx', 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36' &#125;captcha_url = 'http://buy.mm.com.cn/mimi/zhaozhao/neiyi/image.aspx?'# captcha_url = "http://buy.mm.com.cn/mimi/zhaozhao/neiyi/image.aspx"response = session.get(captcha_url, headers=headers, timeout=0.1)# session.cookies.save()# response = session.get(url)image = Image.open(BytesIO(response.content))image.save('./verify.jpg')image = get_file_content('verify.jpg') 第三步、利用创建的AipOcr对象对图片进行识别123456789101112131415161718""" 如果有可选参数 """options = &#123;&#125;options["detect_direction"] = "true"options["probability"] = "true"try: """ 带参数调用通用文字识别（高精度版） """ Accuratemessage = client.basicAccurate(image, options) words = Accuratemessage['words_result'][0]['words'] print("shuchu:", type(words), words) verify_result = verify_result_flow_baidugushici(words)# 自定义数据清洗函数 print(verify_result) return verify_resultexcept: print(Accuratemessage) return '错' verify_result_flow_baidugushici(words)# 这是我数据清洗的函数，在完整代码中有贴出 第四步、对AipOcr识别的结果数据进行清洗这部分直接贴代码，都叫不上清洗，不再重述。 12Accuratemessage = client.basicAccurate(image, options)words = Accuratemessage['words_result'][0]['words'] 这个返回的words就是我们识别的结果的古诗词词组。 百度古诗词查询的接口介绍接下来我们需要进行古诗词匹配，古诗词匹配作者采用的是百度汉语接口 为什么使用这个可以把古诗词验证码中缺失的汉字匹配出来，客官请看图 在百度汉语搜索框中输入 故西辞黄鹤楼 ，这里我们缺失汉字人，所以我们先检索截图，如下图： 请注意图中箭头所示 看到了那个缺失的汉字人了吧 python爬虫web页面数据清洗这部分应该是清洗了，我们用的BeautifulSoup来清洗数据。 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import refrom bs4 import BeautifulSoupdef verify_result_flow_baidugushici(inputpare = '故西辞黄鹤楼'): ''' :param inputpare: 输入古诗词除了缺失待验证的汉字外的其他汉字词组 :return:返回这句古诗词中确实待验证的验证汉字 ''' # 返回结果的数据 headers = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3', 'Accept-Encoding': 'gzip, deflate, br', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Cache-Control': 'max-age=0', 'Connection': 'keep-alive', 'Cookie': 'BAIDUID=3962E06AB8A904AC40FD84F3E2A70D90:FG=1; BIDUPSID=3962E06AB8A904AC40FD84F3E2A70D90; PSTM=1562918639; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; Hm_lvt_010e9ef9290225e88b64ebf20166c8c4=1563587125; BDUSS=p-LTh2WUpIbGJtVzR4TXJpemVVOFBUQTJTTzl5TW1wNXFMN2tvaHcwd1dVVnBkSUFBQUFBJCQAAAAAAAAAAAEAAADbXiAjcGFuY2hhb3BhbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABbEMl0WxDJdQW; H_PS_PSSID=1434_21120_29523_29520_28518_29098_28832_29221_26350_29458; Hm_lpvt_010e9ef9290225e88b64ebf20166c8c4=1563609689', 'Host': 'hanyu.baidu.com', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36' &#125; url = 'https://hanyu.baidu.com/s?wd='+ inputpare +'&amp;from=poem' s = requests.Session() # 不需要验证码直接登录成功 response_page = s.get(url, headers=headers) response_page.encoding = response_page.apparent_encoding soup = BeautifulSoup(response_page.text, features='html.parser') # print(soup) try: try: soup_obj = soup.find("div", class_=u"poem-list-item-body check-red").text except: soup_obj = soup.find("div", class_=u"poem-detail-item-content").text print(soup_obj) except: soup_obj="" # soup_obj = soup.find_all(name="div", attrs=&#123;"class" : "poem-list-item-body"&#125;).text print(type(soup_obj), "输出的字符串为:", soup_obj.strip()) dealords = re.split(r'[， 。]', soup_obj.replace('.', '').strip().lstrip('，').rstrip('。')) print(dealords) similarnumber = 0 comparetext = '' outputtext = '' for i in range(0, len(dealords)): for x in dealords[i]: if x in inputpare: similarnumber += 1 if similarnumber &gt;= 3: comparetext = dealords[i] print(len(comparetext), comparetext) break for i in range(0, len(comparetext)): for x in comparetext[i]: if x in inputpare: similarnumber = 0 else: outputtext=x # print(x) return outputtext 这部分应该也是网页清洗的步骤，虽然代码多点，但是也不是很难理解，暂时先这样贴出来，忘记了，在评论区留言 评论区，采用的DISQUS留言系统，需要翻墙才能展示流言板块，靠缘分了。 到此古诗词验证码的自动识别过程已经带概记录了下，接下来直接贴完整python3的代码，qt5的GUI就不贴了 基于百度api的古诗词完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240# -*- coding: utf-8 -*-import requestsimport http.cookiejar as cookielibimport urllibimport timeimport refrom bs4 import BeautifulSoupfrom aip import AipOcr# import requestsfrom PIL import Imagefrom io import BytesIOsession = requests.Session()# session.cookies = cookielib.LWPCookieJar(filename='cookies')session.cookies = cookielib.LWPCookieJar(filename="cookies.txt")def verify_result_flow_baidugushici(inputpare = '故西辞黄鹤楼'): ''' :param inputpare: 输入古诗词除了缺失待验证的汉字外的其他汉字词组 :return:返回这句古诗词中确实待验证的验证汉字 ''' # 返回结果的数据 headers = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3', 'Accept-Encoding': 'gzip, deflate, br', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Cache-Control': 'max-age=0', 'Connection': 'keep-alive', 'Cookie': 'BAIDUID=3962E06AB8A904AC40FD84F3E2A70D90:FG=1; BIDUPSID=3962E06AB8A904AC40FD84F3E2A70D90; PSTM=1562918639; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; Hm_lvt_010e9ef9290225e88b64ebf20166c8c4=1563587125; BDUSS=p-LTh2WUpIbGJtVzR4TXJpemVVOFBUQTJTTzl5TW1wNXFMN2tvaHcwd1dVVnBkSUFBQUFBJCQAAAAAAAAAAAEAAADbXiAjcGFuY2hhb3BhbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABbEMl0WxDJdQW; H_PS_PSSID=1434_21120_29523_29520_28518_29098_28832_29221_26350_29458; Hm_lpvt_010e9ef9290225e88b64ebf20166c8c4=1563609689', 'Host': 'hanyu.baidu.com', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36' &#125; url = 'https://hanyu.baidu.com/s?wd='+ inputpare +'&amp;from=poem' s = requests.Session() # 不需要验证码直接登录成功 response_page = s.get(url, headers=headers) response_page.encoding = response_page.apparent_encoding soup = BeautifulSoup(response_page.text, features='html.parser') # print(soup) try: try: soup_obj = soup.find("div", class_=u"poem-list-item-body check-red").text except: soup_obj = soup.find("div", class_=u"poem-detail-item-content").text print(soup_obj) except: soup_obj="" # soup_obj = soup.find_all(name="div", attrs=&#123;"class" : "poem-list-item-body"&#125;).text print(type(soup_obj), "输出的字符串为:", soup_obj.strip()) dealords = re.split(r'[， 。]', soup_obj.replace('.', '').strip().lstrip('，').rstrip('。')) print(dealords) similarnumber = 0 comparetext = '' outputtext = '' for i in range(0, len(dealords)): for x in dealords[i]: if x in inputpare: similarnumber += 1 if similarnumber &gt;= 3: comparetext = dealords[i] print(len(comparetext), comparetext) break for i in range(0, len(comparetext)): for x in comparetext[i]: if x in inputpare: similarnumber = 0 else: outputtext=x # print(x) return outputtextdef get_file_content(filePath): ''' 从本地读取古诗词验证码的待识别文字的图片 :param inputpare: 本地验证码图片的保留位置 :return:返回从本地读取的图片 ''' with open(filePath, 'rb') as fp: return fp.read()def verify_by_gushici(): ''' :return: 返回验证码中缺少的古诗词中的那个文字 ''' """ 你的 APPID AK SK """ APP_ID = '16xxxx43' API_KEY = 'IFeIxxxxxxEl' SECRET_KEY = 'S0OPhLxxxxxxxxwX' client = AipOcr(APP_ID, API_KEY, SECRET_KEY) headers = &#123; 'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Connection': 'keep-alive', 'Cookie': 'ASP.NET_SessionId=jwe1ekgshmlwzy2forzsubsd', 'Host': 'buy.mm.com.cn',# 这个主机地址我已经影藏掉了，请自己配置 'Referer': 'http://buy.mm.com.cn/mimi/zhaozhao/neiyi/Default.aspx', 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36' &#125; captcha_url = 'http://buy.mm.com.cn/mimi/zhaozhao/neiyi/image.aspx?' # captcha_url = "http://buy.mm.com.cn/mimi/zhaozhao/neiyi/image.aspx" response = session.get(captcha_url, headers=headers, timeout=0.1) # session.cookies.save() # response = session.get(url) image = Image.open(BytesIO(response.content)) image.save('./verify.jpg') image = get_file_content('verify.jpg') """ 如果有可选参数 """ options = &#123;&#125; options["detect_direction"] = "true" options["probability"] = "true" try: """ 带参数调用通用文字识别（高精度版） """ Accuratemessage = client.basicAccurate(image, options) words = Accuratemessage['words_result'][0]['words'] print("shuchu:", type(words), words) verify_result = verify_result_flow_baidugushici(words) print(verify_result) return verify_result except: print(Accuratemessage) return '错'def log_out(): session.cookies.clear() print("login out")def moni_login(): ''' 模拟客户端登录操作 :return:none ''' headers = &#123; 'Accept': 'application/json, text/javascript, */*; q=0.01', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Connection': 'keep-alive', 'Content-Length': '56', 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'Cookie': 'ASP.NET_SessionId=jwe1ekgshmlwzy2forzsubsd', 'Host': 'buy.mm.com.cn', 'Origin': 'buy.mm.com.cn', 'Referer': 'http://buy.mm.com.cn/mimi/zhaozhao/neiyi/Default.aspx', 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36', 'X-Requested-With': 'XMLHttpRequest' &#125; log_out() url = 'http://buy.mm.com.cn/mimi/zhaozhao/neiyi/login.aspx' code = verify_by_gushici() print(code) # code = '123' # String2 = input("Enter The Value of String2:") form = &#123; 'id': '2035229347', 'pwd': 'dddddd2035229347', 'number': code, 'act': 'dlogin' &#125; # form = urllib.parse.urlencode(form) print(type(code), "su:", form) # time.sleep(2) # 不需要验证码直接登录成功 login_page = session.post(url, data=form, headers=headers, timeout=0.5) context = login_page.content.decode('utf-8') # 保存 cookies 到文件， # 下次可以使用 cookie 直接登录，不需要输入账号和密码 session.cookies.save() print(context)def shoudongxuanzuo(): headers = &#123; 'Accept': 'application/json, text/javascript, */*; q=0.01', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Connection': 'keep-alive', 'Cookie': 'ASP.NET_SessionId=xjen3olvq5lbydin0rgjafqr', 'Host': 'buy.mm.com.cn', 'Referer': 'http://buy.mm.com.cn/mimi/zhaozhao/neiyi/Default.aspx', 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36', 'X-Requested-With': 'XMLHttpRequest' &#125; content = &#123; 'dialogid': '', 'type': 'ts', 'prop': '' &#125; url = "http://buy.mm.com.cn/mimi/zhaozhao/neiyi/reserve.aspx?" url_code1 = verify_by_gushici() print("xuanzdebug:\n%s" % url) # choise_seat = session.get(url, json=content, headers=headers, timeout=0.1) # cookies = dict(cookies_are='working') try: session.cookies.load(ignore_discard=True) print("Cookie正常加载") except: print("Cookie未能加载") choise_seat = session.get(url, params=content, headers=headers, timeout=0.5) # session.cookies.save() context = choise_seat.content.decode('utf-8') print(context)if __name__ == '__main__': # outresult = verify_result_flow_baidugushici('轻罗小扇扑萤')在尔东西北风 # print("output:",outresult) # 图像文字识别结果 # verify_result = verify_by_gushici() # print("verify reslt:",verify_result) moni_login()# 带自动识别古诗词验证码的模拟登录函数 shoudongxuanzuo() # 登录后的操作，这个函数可以省略，内容我也削了]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>验证码</tag>
        <tag>古诗词识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo加载本地图片的方法]]></title>
    <url>%2F%2Fhexoloadlocalimage%2F</url>
    <content type="text"><![CDATA[摘要本文记录了 如何修改hexo以便于实现 Edit By Porter, 积水成渊,蛟龙生焉。 插入本地图片格式 1![xxxx](./image/xxxxx.png)]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>加载本地图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.14 kmeans算法]]></title>
    <url>%2F%2Fkmeans%2F</url>
    <content type="text"><![CDATA[摘要在监督学习中，模型通常是对训练样本进行训练得到模型的参数，而在非监督学习中，训练样本的标记信息是是未知的，需要对未标记的样本数据进行训练来学习其内部的性质及规律。为进一步的数据分析提供基础。对于无监督学习应用最广的就是聚类（clustering） 作用： 有利于增加泛化能力 做了平滑处理 防止过拟合 题外笔记小知识：LRN 层模仿生物神经系统的侧抑制机制，对局部神经元的活动创建竞争机制，使得响应比较大的值相对更大，提高模型的泛化能力,但目前都不大使用，都被Dropout所替代。 Edit By Porter, 积水成渊,蛟龙生焉。 今日分歌单在此 [^1]: Here is the footnote. [^longnote]: Here’s one with multiple blocks. Subsequent paragraphs are indented to show that they belong to the previous footnote.]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>kmean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker 配置权限问题]]></title>
    <url>%2F%2FdockerConf%2F</url>
    <content type="text"><![CDATA[摘要 本文主要介绍Docker 安装结束后的全权限配置问题 一、解决终端运行每次需要运行root权限问题 12porter@porter-Aspire:~$ docker images Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.39/images/json: dial unix /var/run/docker.sock: connect: permission denied 二、解决Pycharm中导入docker时提示权限问题 一、问题分析以上两种问题的出现，都是因为没把当前的用户组加到 /var/run/docker.sock 执行组中去 解决办法步骤一、检查docker.sock 的用户权限情况12ls -l /var/run/docker.socksrw-rw---- 1 root docker 0 Aug 23 09:40 /var/run/docker.sock 步骤二、将当前用户组添加到docker的组中12sudo gpasswd -a $&#123;USER&#125; dockercat /etc/group | grep ^docker 步骤三、重启docker1sudo service docker restart 步骤四、更新docker的用户和组1newgrp docker #更新用户组 步骤五、终端测试可以发现可以不用root权限就可以操作docker相关的命令了 1docker ps #测试docker命令是否可以使用sudo正常使用 二、 问题分析导致问题二中的pycharm出问题的原因是因为file的读写权限的问题，我们只需要改下，出问题的文件的读写权限就可以了 问题的现象如下图 问题的解决方法如下 1sudo chmod a+rw /var/run/docker.sock 然后再重新+一个Docker 看下效果如下]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.20 docker 基础]]></title>
    <url>%2F%2FdockerCommand%2F</url>
    <content type="text"><![CDATA[摘要 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 docker 常见命令-i (interactive, 交互) 以交互式模式运行容器，一般与t搭配运行 -t (tty, 终端) 为容器重新分配一个伪终端输入，通常与i搭配使用 -P (大写) 随机端口映射 -p (小写) 指定端口映射，有以下四种模式 ip:hostPort:containerPort ip::containerPort hostPort:containerPort containerPort –name=”新容器名字” 为容器指定新的名字 -d 后台运行容器，并返回容器id，也即启动守护模式容器 docker ps 查询docker当前运行的进程有哪些。 docker ps -l 查看上一次运行的容器 docker ps -a 查看历史运行过得所有容器 docker ps -n num 查看历史运行过得前num个容器 docker ps -q 查看当前运行容器的编号ID，其他不显示 docker ps –no-trunc:不截断输出(输出很详细) ctrl+P+Q 暂时离开容器，不退出容器 exit 关闭容器并退出 docker start 容器ID 或者容器名name,运行退出后的容器 docker stop 容器ID 或者容器名name,停止运行容器 docker kill 容器ID 或者容器名name,强制停止容器 docker rm ID 删除容器(容器停止后删除) docker rm -f ID 强制删除容器(容器未停止就删除) docker rm -f $(docker ps -a -q) 一次删除当前的所有容器 docker ps -a -q | xargs docker rm 一次删除当前的所有容器 docker rmi ID 删除镜像 docker run -d 镜像的REPOSITORY|ID 后台运行容器(字节这样的话容器会自动退出的，因为没有前台交互，容器会自动退出) docker logs 容器ID, 查看docker上对应容器的日志 docker logs -t 容器ID ;加时间戳 docker logs -t -f 容器ID; 跟随最新的容器日志打印 docker logs -t -f –tail num 容器ID; 跟随最新的容器日志打印,只显示最后的第num个最新的日志 docker top 容器ID ，查看容器内部正在运行的进程 docker inspect 容器ID， 查看容器内部细节 docker attach 容器ID， 进入你之前没有关闭但临时退出的容器 docker exec -t 容器ID 你要操作内部容器的命令； 就是在容器外面执行容器命令，不用非得进入容器才能运行容器命令 docker cp 容器ID:容器内路径 主机路径；将容器内拷贝文件到主机 docker commit ，提交容器副本使之称为一个新的镜像 docker commit -m=”描述性文字” -a=”作者” 容器ID 要创建目标镜像名:版本号TAG; 提交容器副本 docker run -it -v /宿主机绝对目录:/容器内目录 镜像名； 实现本地的宿主机内文件目录和容器内目录文件的对接，类似于移动硬盘的插入 docker run -it -v /宿主机绝对目录:/容器内目录:ro(read only) 镜像名； 实现本地的宿主机内文件目录和容器内目录文件的对接，类似于移动硬盘的插入, ro 容器只能读，不能写]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.15 机器学习算法GBDT]]></title>
    <url>%2F%2FGBDT%2F</url>
    <content type="text"><![CDATA[摘要 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七章 TensorFlow 卷积神经网络]]></title>
    <url>%2F%2FtfCNN7%2F</url>
    <content type="text"><![CDATA[摘要本节主要是学习TensorFlow的相关学习笔记，主要是基础的学习路线，包括简单的实例笔记等。 内容包括如下： TensorFlow 卷积神经网络基础 卷积神经网络常用的函数 CNN原理 代码实现 提示本部分是一个PDF手稿，暂时未整理排版，只能在电脑端预览本部分的PDF笔记,手机上的PDF笔记将不会显示出来。 Edit By Porter, 积水成渊,蛟龙生焉。 第七章 TensorFlow 卷积神经网络7.1 基本概念 全连接NN 每个神经元与前后相邻层的每一个神经元都有连接关系，输入时特征，输出为预测结果。 卷积(Convolutional) 卷积是一种有效提取图像特征的方法，一般用一个正方形的卷积核，遍历图像上的每一像素点。图片上与卷积核对应重叠区域的像素值与卷积核上对应点的权值相乘再求和，再加上偏置，得到一个输出像素。 全零填充(padding) 全零填充可以保证，卷积后的图像尺寸可以保持输入输出大小一致。 7.2 神经网络的常用函数7.2.1 tf.nn.conv2d(输入图像的描述， 卷积核描述，核滑动步长描述，padding=’VALID’)输入图像的描述给出一次喂入的图片数量；像素大小；颜色通道数量 例如: [5, 28, ,28, 3] ,表示一次喂入5张图片，每张图像的像素的大小28x28，颜色通道数为3个。 卷积核描述例如 [3, 3, 1, 16] 表示三行三列1个通道的核函数共16个这样的核函数 一共这样的核函数，也就是说卷积操作后输出图像的深度是16，也就是输出为16通道 核滑动步长例如： [1, 1, 1, 1] 第一个和最后一个1都是固定的，中间两个1是表示为横向坐标和纵向坐标。 paddingpadding = ‘VALID’ 表示不使用填充 padding = “SAME” 表示全零填充 7.2.2 tf.nn.avg_pool(输入描述，池化描述，池化核滑动步长的描述，padding)函数功能：平均池化函数 输入描述：给出一次输入batch张图片的描述，例如：[batch, 28, 28, 6] 表示图像像素大小为28x28 通道数为6。 池化核滑动步长： 例如：[1, 2, 2, 1] 第一个和最后一个都固定为1, 中间两个表示，横纵坐标像素个数。 7.2.3 tf.nn.max_pool(输入描述，池化描述，池化核滑动步长的描述，padding)函数功能：最大池化函数 输入描述：给出一次输入batch张图片的描述，例如：[batch, 28, 28, 6] 表示图像像素大小为28x28 通道数为6。 池化核滑动步长： 例如：[1, 2, 2, 1] 第一个和最后一个都固定为1, 中间两个表示，横纵坐标像素个数。 7.2.4 tf.nn.dropout(上层输入，暂时舍弃神经元的概率)在神经网络的计算过程中，为了减少过多参数常使用dropout的方法，将一部分神经元按照一定概率从神经网络中舍弃。这种舍弃是临时的，仅在训练师舍弃一些神经元。 在使用神经网络时，会把所有的神经元恢复到神经网络中。 dropout 可以有效的减少过拟合 常常在前向传播构建神经网络中使用dropout来减小过拟合加快模型的训练速度 dropout 一般放到全连接网络中 输出 = tf.nn.dropout(上层输入，暂时舍弃神经元的概率)这样就有指定概率的神经元随机被置零，置零的神经元不参加当前轮的参数优化 7.3 CNN： 借助卷积核(kernel)提取特征后，送入全连接网络卷积神经网络可以认为由两部分组成，一部分是对输入图片进行特征提取，另一部分是全连接网络。只不过喂入全连接网络的不再是原始图片，而是经过若干次卷积，激活和池化后的特征信息。 目前经典的卷积神经网络有很多经典的结构，比如：Lenet-5、Alenet、VGGNet、GoogleNet、ResNet.每一种都是以卷积、激活、池化四种操作为基础展开。 7.3.1 卷积神经网络的连个概念局部感知野、权值共享 局部感知野卷积神经网络的出现是受到了生物处理过程的启发，因为神经元之间的连接模式类似于动物的视觉皮层组织。 个体皮层神经元仅在被称为感受野的视野受限区域中对刺激作出反应，不同神经元的感受野部分重叠，使得它们能够覆盖整个视野。 共享权重和偏置理解卷积的一个简单方法是考虑作用于矩阵的滑动窗函数。在下面的例子中，给定输入矩阵 I 和核 K，得到卷积输出。将 3×3 核 K（有时称为滤波器或特征检测器）与输入矩阵逐元素地相乘以得到输出卷积矩阵中的一个元素。所有其他元素都是通过在 I 上滑动窗口获得的： 简单理解就是一张图片的一个通道中的像素是与同样的核函数进行卷积计算的，可以理解为共享相同的权值和偏置。 7.3.2 卷积层 卷积神经网络如上图所示，经过卷积层和后面的全连接网络，其后面的全连接和之前的全连接形式相当，是人工神经网络的样子。但是输入层却有所不同了，之前的人工神经网络的输入层是现将图片打散成一个一维的数据矩阵，在CNN中，数据的输入可以直接是RGB通道的图片。 CNN的输入如果是n个深度的图像数据，那么卷积核(滤波器)的深度也应该是要n个深度。 如下图，三个通道的图像数据矩阵 卷基层将会也是3个深度的核矩阵（滤波器）,卷积的计算过程如下： 矩阵的区域对应卷积核(滤波器)的重叠区域进行权值相乘并最终求和得到一个数值结果，并将该结果作为输出结果。 滤波器将滑过整个图像，重复相同的点积运算。这里 滤波器必须具有与输入图像相同数量的通道； 网络越深，使用的滤波器就越多；拥有的滤波器越多，获得的边缘和特征检测就越多； 7.3.3 卷积层的输出尺寸输出宽度： $\frac{W-F_{w}+2P}{S}+1$ 输出高度：$\frac{H-F_{h}+2P}{S}+1$ 其中： $W$ ：输入图像的宽度 $H$ ：输入图像的高度 $F_{w}$ ：滤波器或内核的宽度 $F_{h}$ ：滤波器的高度 P ：填充 S ：移动步幅 卷积层输出的通道数等于卷积操作期间使用的滤波器的个数。 7.4 卷积神经网络的代码实现卷积、激活函数、池化三个过程可以说是卷基层的标配（有时也会去掉池化）。卷积计算后的激活函数大多使用的ReLU作为激活函数，这样可以保证卷积后的数值如果小于0 则用零替换，否则保持正数的数值不变。 12345678910111213141516171819202122232425262728293031323334353637383940414243def weight_variable(shape): initial = tf.truncated_normal(shape, stddev=0.1) return tf.Variable(initial)def bias_variables(shape): initial = tf.constant(0.1, shape=shape) return tf.Variable(initial)def conv2d(x, W): return tf.nn.conv2d(x, W, stides=[1, 1, 1, 1], padding='SAME')def max_pol_2x2(x): return tf.nn.max_pool(x, ksize=[1,2,2,1],strides=[1,2,2,1],padding='SAME')# 第一层卷积W_conv1 = weight_variable([5,5,1,32])b_conv1 = bias_variable([32])h_conv1 = tf.nn.relu(conv2d(x_image,W_conv1)+b_conv1) # 卷积和激活h_pool1 = max_pool_2x2(h_conv1) # 池化# 第二层卷积W_conv2 = weight_variable([5,5,32,64])b_conv2 = bias_variable([64])h_conv2 = tf.nn.relu(conv2d(h_pool1,W_conv2)+b_conv2) # 卷积和激活h_pool2 = max_pool_2x2(h_conv2) # 池化# 之后是全连接w_fc1 = weight_variable([7*7*64, 1024])b_fc1 = bias_variabl([1024])h_pool2_flat = tf.reshape(h_hool2, [-1. 7*7*64])h_fc1 = tf.nn.relu(tf.matmul(h_pool2, [-1, 7*7*64])+b_fc1)# 使用dropout, keep_prob是一个占位符,训练时为0.5， 测试时为1keep_prob = tf.placeholder(tf.float32)h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)# 再使用全连接将一层前向传播变成onehot编码模式的输出W_fc2 = weight_variable([1024, 10])b_fc2 = bias_variable([10])y_conv = tf.matmul(h_fc1_drop, W_fc2)+b_fc2]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五章 TensorFlow MNIST 手写字识别笔记]]></title>
    <url>%2F%2Ftfshouxiezi%2F</url>
    <content type="text"><![CDATA[摘要本节主要是学习TensorFlow的相关学习笔记，主要是基础的学习路线，包括简单的实例笔记等。 内容包括如下： 部分数学推导 部分代码实现 MNIST手写数字识别的模型训练过程 MNIST手写数字识别的模型测试过程 MNIST手写数字是别的模型应用 提示本部分是一个PDF手稿，暂时未整理排版，只能在电脑端预览本部分的PDF笔记,手机上的PDF笔记将不会显示出来。 Edit By Porter, 积水成渊,蛟龙生焉。 五、 TensorFlow MNIST 手写字识别5.1 具体实现过程MNIST 手写字识别的训练图片是28*28寸的图片。 第一层隐藏层 第一步是将图片矩阵打平处理为 $[image]_{1×784}$ 第二 步是我们将第一层隐藏层将要设置的参数数量，这些数量会影响我们的训练精度，将设我们设置第一层的影藏层权重和偏置参数分别为500个，则可以设置第一个隐藏层的维数为$[\omega_{1}]{784×500}$，同样偏置的维数为$[b{1}]_{1×500}$ 第二层隐藏层 第三步是设置第二层隐藏层的权重和偏置维数，因为我们只需要三层神经网络结构实现，所以我们这一层应该做池化实现onehot，输出应该为1×10的独热编码。所以$\omega_{2}$应该是500行和10列。即 $[\omega_{2}]{500×10}$，$[b{2}]_{1×10}$ 整个流程 5.2 前向传播 训练的过程是，首先输入一批数据，然后对每批数据进行上个流程的计算过程，比如我一批次输入200张图片进行训练。 前向传播算法的代码如下部分代码所示 12345678910111213141516171819202122232425import tensorflow as tfINPUT_NODE = 784OUTPUT_NODE = 10LAYER1_NODE = 500def get_weight(shape, regularizer): w = tf.Variables(tf.truncated_normal(shape,stddev=0.1)) if regularizer != None: tf.add_to_collection('losses', tf.contrib.layers.l2_regularizer(regularizer)(w)) return wdef get_bias(shape): b = tf.Variable(tf.zeros(shape)) return bdef forward(x, regularizer): # []_&#123;784*500&#125; w1 = get_weight([INPUT_NODE, LAYER1_NODE], regularizer) b1 = get_bias([LAYER1_NODE])# relu 非线性函数的，修正线性单元 y1 = tf.nn.relu(tf.matmul(x, w1) + b1) # 这里w= get_weight([500, 784] 因为x=[None,784] w2 = get_weight([LAYER1_NODE, OUTPUT_NODE], regularizer) b2 = get_bias([OUTPUT_NODE]) y = tf.matmul(y1, w2) + b2 return y 5.3 反向传播(最小化损失函数)反向传播过程就是利用梯度下降算法进行最佳的各隐藏层的权值和偏置的优化过程。 一般选择的梯度优化算法有： 批量梯度优化算法 随机梯度优化 自适应梯度优化 等等 train_step = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss, global_step=global_step) 整个流程 前向传播输出结果–&gt; 归一化(softmax()) —&gt; 求取每回batch中样本的输出相似度（交叉熵求求相似度sparse_softmax_cross_entropy_with_logits）—&gt; 得到每个batch中每个样本中的交叉熵均值(tf.reduce_mean()) –&gt;正则化输出–&gt; loss(loss = cem + tf.add_n(tf.get_collection(‘losses’))) 相关函数解释： tf.add_n(p1, p2, p3…) 实现列表中的元素相加 123input1 = tf.constant([1.0, 2.0, 3.0])input2 = tf.Variable(tf.random_uniform([3]))output = tf.add_n([input1, input2]) # = input1 + input2 5.3.1 Softmax(归一化前向传播输出结果)之前我们选择的代价函数为均方误差函数，表达式为 $$loss = \frac{(y-y_)^{2}}{n}$$ 实现的代码如下： 12loss_mse = tf.reduce_mean(tf.square(y_ - y))train_step = tf.train.GradientDescentOptimizer(0.001).minimize(loss_mse) Softmax 归一化操作，实现输出各通道的数值编程, 概率和为1的概率表达形式 $$\mathit{y_{j} = \frac{e^{z^{j}}}{\sum\limits {i} e^{z{i}}}}$$ 如上图所示，softmax函数的作用是归一化，将所有的输出以概率和为1的方式，将输出结果用概率表示。 5.3.2 交叉熵(比较输出和样本标签的相似度)本部分我们不简单的使用均方误差函数，而是使用交叉熵的方式实现 $$H_{y_ (y)} = - \sum_{i}^{} y_{i} _log(y_{i})$$ $y_$为样本的标签，而$y$为前向传播的输出计算结果。 例子： $$y=[0.005899750.87560060.11849965] $$ ,也就是如果batch为1(输入的训练数据，只输入1组含有一个样本的数据，一般训练一个batch会包含多个batch所以，会对本次的batch中的多个交叉熵求取均值“ tf.reduce_mean(ce)”) $$H_{y_ (y)} =−0×log(0.00589975)−1×log(0.8756006)−0×log(0.11849965) \=0.6355716 -0\times log(0.00589975)-1\times log(0.8756006)-0\times log(0.11849965) \= 0.6355716−0×log(0.00589975)−1×log(0.8756006)−0×log(0.11849965) \=0.6355716$$ 实现的代码如下 123ce = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=y, labels=tf.argmax(y_, 1))cem = tf.reduce_mean(ce)loss = cem + tf.add_n(tf.get_collection('losses')) 这里的logits=y, 是前向传播中的3层神经网络的输出层结果$y_{[200×10]}$ tf.nn.sparse_softmax_cross_entropy_with_logits()与tf.nn.softmax_cross_entropy_with_logits的差别 sparse_softmax_cross_entropy_with_logits(_sentinel=None, labels=None, logits=None, name=None) 唯一的区别是sparse的labels是int类型，而非sparse的labels是one-hot类型。 tf.argmax(input,axis)根据axis取值的不同返回每行或者每列最大值的索引 axis = 0: axis=0时比较每一列的元素，将每一列最大元素所在的索引记录下来，最后输出每一列最大元素所在的索引数组。 12345test[0] = array([1, 2, 3])test[1] = array([2, 3, 4])test[2] = array([5, 4, 3])test[3] = array([8, 7, 2])# output : [3, 3, 1] axis = 1: axis=1的时候，将每一行最大元素所在的索引记录下来，最后返回每一行最大元素所在的索引数组。 1234test[0] = array([1, 2, 3]) #2test[1] = array([2, 3, 4]) #2test[2] = array([5, 4, 3]) #0test[3] = array([8, 7, 2]) #0 5.3.3 batch个样本的交叉熵后整体均值计算cem = tf.reduce_mean(ce) reduce_mean()函数的用法举例 123456789101112131415161718import tensorflow as tf x = [[1,2,3], [1,2,3]] xx = tf.cast(x,tf.float32) mean_all = tf.reduce_mean(xx, keep_dims=False)mean_0 = tf.reduce_mean(xx, axis=0, keep_dims=False)mean_1 = tf.reduce_mean(xx, axis=1, keep_dims=False) with tf.Session() as sess: m_a,m_0,m_1 = sess.run([mean_all, mean_0, mean_1]) print m_a # output: 2.0print m_0 # output: [ 1. 2. 3.]print m_1 #output: [ 2. 2.] 5.3.4 正则化在前向传播中将正则化对象设置成$\omega$ $L^{2}$参数正则化 $$\Omega(\theta)=\frac{1}{2} ||\omega||^{2}_{2}$$ 将上面的公式整理可得到 $$\widetilde{J}(\omega;X,y) = J(\omega;X,y)+\alpha \Omega(\theta) \= J(\omega;X,y)+ \frac{\alpha}{2} \omega^{\top}\omega$$ 与之对应的梯度为： $$\triangledown_{\omega} \widetilde{J}(\omega;X,y)=\alpha \omega + \triangledown_{\omega}J(\omega;X,y)$$ 得到$L^{2}$参数正则化的参数$\omega$参数更新的表达式为 $$\omega \leftarrow \omega - \epsilon \triangledown_{\omega} \widetilde{J}(\omega;X,y)$$ 正则化后的代价函数$J(\omega;X,y)$实现代码为 1loss = cem + tf.add_n(tf.get_collection('losses')) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_data# import mnist_forwardimport osBATCH_SIZE = 200LEARNING_RATE_BASE = 0.1LEARNING_RATE_DECAY = 0.99REGULARIZER = 0.0001STEPS = 50000MOVING_AVERAGE_DECAY = 0.99MODEL_SAVE_PATH="./model/"MODEL_NAME="mnist_model"def backward(mnist): x = tf.placeholder(tf.float32, [None, mnist_forward.INPUT_NODE]) y_ = tf.placeholder(tf.float32, [None, mnist_forward.OUTPUT_NODE]) y = mnist_forward.forward(x, REGULARIZER) global_step = tf.Variable(0, trainable=False) ce = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=y, labels=tf.argmax(y_, 1)) cem = tf.reduce_mean(ce) loss = cem + tf.add_n(tf.get_collection('losses')) learning_rate = tf.train.exponential_decay( LEARNING_RATE_BASE, global_step, mnist.train.num_examples / BATCH_SIZE, LEARNING_RATE_DECAY, staircase=True) train_step = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss, global_step=global_step) ema = tf.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY, global_step) ema_op = ema.apply(tf.trainable_variables()) with tf.control_dependencies([train_step, ema_op]): train_op = tf.no_op(name='train') saver = tf.train.Saver() with tf.Session() as sess: init_op = tf.global_variables_initializer() sess.run(init_op) ckpt = tf.train.get_checkpoint_state(MODEL_SAVE_PATH) if ckpt and ckpt.model_checkpoint_path: saver.restore(sess, ckpt.model_checkpoint_path) for i in range(STEPS): xs, ys = mnist.train.next_batch(BATCH_SIZE) _, loss_value, step = sess.run([train_op, loss, global_step], feed_dict=&#123;x: xs, y_: ys&#125;) if i % 1000 == 0: print("After %d training step(s), loss on training batch is %g." % (step, loss_value)) saver.save(sess, os.path.join(MODEL_SAVE_PATH, MODEL_NAME), global_step=global_step)def main(): mnist = input_data.read_data_sets("./data/", one_hot=True) backward(mnist)if __name__ == '__main__': main() 5.4 训练过程5.4.1 指数衰减学习率训练过程我们使用指数衰减学习率实现，梯度下降算法中的学习率以指数形式衰减，可以提高训练的效率。 指数衰减学习率的公式为： $$dlr = lr * dr ^{\frac{globals}{decays}}$$ 各个简写分别为 简写 对应的全程 代表的含义 dlr decayed_learning_rate 指数衰减学习率 lr learining_rate 为学习率初始设定值 dr decay_rate 为学习率的衰减率 globals global_step 记录了当前训练轮数 decays decay_steps 多少轮更新一次学习率 也可以用如下的表达式表示指数衰减学习率的表示 1decayed_learning_rate=learining_rate*decay_rate^(global_step/decay_steps) 具体的实现代码如下： 1234567def exponential_decay(learning_rate, global_step, decay_steps, decay_rate, staircase=False, name=None): 函数的的使用 1234567891011LEARNING_RATE_BASE = 0.8BATCH_SIZE = 200LEARNING_RATE_DECAY = 0.99global_step = tf.Variable(0, trainable=False)train_step = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss, global_step=global_step)learning_rate = tf.train.exponential_decay(learning_rate = LEARNING_RATE_BASE, global_step = global_step, decay_steps = mnist.train.num_examples / BATCH_SIZE, decay_rate = LEARNING_RATE_DECAY, staircase=True) 5.4.2 梯度下降并开始迭代训练上面步骤确定了学习率，并且5.2 节也确定了前向传播，5.3节确定了代价函数，此时可以进行梯度下降算法的迭代训练模型参数 模型的训练，此处选择梯度下降算法，开始训练模型参数，代码如下 1train_step = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss, global_step=global_step) 5.4.3 滑动平均优化模型参数滑动平均可以使训练的模型能在测试数据上更加健壮(好的泛化能力、鲁棒性好),其实滑动平均模型，主要是通过控制衰减率来控制参数更新前后之间的差距，从而达到减缓参数的变化值（如，参数更新前是5，更新后的值是4，通过滑动平均模型之后，参数的值会在4到5之间），如果参数更新前后的值保持不变，通过滑动平均模型之后，参数的值仍然保持不变。 函数的原型如下 1tf.train.ExponentialMovingAverage(decay, num_updates=None, zero_debias=False,name="ExponentialMovingAverage") 参数：decay：实数类型，衰减率。num_updates：可选，为轮数，设置这个参数之后，将会通过min(decay, (1 + num_updates) / (10 + num_updates))函数，从中选择最小值做为衰减率。返回值： ExponentialMovingAverage对象，通过对象调用apply方法可以通过滑动平均模型来更新参数。 计算公式： shadow_variable = decay shadow_variable + (1-decay) variable 计算公式中的shadow_variable为影子变量，也就是变量在更新之前的值，variable是变量现在的值，可能这样说不是很明白，下面用TensorFlow的程序来实现滑动平均模型。 本次模型训练使用的滑动平均算法调用如下： 1234ma_decay = 0.99ema = tf.train.ExponentialMovingAverage(decay = ma_decay, num_updates = global_step) ema_op = ema.apply(tf.trainable_variables()) 总结下； 滑动平均值的参数更新，比如对权重$\omega_{1}$更新，开始轮数为num_updates= 0 次时，$\omega_{1}$初值设置0, 第1轮更新为variable=1($\omega_{1}=1$); decay=0.99 ;此时有： $\omega_{1}$ = $min(ma_decay, \frac{1+0}{10+0})0+(1-min(1-min(decay,\frac{1+0}{10+0})1))= 0.10+(1-0.9)1=0.9$ 训练过程的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#coding:utf-8import timeimport tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_dataimport mnist_forwardimport mnist_backwardTEST_INTERVAL_SECS = 5def test(mnist): with tf.Graph().as_default() as g: x = tf.placeholder(tf.float32, [None, mnist_forward.INPUT_NODE]) y_ = tf.placeholder(tf.float32, [None, mnist_forward.OUTPUT_NODE]) y = mnist_forward.forward(x, None) ema = tf.train.ExponentialMovingAverage(mnist_backward.MOVING_AVERAGE_DECAY) ema_restore = ema.variables_to_restore() saver = tf.train.Saver(ema_restore) correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1)) accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32)) while True: with tf.Session() as sess: ckpt = tf.train.get_checkpoint_state(mnist_backward.MODEL_SAVE_PATH) if ckpt and ckpt.model_checkpoint_path: saver.restore(sess, ckpt.model_checkpoint_path) global_step = ckpt.model_checkpoint_path.split('/')[-1].split('-')[-1] accuracy_score = sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels&#125;) print("After %s training step(s), test accuracy = %g" % (global_step, accuracy_score)) else: print('No checkpoint file found') return time.sleep(TEST_INTERVAL_SECS)def main(): mnist = input_data.read_data_sets("../MNIST_data/", one_hot=True) test(mnist)if __name__ == '__main__': main() 5.5 模型训练后的断点保存和恢复5.5.1 保存模型在反向传播中，为防止模型训练过程中由于硬件或者断电的情况下，使模型前期训练全部失效，我们一般会在训练了一定间隔轮数后保存当前训练后的神经网络模型。 保存模型后会产生3个文件。 保存当前图解钩的.meta文件 保存当前参数名的.index文件 保存当前参数的.data文件 具体的保存过程代码，如下 123456789MODEL_SAVE_PATH = "./model/"MODEL_NAME = "mnist_model"saver = tf.train.Server()# 实例化Sever对象with tf.Session() as sess: for i in range(STEPS): if i%轮数 == 0: saver.save(sess, os.path.join(MODEL_SAVE_PATH, MODEL_NAME), global_step = global_step) os.path.join() 是将括号中的参数都变成路径的字符形式。 比如，当前的global_step=100，则save后的文件名是“./model/mnist_model-100.meta、./model/mnist_model-100.index ”等 5.5.2 恢复模型恢复训练中的神经网络模型 123ckpt = tf.train.get_checkpoint_state(mnist_backward.MODEL_SAVE_PATH) if ckpt and ckpt.model_checkpoint_path: saver.restore(sess, ckpt.model_checkpoint_path) 恢复模型中调用的滑动平均模型参数 123ema = tf.train.ExponentialMovingAverage(滑动平均基数)ema_restore = ema.variables_to_restore()saver = tf.train.Saver(ema_restore) 5.6 验证阶段神经网络模型准确性的评估方法12correct_prediction = tf.equal(tf.argmax(y,1),tf.argmax(y_, 1))# 返回的都是bool型变量accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))# 将bool型转化为float型，然后求均值 对训练后的模型进行准确度评判 神经网络的测试验证阶段，只需要前向传播的模型，不需要对模型参数进行梯度下降的迭代优化，具体的过程入下 1234567891011121314151617181920212223with tf.Graph().as_default() as g: x = tf.placeholder(tf.float32, [None, mnist_forward.INPUT_NODE]) y_ = tf.placeholder(tf.float32, [None, mnist_forward.OUTPUT_NODE]) y = mnist_forward.forward(x, None) ema = tf.train.ExponentialMovingAverage(mnist_backward.MOVING_AVERAGE_DECAY) ema_restore = ema.variables_to_restore() saver = tf.train.Saver(ema_restore) correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1)) accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32)) # 开始读取保存后的神经网络模型参数，恢复到我们复制Graph()中 ，然后开始准确性判断 with tf.Session() as sess: ckpt = tf.train.get_checkpoint_state(mnist_backward.MODEL_SAVE_PATH) if ckpt and ckpt.model_checkpoint_path: saver.restore(sess, ckpt.model_checkpoint_path) global_step = ckpt.model_checkpoint_path.split('/')[-1].split('-')[-1] accuracy_score = sess.run(accuracy, feed_dict=&#123;x:mnist.test.images, y_:mnist.test.labels&#125;) print("After %s training step(s), test accuracy = %g" % (global_step, accuracy_score)) else: print('No checkpoint file found') return 5.7 训练后的模型使用本部分的过程和测试部分的过程稍微不同的是，需要引入输入待识别的图片的图像预处理工作。 预处理工作，应该是如下步骤 图片的灰度化（0-255取值范围） 将灰度化处理后的图片像素取值进行缩放（0-1的取值范围np.multiply(nm_arr, 1.0/255.0)） 图像的reshape 复制神经网络计算图 tf.Graph().as_default() 然后重保存的神经网络训练参数文件中恢复模型参数 （和测试程序一样，这部分也不需要反向传播优化模型参数） 然后就是用前向传播计算的流程一样 123 x = tf.placeholder(tf.float32, [None, mnist_forward.INPUT_NODE])y = mnist_forward.forward(x, None)preValue = tf.argmax(y, 1) 具体的整体代码如下部分所示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#coding:utf-8import tensorflow as tfimport numpy as npfrom PIL import Imageimport mnist_backwardimport mnist_forwarddef restore_model(testPicArr): with tf.Graph().as_default() as tg: x = tf.placeholder(tf.float32, [None, mnist_forward.INPUT_NODE]) y = mnist_forward.forward(x, None) preValue = tf.argmax(y, 1) variable_averages = tf.train.ExponentialMovingAverage(mnist_backward.MOVING_AVERAGE_DECAY) variables_to_restore = variable_averages.variables_to_restore() saver = tf.train.Saver(variables_to_restore) with tf.Session() as sess: ckpt = tf.train.get_checkpoint_state(mnist_backward.MODEL_SAVE_PATH) if ckpt and ckpt.model_checkpoint_path: saver.restore(sess, ckpt.model_checkpoint_path) preValue = sess.run(preValue, feed_dict=&#123;x:testPicArr&#125;) return preValue else: print("No checkpoint file found") return -1def pre_pic(picName): img = Image.open(picName) reIm = img.resize((28,28), Image.ANTIALIAS) im_arr = np.array(reIm.convert('L')) threshold = 50 for i in range(28): for j in range(28): im_arr[i][j] = 255 - im_arr[i][j] if (im_arr[i][j] &lt; threshold): im_arr[i][j] = 0 else: im_arr[i][j] = 255 nm_arr = im_arr.reshape([1, 784]) nm_arr = nm_arr.astype(np.float32) img_ready = np.multiply(nm_arr, 1.0/255.0) return img_readydef application(): testNum = input("input the number of test pictures:") for i in range(testNum): testPic = raw_input("the path of test picture:") testPicArr = pre_pic(testPic) preValue = restore_model(testPicArr) print("The prediction number is:", preValue)def main(): application()if __name__ == '__main__': main()]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四章个人笔记-神经网络优化笔记]]></title>
    <url>%2F%2Ftfyouhua4%2F</url>
    <content type="text"><![CDATA[摘要本节主要是学习TensorFlow的相关学习笔记，主要是基础的学习路线，包括简单的实例笔记等。 内容包括如下： 部分数学推导 部分代码实现 神经网络的优化过程 正则化过程数学推导 正则化过程代码实现 提示本部分是一个PDF手稿，暂时未整理排版，只能在电脑端预览本部分的PDF笔记,手机上的PDF笔记将不会显示出来。 Edit By Porter, 积水成渊,蛟龙生焉。 第四章、神经网络优化针对《TensorFlow学习笔记》做相关学习笔记，这一段落主要记录神经网络的优化相关的知识。 4.1 正则化的理论知识4.1.1 过拟合神经网络模型在训练数据集上表现很好，但是却在新的预测或者分类的数据集上的表现不是很理想，这就说明模型的泛化能力差，可能存在过拟合现象(也有可能是存在欠拟合的情况) 4.1.2 正则化在损失函数中给每个参数加上权重参数$\omega$加上权重系数$\eta$,引入模型复杂度指标，实现对模型的噪声抑制，避免最终的模型存在过拟合现象。 4.1.3 正则化的理论思路机器学习的大部分带参模型的结构基本上和如下模型形似，模型如下： $$\omega^{*} = arg \min_{\omega} \sum_{i}^{} L(y_{i},f(x_{i};\omega)) + \alpha \Omega(\omega)$$ 其中$\alpha $为正则化系数, 也是一个权值。$\Omega$是一个规则化函数。 [1] 规则化函数$\Omega$ 规则化函数$\Omega$, 有很多种选择，一般是性复杂度的单调递增函数,模型越复杂，规则化值就越大。一般常见的比如L0范数, L1范数，迹范数，Frobenius范数和核范数等等。 [2] 正则化的目标函数 $$\widetilde{J}(\theta;X,y) = J(\theta;X,y)+\alpha \Omega(\theta)$$ $\widetilde{J}$为正则化后的函数； $J(\theta;X,y)$为标准目标函数； $\Omega$是权衡范数惩罚项； $\alpha \in [0, \propto)$是权衡范数惩罚项$\Omega$和标准目标函数$J(\theta;X,y)$的相对贡献超参数； 注解1:分类和回归问题的区别 输入变量与输出变量均为连续变量的预测问题是回归问题； 输出变量为有限个离散变量的预测问题成为分类问题； Logistic回归，也可以说是二分类的情况； 4.1.4 $L^{2}$参数正则化$L_{2}$范数可以防止过拟合，提升模型的泛化能力。 $$\Omega(\theta)=\frac{1}{2} ||\omega||^{2}_{2}$$ 为了简单的表示，我们假设不考虑偏置,模型中只存在权重系数$\omega$,则$\theta == \omega$,代入模型的总的目标函数，得到如下表达式。$$\widetilde{J}(\omega;X,y) = J(\omega;X,y)+\alpha \frac{1}{2} ||\omega||^{2}_{2} \= J(\omega;X,y)+ \frac{\alpha}{2} \omega^{\top}\omega$$ 与之对应的梯度为： $$\triangledown_{\omega} \widetilde{J}(\omega;X,y)=\alpha \omega + \triangledown_{\omega}J(\omega;X,y)$$ 使用单步梯度下降更新权重，即执行如下更新： $$\omega \leftarrow \omega - \epsilon(\alpha \omega + \triangledown_{\omega}J(\omega;X,y))$$ 这种写法对上面的进一步改写就是这样的 $$\omega \leftarrow \omega - \epsilon \triangledown_{\omega} \widetilde{J}(\omega;X,y)$$ 有没有发现 $\epsilon $和梯度下降算法的学习率表达式还是有点相似, 但是别忘了$\widetilde{J}$和$J$两个表达式里面是不一样的。 4.1.5 $L^{1}$参数正则化类似，对模型参数$\omega$的$L^{1}$正则化被定义为： $$\Omega(\theta) = ||\omega||{1} = \sum{i}|\omega_{i}|$$ 对应的正则化目标函数为： $$\widetilde{ J}(\omega;X,y)=\alpha||\omega||_{1}+J(\omega;X,y)$$ 4.1.6 $L^{2}、L^{2}$参数正则化的区别为了便于可视化，我们考虑两维的情况，在(w1, w2)平面上可以画出目标函数的等高线，而约束条件则成为平面上半径为C的一个 norm ball 。等高线与 norm ball 首次相交的地方就是最优解，如下图： 通过这个$L_{1}-ball$和$L_{2}-ball$图像可以看出，$L_{1}$和每隔坐标轴都有“角”的出现，最优解如果出现在轴上，代表对应的轴上的$\omega$参数为0，例如图中的相交点就有w1=0，而更高维的时候（想象一下三维的L1-ball 是什么样的？）除了角点以外，还有很多边的轮廓也是既有很大的概率成为第一次相交的地方，又会产生稀疏性。 相比之下，L2-ball 就没有这样的性质，因为没有角，所以第一次相交的地方出现在具有稀疏性的位置的概率就变得非常小了。这就从直观上来解释了为什么L1-regularization 能产生稀疏性，而L2-regularization 不行的原因了。 注解1:批量梯度下降算法 批量梯度下降算法(batch gradient descent)的公式为： repeat until convergence{$$\theta_{j}: = \theta_{j} - \alpha \frac{\partial}{\partial {j}}J(\theta{0}, \theta_{1}) \qquad (for j = 0 \quad and \quad j = 1)$$} $\alpha$就是学习率, 他决定了代价函数沿着梯度下降程度最大的方向向下迈出的下一步的步长； 其中代价函数的梯度代表下一步迈步的方向； 前面一个负号，代表，方向永远向着局部梯度最优点的方向； 参考来自： 机器学习中的范数规则化之（一）L0、L1与L2范数 小花书 4.2 正则化的代码实现4.2.1 基础知识通过对未经正则化前的散点图和经过正则化后的散点图进行对比，我们可以发现，如果引入正则化后，所能够带来的优势。 4.2.1 TensorFlow基本函数 tf.add_to_collection(‘list_name’,element) 将元素element添加到列表list_name中。 tf.get_collection(‘list_name’) 返回名称为list_name的列表 tf.add_n(list) 将列表元素相加并返回 tf.train.AdamOptimizer() Adam 这个名字来源于 adaptive moment estimation , 自适应矩估计，如果一个随机变量X服从某个分布，X的一阶矩是求取X样本的平均值，表示为$E(X)$。X的二阶矩是表示求取样本的平方的平均值，表示为$E(X^{2})$ Adam 也是基于梯度下降的方法，但是每次迭代参数的学习步长都有一个确定的范围，不会因为很大的梯度导致很大的学习步长，参数的值比较稳定，AdamOptimizer通过动量（参数的移动平均数）来改善传统梯度下降，促进超参数动态调整。 123456789101112import tensorflow as tftf.add_to_collection('losses', tf.constant(2.2))tf.add_to_collection('losses', tf.constant(3.))with tf.Session() as sess: print(sess.run(tf.get_collection('losses'))) print(sess.run(tf.add_n(tf.get_collection('losses'))结果：[2.2, 3.0] 5.2注意： 使用tf.add_n对列表元素进行相加时，列表内元素类型必须一致，否则会报错。 4.3 综合代码包括了正则化，包括指数衰减学习率 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#coding:utf-8#0导入模块 ，生成模拟数据集import numpy as npimport matplotlib.pyplot as pltseed = 2 def generateds(): #基于seed产生随机数 rdm = np.random.RandomState(seed) #随机数返回300行2列的矩阵，表示300组坐标点（x0,x1）作为输入数据集 X = rdm.randn(300,2) #从X这个300行2列的矩阵中取出一行,判断如果两个坐标的平方和小于2，给Y赋值1，其余赋值0 #作为输入数据集的标签（正确答案） Y_ = [int(x0*x0 + x1*x1 &lt;2) for (x0,x1) in X] #遍历Y中的每个元素，1赋值'red'其余赋值'blue'，这样可视化显示时人可以直观区分 Y_c = [['red' if y else 'blue'] for y in Y_] #对数据集X和标签Y进行形状整理，第一个元素为-1表示跟随第二列计算，第二个元素表示多少列，可见X为两列，Y为1列 X = np.vstack(X).reshape(-1,2) Y_ = np.vstack(Y_).reshape(-1,1) return X, Y_, Y_c #print X#print Y_#print Y_c#用plt.scatter画出数据集X各行中第0列元素和第1列元素的点即各行的（x0，x1），用各行Y_c对应的值表示颜色（c是color的缩写） #plt.scatter(X[:,0], X[:,1], c=np.squeeze(Y_c)) #plt.show()#定义神经网络的输入、参数和输出，定义前向传播过程 def get_weight(shape, regularizer): w = tf.Variable(tf.random_normal(shape), dtype=tf.float32) tf.add_to_collection('losses', tf.contrib.layers.l2_regularizer(regularizer)(w)) return wdef get_bias(shape): b = tf.Variable(tf.constant(0.01, shape=shape)) return b def forward(x, regularizer): w1 = get_weight([2,11], regularizer) b1 = get_bias([11]) y1 = tf.nn.relu(tf.matmul(x, w1) + b1) w2 = get_weight([11,1], regularizer) b2 = get_bias([1]) y = tf.matmul(y1, w2) + b2 return y]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨平台好用且小巧的pdf阅读器]]></title>
    <url>%2F%2FlinuxPDF%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要在跨平台的PDF阅读器中，Foxit阅读器还是比较不错的，但是Foxit 在linux下的变现还是有点令人不大满意，首先是看英文文献中，做notes很不convenient，没有快捷键使用注释工具，还不能取词，复制有时也必须在选择模式下才能复制，总之很不方便。下面给推荐两款跨平台，windows和linux都好用的PDF阅读和编辑的软件 master pdf editor5 （破解后很好用哦） Pdf studio viewer 2018(免费版可以做笔记很好用) Foxit Reader（感觉linux里一般般，取词不行，应该是快捷键冲突和复制内容有时抽风） Okular （差强人意吧，但是没什么科夸赞的） master pdf editor5 官方地址Master pdf editor is the most popular and featured rich commercial Linux pdf editor available in the market. You can do almost everything ranging from creating and editing a pdf file to signature handling and editing scanned documents. It provides a wide range of features including add or edit text, images, notes into the pdf documents, offers powerful annotation tools, ability to edit pdf forms etc. Though Master PDF Editor is a proprietary application, still you can do some basic task by using the free version. But digital signatures, encryption, and watermarks are not available in the free version. but there have some approch to get it by crick. master pdf editor5 破解版linux安装教程linux下从get-masterpdfeditor官方下载最新版rpm或者其他方式安装，下面以rpm安装为例1234porter@porter-Aspire:~$ cd ~porter@porter-Aspire:~$ wget https://code-industry.net/public/master-pdf-editor-5.4.10_qt5.x86_64.rpmporter@porter-Aspire:~$ dpkg -i ./master-pdf-editor-5.4.10_qt5.x86_64.rpmporter@porter-Aspire:~$ masterpdfeditor5 # 或者直接去软件中心打开这个安装好的软件 master-pdf-editor软件将会运行界面效果如下 离线激活教程Off Line Activation In order to activate Master PDF Editor in autonomous mode, preform following actions: Double click Master PDF Editor icon on your desktop and choose Help -&gt; Register… Set Offline Activation checkbox on. Activation Code field will appear near Registration Code field. System will also generate unique identifier for you (ID is selected on screenshot below). 出现如下的激活界面： 到此不要看下面一段官方购买的激活教程，我们跳过， 12345Please, copy-paste to e-mail and send ID and Registration Code to our e-mail address support@code-industry.net.Please, inform your Order ID or e-mail address that you used for purchasing! Letter without this information will be ignored!After you receive the response with activation code, do not type it in manually. Instead, copy-paste it to Activation Code field and paste registration code to Registration Code field and then click Activate. 好了，跳转到这，现在告诉你们如何用免费的手段激活 [1.] 找台windows机器，在windows上运行破解软件Keygen.exe [2.] 将 ##masterpdfeditor-5-register## 图片中的ID，复制到破解软件中 [3.] 然后回车，此时破解软件会出现如下激活码信息 [4.] 将破解替换文件文件家中的两个x86/x64根据你自己电脑是64位还是32位选择性复制到你的安装目录中(linux在/opt/master pdf/) [5.] 输入激活码到上图对应的填写位置,点击激活 效果如下 我提供的破解文件里面包含如下文件，exe是windows环境中运行的。rpm是linux中运行的。 windows下从get-masterpdfeditor官方下载最新版exe破解步骤 [1.] 直接安装exe [2.] 将破解替换文件文件家中的两个x86/x64根据你自己电脑是64位还是32位选择性复制到你的安装目录中(windows桌面快捷键右键软件安装位置) [3.] 运行激活软件keygreen.exe产生激活码 [4.] 运行master pdf ，将ID复制出来填写到kegreen.exe后回车，keygreen 将产生激活码，切换到master pdf 填写激活码 [5.] 破解成功 软件汉化参考地址Master PDF Editor怎么设置中文界面 让你的操作更方便 附件供下载331×××@q×.com: master pdf 破解版下载链接: https://pan.baidu.com/s/1iGH2394KU7nG_lde7hRy2Q 提取码: kra8 复制这段内容后打开百度网盘手机App，操作更方便哦 如果软件链接失效可以关注我的telegram并私信给我: @Porter_Pan 文章写作技巧： 12345+ 1.写+ 2.的+ 的+ 对对对+ 的 效果 1.写 2.的 的 对对对 的 123456破解步骤- 1. 直接安装exe - 2. 将[破解替换文件](/appendix/Crack/)文件家中的两个x86/x64根据你自己电脑是64位还是32位选择性复制到你的安装目录中(windows桌面快捷键右键软件安装位置)- [3.] 运行激活软件keygreen.exe产生激活码- [4.] 运行master pdf ，将ID复制出来填写到kegreen.exe后回车，keygreen 将产生激活码，切换到master pdf 填写激活码- [5.] 破解成功 效果 破解步骤 直接安装exe 将破解替换文件文件家中的两个x86/x64根据你自己电脑是64位还是32位选择性复制到你的安装目录中(windows桌面快捷键右键软件安装位置) [3.] 运行激活软件keygreen.exe产生激活码 [4.] 运行master pdf ，将ID复制出来填写到kegreen.exe后回车，keygreen 将产生激活码，切换到master pdf 填写激活码 [5.] 破解成功]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web中插入视频和音乐播放]]></title>
    <url>%2F%2Fmusicplug%2F</url>
    <content type="text"><![CDATA[摘要本文介绍在web中简单的嵌入第三方音乐播放的相关html代码 实现网页上直接可以音乐或者视频的播放，适合博客文章的嵌入 每种播放都写了两种播放样式 Edit By Porter, 积水成渊,蛟龙生焉。 插入视频播放视频在线播放方式1无聊时刻看看剧也不错：123&lt;div&gt;&lt;iframe height=498 width=100% src="https://player.bilibili.com/player.html?aid=38792500&amp;cid=68183480&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"&gt; &lt;/iframe&gt;&lt;/div&gt; 视频播放方式2直接在优酷上打开视屏，选择分享，外链。即可 1&lt;iframe height=498 width=510 src='http://player.youku.com/embed/XNDI4MDk3Mjc0NA==' frameborder=0 'allowfullscreen'&gt;&lt;/iframe&gt; 插入音频播放插入网易云音乐的方法一12345&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&amp;id=1378085345&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt; 插入网易云音乐的方法二点击网易云音乐的某一首歌（不是歌曲列表）,然后选择生成外链，然后选择html外链 12345&lt;iframe frameborder="0" border="1" marginwidth="0" marginheight="0" width="100%" height="132" src="https://music.163.com/outchain/player?type=2&amp;amp;id=2175282&amp;amp;auto=0&amp;amp;height=80"&gt;&lt;/iframe&gt; id：歌曲idauto：0/10表示打开网页的时候不自动播放；1表示打开网页的时候自动播放。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>网页嵌入</tag>
        <tag>音视频嵌入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow的相关学习笔记 part1]]></title>
    <url>%2F%2Ftfnotesp1%2F</url>
    <content type="text"><![CDATA[摘要本节主要是学习TensorFlow的相关学习笔记，主要是基础的学习路线，包括简单的实例笔记等。 内容包括如下： 部分数学推导 部分代码实现 莺尾花数据集 MNIST手写字等 提示本部分是一个PDF手稿，暂时未整理排版，只能在电脑端预览本部分的PDF笔记,手机上的PDF笔记将不会显示出来。 Edit By Porter, 积水成渊,蛟龙生焉。 MNIST 手写字识别程序入门一、部分基础123456import numpy as nptest = np.array([[1,2,3], [2,3,4], [5,4,3], [8,7,2]])np.argmax(test,1) 1.1 线性回归基础1.1.1 最小二乘法曲线拟合问题1.1.2 模型假设理想的线性模型 $$y = 0.99x + 9.31; x \in {[1:1:10]}$$ 假设的线性模型 $$f(x;a,b) = ax + b$$ 1.1.3 最小二乘法确定参数$$f(x;a,b) = ax + b$$ 均方误差函数 $$S = \sum_{i=1}^{n} (y_{i}-(ax_{i}+b))^{2}$$ 对误差求极限，找误差函数的最小值点 $$\frac{\partial S}{\partial a}=-2(\sum_{i=1}^{n}x_{i}y_{i}-b\sum_{i=1}{n}x_{i}-a\sum_{i=1}^{n}x_{i}^{2})$$ $$\frac{\partial S}{\partial b}=-2(\sum_{i=1}^{n}y_{i}-nb-a\sum_{i=1}^{n}x_{i})$$ 令偏导数为零，求得凸函数的极小值点处的a,b 值 $$a=\frac {n\sum_{}^{}{x_iy_i}-\sum_{}^{}{x_i}\sum_{}^{}{y_i}} {n\sum_{}^{}{x_i}^2-(\sum_{}^{}{x_i})^2}$$ $$b = \frac {\sum_{}^{}{x_i}^2\sum_{}^{}{y_i}-\sum_{}^{}{x_i}\sum_{}^{}{x_iy_i}} {n\sum_{}^{}{x_i}^2-(\sum_{}^{}{x_i})^2}$$ 下面用两种代码的实现方式实现上述曲线拟合过程 用户自定义函数代码实现 调用numpy的最小二乘法的线性拟合问题lstsq函数实现 12345678910111213141516171819202122232425262728293031323334# 用户自定义函数代码实现import numpy as npimport matplotlib.pyplot as pltdef calcAB(x,y): n = len(x) sumX,sumY,sumXY,sumXX =0,0,0,0 for i in range(0,n): sumX += x[i] sumY += y[i] sumXX += x[i]*x[i] sumXY += x[i]*y[i] a = (n*sumXY -sumX*sumY)/(n*sumXX -sumX*sumX) b = (sumXX*sumY - sumX*sumXY)/(n*sumXX-sumX*sumX) return a,b,# xi = [1,2,3,4,5,6,7,8,9,10]# yi = [10,11.5,12,13,14.5,15.5,16.8,17.3,18,18.7]xi = [1,2,3,4,5,6,7,8,9,10]# yi = [1 for i in range(10)]yi = [0] * 10print(yi)for num in xi: yi[num -1] = num*1.201030944 + 9.8678999766 a,b=calcAB(xi,yi)print("y = 1.201030944*x + 9.8678999766", '\n', "f(x;a,b) = (a)%3.5fx + (b)%3.5f" %(a,b))x = np.linspace(0,10)y = a * x + bplt.plot(x,y,'red', label='fitting curve')plt.scatter(xi,yi, label='primitive curve')plt.legend(loc='right')plt.title('last square method fitting curve')plt.show() 123456789101112131415161718192021222324# 最小二乘法的线性拟合问题lstsq函数实现import numpy as npimport matplotlib.pyplot as pltx = [1,2,3,4,5,6,7,8,9,10]# y = [10,11.5,12,13,14.5,15.5,16.8,17.3,18,18.7]y = [0] * 10for num in x: y[num -1] = num*1.201030944 + 9.8678999766A = np.vstack([x,np.ones(len(x))]).Ta,b = np.linalg.lstsq(A,y, rcond=-1)[0]print("1.理想曲线:","y = 1.201030944*x + 9.8678999766")print('2.拟合曲线:', "f(x;a,b) = %10.5fx + %10.5f" %(a,b))x = np.array(x)y = np.array(y)plt.plot(x,y,'o',label='idea curve',markersize=10)plt.plot(x,a*x+b,'r',label='fitting curve')plt.legend(loc='upper left')plt.title(' the least-squares solution to a linear matrix equation.')plt.show() 更多内容见上边的PDF在线预览]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-深度学习顶级会议罗列]]></title>
    <url>%2F%2Fml%26dlcomference%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要本文主要罗列出，机器学习-深度学习领域比较知名的学术期刊组织，在学习机器学习相关的技术中，可以前往这些个机构，检索最近最新的研究状况，有针对性的就前沿技术进行挖掘性研究，并针对现有问题，做自己独到的方案。 Edit By Porter, 学海无涯，苦作舟 ICLRthe international conference on learning representations缩写，由位列深度学习三大巨头之二的 Yoshua Bengio 和 Yann LeCun 牵头创办。 The International Conference on Learning Representations (ICLR) is a machine learning conference held every Spring. The conference includes invited talks as well as oral and poster presentations of refereed papers. The first ICLR was held in Scottsdale, Arizona[1]. Since its inception in 2013, ICLR has employed an open peer review process to referee paper submissions (based on models proposed by Yann LeCun[2]). In 2019, there were 1591 paper submissions, of which 500 accepted with poster presentations (31%) and 24 with oral presentations (1.5%) ICML是 International Conference on Machine Learning的缩写即国际机器学习大会。ICML如今已发展为由国际机器学习学会（IMLS）主办的年度机器学习国际顶级会议。 NIPSNeural Information Processing Systems，神经信息处理系统大会是人工智能和机器学习领域最重要的盛会。每年，来自计算机科学领域的各路专家和业界人士都会共聚一堂，共同讨论和分享有关人工智能的前沿想法。而作为大会学术内容最重要的部分，会议论文是众人关注的焦点。 AAAI:AI Conference on Artificial IntelligenceIJCAI:International Joint Conferences on AIICRA:International Conference on Robotics and AutomationIROS:International Conference on Intelligent Robots and SystemsAAMAS:International Conference on Autonomous Agents and Multiagent SystemsRSS:Robotics: Science and SystemsICCV:International Conference on Computer VisionCVPRConference on Computer Vision and Pattern RecognitionCVPR是IEEE Conference on Computer Vision and Pattern Recognition的缩写，即IEEE国际计算机视觉与模式识别会议。该会议是由IEEE举办的计算机视觉和模式识别领域的顶级会议。 简介编辑 国际计算机视觉与模式识别会议（CVPR）是IEEE一年一度的学术性会议，会议的主要内容是计算机视觉与模式识别技术。CVPR是世界顶级的计算机视觉会议（三大顶会之一，另外两个是ICCV和ECCV），近年来每年有约1500名参加者，收录的论文数量一般300篇左右。本会议每年都会有固定的研讨主题，而每一年都会有公司赞助该会议并获得在会场展示的机会。 引用来自百度百科 ECCV:European Conference on Computer Vision]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.18 ubuntu下安装OpenCV 3.4.3]]></title>
    <url>%2F%2Finstallopencvs%2F</url>
    <content type="text"><![CDATA[摘要解决ubuntu 中安装opencv遇到的各种水土不服 下载 安装 ##下载OpenCV 源码 安装依赖包1234567sudo apt-get install build-essentialsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-devsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff5-dev libdc1394-22-dev sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev liblapacke-devsudo apt-get install libxvidcore-dev libx264-dev sudo apt-get install libatlas-base-dev gfortran sudo apt-get install ffmpeg 作者：BlainWu来源：CSDN原文：https://blog.csdn.net/qq_22945165/article/details/84312374版权声明：本文为博主原创文章，转载请附上博文链接！ 下载、安装从第三方源中下载（解决官方github下载网速过慢的问题）123https://ftp.osuosl.org/pub/blfs/conglomeration/opencv/opencv-3.4.3.zip（https://ftp.osuosl.org/pub/blfs/conglomeration/opencv/opencv_contrib-3.4.3.tar.gz）#目前这个control不用下载，以后需要可以下载安装 解压 12cd /你的解压路径/opencv/mkdir ./build cmake 12cd buildcmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. make 1make -j4 安装 1sudo make install 编译中会出现的问题 ippicv_2017u3_lnx_intel64_general_20180518.tgz下载失败 进入opencv解压的文件路径中 —&gt; 找到你的解压路径/opencv-3.4.3/3rdparty/ippicv/ippicv.cmake的文件。 编辑文件：ippicv.cmake 编辑ippicv.cmake内容,替换如下的内容 123456ocv_download(FILENAME $&#123;OPENCV_ICV_NAME&#125; HASH $&#123;OPENCV_ICV_HASH&#125; URL "$&#123;OPENCV_IPPICV_URL&#125;" "$ENV&#123;OPENCV_IPPICV_URL&#125;" "file:///home/blain/Downloads/"# “file:///home/blain/Downloads/“# 这个为你手动下载的文件所在的路径 需手动下载的包的地址如下，自己手动下载，建议存放在opencv解压后的文件夹中方便管理1https://ftp.osuosl.org/pub/blfs/conglomeration/opencv/ippicv_2017u3_lnx_intel64_general_20180518.tgz 我的下载存放地址就是 home/blain/Downloads 。 修改完成，重新cmake 即可]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.19 gym_gazabe安装配置]]></title>
    <url>%2F%2FgymGazabeInstall%2F</url>
    <content type="text"><![CDATA[摘要本文主要记录gym_gazebo安装的过程，想想每次安装都要一堆的百度，过程很痛苦，所以直接记录下我成功安装的过程，方便后面安装的参考。 具体内容如下： 摘要 解决ubuntu 中安装 gym_gazabe 遇到的各种水土不服 Basic requirements: ROS Kinetic dependencies Install Sophus Gazebo gym Dependencies and libraries Agent dependencies Run the environment with a sample agent 解决ubuntu 中安装 gym_gazabe 遇到的各种水土不服Basic requirements: ROS Kinetic (/rosversion: 1.12.7) Gazebo 8.1.1 Python 3.5.2 OpenCV3, installed from sources for Python 3 (git clone https://github.com/Itseez/opencv.git) OpenAI gym 这部分的安装请自行百度, 但是这部分的内容也要安装上，不然安装gym_gazebo会出错的。 ROS Kinetic dependencies12345678910111213141516171819202122232425262728sudo pip3 install rospkg catkin_pkgsudo apt-get install python3-pyqt4sudo apt-get install \cmake gcc g++ qt4-qmake libqt4-dev \libusb-dev libftdi-dev \python3-defusedxml python3-vcstool \libbluetooth-dev libspnav-dev \pyqt4-dev-tools libcwiid-dev \ros-kinetic-octomap-msgs \ros-kinetic-joy \ros-kinetic-geodesy \ros-kinetic-octomap-ros \ros-kinetic-control-toolbox \ros-kinetic-pluginlib \ros-kinetic-trajectory-msgs \ros-kinetic-control-msgs \ros-kinetic-std-srvs \ros-kinetic-nodelet \ros-kinetic-urdf \ros-kinetic-rviz \ros-kinetic-kdl-conversions \ros-kinetic-eigen-conversions \ros-kinetic-tf2-sensor-msgs \ros-kinetic-pcl-ros \ros-kinetic-navigation \ros-kinetic-ar-track-alvar-msgs Install Sophus123456789cdgit clone https://github.com/stonier/sophus -b release/0.9.1-kineticcd sophusmkdir buildcd buildcmake ..makesudo make installecho "## Sophus installed ##\n" Gazebo gym1234cd git clone https://github.com/erlerobot/gym-gazebocd gym-gazebosudo pip3 install -e . Dependencies and libraries1234567891011sudo pip3 install h5pysudo apt-get install python3-skimage# install Theanocd ~/git clone git://github.com/Theano/Theano.gitcd Theano/sudo python3 setup.py develop#install Kerassudo pip3 install keras Agent dependencies 这部分的安装可以参考我的github 仓库(gazebo.repos 已经修改过,并且在ubuntu16上正确编译安装通过，可以直接clone下来安装,我只修改了gazebo.repos,设置/usr/local/python3.5环境): 这部分的安装需要注意请尽量用”/usr/local/bin/python3.5”如果用anaconda的python环境下安装，会出现Cmake 报错,如果你有解决的办法可以忽略提示 切换python 环境，只需要执行如下命令： 1234vim ~/.bashrc# 修改弹出的文本，将export anaconda这行注释掉，如下所示# added by Anaconda3 4.2.0 installer#export PATH="/home/porter/anaconda3/bin:$PATH" 效果如下： 安装前需要配置下Agent 的gazebo.repos123cd ~/gym-gazebo/gym_gazebo/envs/installation/cp ./gazebo.repos ./gazebo.repos.bakgedit ~/gym-gazebo/gym_gazebo/envs/installation/gazebo.repos gazebo.repos 内容如下 主要修改一些github 仓库对应版本release的分支问题, 解决安装时的错误， 修改后的内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168repositories:# ardupilot_sitl_gazebo_plugin:# type: git# url: https://github.com/erlerobot/ardupilot_sitl_gazebo_plugin## version: master ar_track_alvar: type: git url: https://github.com/ros-perception/ar_track_alvar.git version: kinetic-devel mav_comm: type: git url: https://github.com/ethz-asl/mav_comm.git version: master# ar_track_alvar:# type: git# url: https://github.com/sniekum/ar_track_alvar# version: indigo-devel# ar_track_alvar_msgs:# type: git# url: https://github.com/sniekum/ar_track_alvar_msgs# version: indigo-devel catkin_simple: type: git url: https://github.com/catkin/catkin_simple.git version: master control_toolbox: type: git url: https://github.com/ros-controls/control_toolbox.git version: indigo-devel# drcsim:# type: hg# url: https://bitbucket.org/osrf/drcsim# version: default ecl_core: type: git url: https://github.com/stonier/ecl_core version: release/0.61-indigo-kinetic ecl_lite: type: git url: https://github.com/stonier/ecl_lite version: release/0.61-indigo-kinetic ecl_navigation: type: git url: https://github.com/stonier/ecl_navigation version: devel ecl_tools: type: git url: https://github.com/stonier/ecl_tools version: release/0.61-indigo-kinetic driver_base: type: git url: https://github.com/ros-drivers/driver_common.git version: indigo-devel gazebo_ros_pkgs: type: git url: https://github.com/ros-simulation/gazebo_ros_pkgs version: indigo-devel# glog_catkin:# type: git# url: https://github.com/ethz-asl/glog_catkin.git# version: master hector_gazebo: type: git url: https://github.com/tu-darmstadt-ros-pkg/hector_gazebo/ version: indigo-devel image_common: type: git url: https://github.com/ros-perception/image_common.git version: hydro-devel joystick_drivers: type: git url: https://github.com/ros-drivers/joystick_drivers.git version: master kobuki: type: git url: https://github.com/yujinrobot/kobuki version: indigo kobuki_core: type: git url: https://github.com/yujinrobot/kobuki_core version: indigo kobuki_desktop: type: git url: https://github.com/erlerobot/kobuki_desktop version: indigo kobuki_msgs: type: git url: https://github.com/yujinrobot/kobuki_msgs version: indigo# mavros:# type: git# url: https://github.com/erlerobot/mavros.git# version: gazebo_udp# mav_comm:# type: git# url: https://github.com/PX4/mav_comm.git# version: master navigation: type: git url: https://github.com/ros-planning/navigation version: indigo-devel# osrf-common:# type: hg# url: https://bitbucket.org/osrf/osrf-common# version: default pcl_ros: type: git url: https://github.com/ros-perception/perception_pcl.git version: indigo-devel# python_qt_binding:# type: git# url: https://github.com/ros-visualization/python_qt_binding# version: kinetic-devel# qt_gui_core:# type: git# url: https://github.com/ros-visualization/qt_gui_core# version: groovy-devel realtime_tools: type: git url: https://github.com/ros-controls/realtime_tools version: indigo-devel ros_control: type: git url: https://github.com/ros-controls/ros_control version: indigo-devel roslint: type: git url: https://github.com/ros/roslint version: master# rqt:# type: git# url: https://github.com/ros-visualization/rqt# version: groovy-devel# rqt_common_plugins:# type: git# url: https://github.com/ros-visualization/rqt_common_plugins# version: master# rqt_robot_plugins:# type: git# url: https://github.com/ros-visualization/rqt_robot_plugins# version: master turtlebot: type: git url: https://github.com/turtlebot/turtlebot version: indigo turtlebot_create: type: git url: https://github.com/turtlebot/turtlebot_create version: indigo turtlebot_simulator: type: git url: https://github.com/turtlebot/turtlebot_simulator version: indigo xacro: type: git url: https://github.com/ros/xacro version: indigo-devel yocs_msgs: type: git url: https://github.com/yujinrobot/yocs_msgs version: release/0.6-kinetic yujin_ocs: type: git url: https://github.com/yujinrobot/yujin_ocs version: kinetic 具体的修改地方建议，通过code compare 工具查看，这里推荐一个好用而代码比较工具：Meld Diff 比较好用。 接下来执行如下Agent dependences 12cd gym_gazebo/envs/installationbash setup_kinetic.bash Run the environment with a sample agent12cd gym_gazebo/examples/scripts_turtlebotpython circuit2_turtlebot_lidar_qlearn.py]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>gym_gazabe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.18 ubuntu下安装OpenCV 3.4.3]]></title>
    <url>%2F%2Finstallopencv%2F</url>
    <content type="text"><![CDATA[摘要解决ubuntu 中安装opencv遇到的各种水土不服 下载 安装 ##下载OpenCV 源码 安装依赖包1234567sudo apt-get install build-essentialsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-devsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff5-dev libdc1394-22-dev sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev liblapacke-devsudo apt-get install libxvidcore-dev libx264-dev sudo apt-get install libatlas-base-dev gfortran sudo apt-get install ffmpeg 作者：BlainWu来源：CSDN原文：https://blog.csdn.net/qq_22945165/article/details/84312374版权声明：本文为博主原创文章，转载请附上博文链接！ 下载、安装从第三方源中下载（解决官方github下载网速过慢的问题）123https://ftp.osuosl.org/pub/blfs/conglomeration/opencv/opencv-3.4.3.zip（https://ftp.osuosl.org/pub/blfs/conglomeration/opencv/opencv_contrib-3.4.3.tar.gz）#目前这个control不用下载，以后需要可以下载安装 解压 12cd /你的解压路径/opencv/mkdir ./build cmake 12cd buildcmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. make 1make -j4 安装 1sudo make install 编译中会出现的问题 ippicv_2017u3_lnx_intel64_general_20180518.tgz下载失败 进入opencv解压的文件路径中 —&gt; 找到你的解压路径/opencv-3.4.3/3rdparty/ippicv/ippicv.cmake的文件。 编辑文件：ippicv.cmake 编辑ippicv.cmake内容,替换如下的内容 123456ocv_download(FILENAME $&#123;OPENCV_ICV_NAME&#125; HASH $&#123;OPENCV_ICV_HASH&#125; URL "$&#123;OPENCV_IPPICV_URL&#125;" "$ENV&#123;OPENCV_IPPICV_URL&#125;" "file:///home/blain/Downloads/"# “file:///home/blain/Downloads/“# 这个为你手动下载的文件所在的路径 需手动下载的包的地址如下，自己手动下载，建议存放在opencv解压后的文件夹中方便管理1https://ftp.osuosl.org/pub/blfs/conglomeration/opencv/ippicv_2017u3_lnx_intel64_general_20180518.tgz 我的下载存放地址就是 home/blain/Downloads 。 修改完成，重新cmake 即可]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于DQN的gym_gazebo运行代码演示]]></title>
    <url>%2F%2FDQNgym%2F</url>
    <content type="text"><![CDATA[基于DQN的gym_gazebo运行代码演示 基于DQN的gym_gazebo运行代码演示 下载算法包 运行脚本 终端效果 export 端口环境添加 运行ＧＵＩ效果 Edit By Porter, 积水成渊,蛟龙生焉。 下载算法包12git clone https://github.com/ipa-bfb-sc/CSN-RLcd ./CSN-RL 运行脚本12cd ~/文档/GitHub_Projects/CSN-RLqqq/DQNpython3 ./DQN_CirTurtleBot.py ## 终端效果 12345678910111213141516171819porter@porter-Aspire:~/文档/GitHub_Projects/CSN-RLqqq/DQN$ python3 ./DQN_CDQN_CartPole.py DQN_CirTurtleBot.py porter@porter-Aspire:~/文档/GitHub_Projects/CSN-RLqqq/DQN$ python3 ./DQN_CirTurtleBot.py Using TensorFlow backend.ROS_MASTER_URI=http://localhost:12935GAZEBO_MASTER_URI=http://localhost:12936Gazebo launched!Unable to register with master node [http://localhost:12935]: master may not be running yet. Will keep trying.... logging to /home/porter/.ros/log/9b695694-7000-11e9-a24a-f0761cd1b3e0/roslaunch-porter-Aspire-32299.logChecking log directory for disk usage. This may take awhile.Press Ctrl-C to interruptDone checking log file disk usage. Usage is &lt;1GB.started roslaunch server http://porter-Aspire:36739/SUMMARY======== export 端口环境添加此时不会出gazebo，要查看实时的效果，运行如下命令 123porter@porter-Aspire:~$ export ROS_MASTER_URI=http://localhost:12935porter@porter-Aspire:~$ export GAZEBO_MASTER_URI=http://localhost:12936porter@porter-Aspire:~$ gzclient 如果不成功，执行 12345porter@porter-Aspire:~$ cd /home/porter/gym-gazebo/gym_gazebo/envs/installation/catkin_ws/develporter@porter-Aspire:~/gym-gazebo/gym_gazebo/envs/installation/catkin_ws/devel$ source setup.bashporter@porter-Aspire:~$ export ROS_MASTER_URI=http://localhost:12935porter@porter-Aspire:~$ export GAZEBO_MASTER_URI=http://localhost:12936porter@porter-Aspire:~$ gzclient 运行ＧＵＩ效果]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>gym-gazebo</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu16 安装gym-gazebo]]></title>
    <url>%2F%2FubuntuinstallGym%2F</url>
    <content type="text"><![CDATA[目录本节会安装以下内容 Kinetic ubuntu16 gazebo8 gym python3.5 opencv3 安装 gazebo_ros_pkgs gym-gazebo gym-gazebo 测试 本节笔记主要记录ubuntu16 下安装gym-gazebo，包括其依赖的软件包安装。 我的代码仓库: https://github.com/porterpan/gym-gazebo 建议直接clone 我的软件仓库安装(直接适应kinetic版本安装不会出现警告和编译出错终止，当然可能会应为你的ros功能包缺失出错,这时只需要手动安装缺失的ros功能包，删除catkin_ws，再重复上次的安装过程即可) 12cd ~git clone -b master https://github.com/porterpan/gym-gazebo 实在官方的仓库中修改了: ~/gym-gazebo/gym_gazebo/envs/installation/gazebo.repos 文件内容.使整个安装适应ROS kinetic 环境。当然过程中如果缺ros功能包，需要自己额外安装功能包的。 缺失ros功能包会在编译时出现make error 红色的， 解决办法见ROS 中功能包的安装与查询 部分的方法安装好，然后remove -rf 安装路径中的catkin_ws 文件夹，然后重新上一步操作安装即可。 目录 第一部分安装gym-gazebo 下载安装文件 安装依赖环境 Basic requirements: Install Sophus 安装gym-gazebo Dependencies and libraries install Theano install Keras Try it out (turtlebot simple env) Agent dependencies: Run the environment with a sample agent: 第二部分：附录 ROS 中功能包的安装与查询 1.查询当前安装完成的所有包文件 2.查询ros的所有功能包 安装错误解决 错误1： 问题2 问题3： gazebo.repos 内容修改 安装结束效果- [问题4：](#问题4) - [问题5：](#问题5) gym-gazebo 测试 Edit By Porter, 积水成渊,蛟龙生焉。 第一部分安装gym-gazebo下载安装文件12cd ~ #进入home目录git clone -b master https://github.com/porterpan/gym-gazebo 安装依赖环境Basic requirements: ROS Kinetic (/rosversion: 1.12.7) (安装选择这个sudo apt-get install ros-kinetic-desktop, 不要全装不然后面装gazebo8会相对麻烦点) 进入ROS官网的安装界面：http://wiki.ros.org/ROS/Installation 选择需要的版本 Kinetic 和系统平台，我们用的是 ubuntu 16.04按照指导进行安装，这里注意要选择安装 ros-kinetic-desktop 版本，不要选 ros-kinetic-desktop-full，前者不包含 Gazebo ，后者包含了 Gazebo 7。后边安装 Gazebo 8 的时候还需要卸载掉，比较麻烦。按照完 ROS 测试一下，在命令行中输入如下命令，看能否正常启动 ros master ： 作者：isl_qdu链接：https://www.jianshu.com/p/2b4c68b9caaf来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 Gazebo 8.1.1 , 进入选择手动安装，不要选择Default installation: one-liner安装方式，否则会给你安装默认最新版本的gazebo. Python 3.5.2 (# I have yet to find out why though, because all the standard ROS stuff is in Python 2) OpenCV3, installed from sources for Python 3， pip3 或者手动安装(git clone https://github.com/Itseez/opencv.git) 安装 gazebo_ros_pkgs 前边安装的 ROS 与 Gazebo 是完全独立的两部分，要使他们之间互相通讯，还需要安装 gazebo_ros_pkgs 包。 进入官网安装界面：http://gazebosim.org/tutorials?tut=ros_installing 按照指导安装即可。我一般选择用 A: Install Pre-Built Debians 方式安装。需要注意的是，如果用如下命令安装报错：1sudo apt-get install ros-kinetic-gazebo-ros-pkgs ros-kinetic-gazebo-ros-control 则需要指明 Gazebo 版本，将命令改为：1sudo apt-get install ros-kinetic-gazebo8-ros-pkgs ros-kinetic-gazebo8-ros-control 就可以解决问题。 测试。安装结束，用如下命令测试：12roscore # 启动 ros masterrosrun gazebo_ros gazebo # 用 rosrun 方式启动 Gazebo 作者：isl_qdu链接：https://www.jianshu.com/p/2b4c68b9caaf来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 OpenAI gym安装 Install Sophus123456789cd ~git clone https://github.com/stonier/sophus -b release/0.9.1-kineticcd sophusmkdir buildcd buildcmake ..makesudo make installecho "## Sophus installed ##\n" 安装gym-gazebo12345cd ~Gazebo gymgit clone -b master https://github.com/erlerobot/gym-gazebocd gym-gazebosudo pip2 install -e . Dependencies and libraries12sudo pip3 install h5pysudo apt-get install python3-skimage install Theano1234cd ~/git clone git://github.com/Theano/Theano.gitcd Theano/sudo python3 setup.py develop install Keras1sudo pip3 install keras Try it out (turtlebot simple env) Issues: spacenav_node not compiling. CATKIN_IGNOREd.wiimote not compiling. CATKIN_IGNOREd.kobuki_qtestsuite not compiling. CATKIN_IGNOREd. Agent dependencies:1234567# make sure to switch to bash, because the installation script # hasn't been converted to ZSH yet# and if you run it from ZSH the environmental variables # that are set during the script's execution aren't preservedcd gym_gazebo/envs/installation./setup_kinetic.bash ./turtlebot_setup.bash Run the environment with a sample agent:123# only execute this while still in the same bash as last stepcd ../../../examples/scripts_turtlebot/python circuit2_turtlebot_lidar_qlearn.py The result should look like this (after a few seconds): 123456789101112... (messages about ROS and Gazebo starting up, until finally:) ...[ INFO] [1508869124.880487247, 81.480000000]: GazeboRosKobuki plugin ready to go! [mobile_base]EP: 1 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.9] - Reward: -87 Time: 0:00:05EP: 2 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.9] - Reward: -155 Time: 0:00:05EP: 3 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.9] - Reward: -165 Time: 0:00:05EP: 4 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.89] - Reward: -156 Time: 0:00:06EP: 5 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.89] - Reward: -162 Time: 0:00:06EP: 6 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.89] - Reward: -161 Time: 0:00:07EP: 7 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.89] - Reward: -167 Time: 0:00:07EP: 8 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.89] - Reward: -166 Time: 0:00:08EP: 9 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.89] - Reward: -154 Time: 0:00:08EP: 10 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.89] - Reward: -157 Time: 0:00:09 第二部分：附录ROS 中功能包的安装与查询1.查询当前安装完成的所有包文件1rospack list 可以看到所有的ROS功能包都在/opt/ros/kinetic/share目录下，所以也可以使用如下命令查询1234cd /opt/ros/kinetic/share/orroscd turtlesim/cd .. 2.查询ros的所有功能包1apt-cache search ros-kinetic 或者说在不知道要安装功能包的确切名字的情况下找到目标包1apt-cache search ros-kinetic | grep rqt- 通过管道线 与grep命令， 输出与关键字rqt-相关的行 再或者下述安装命令与Tab键结合1sudo apt-get install ros-kinetic-rqt- 系统输出相应提示。前述所有内容中，rospack list 与sudo apt-get install ros-kinetic-rqt- +Tab键使用最方便。 安装错误解决错误1： 错误1：错误提示： 在moveit编译时找不到manipulation_msgsConfig.cmake manipulation_msgs-config.cmake文件 123456789101112Could not find the required component 'manipulation_msgs'. The following CMake error indicates that you either need to install the package with the same name or change your environment so that it can be found.CMake Error at /opt/ros/kinetic/share/catkin/cmake/catkinConfig.cmake:83 (find_package): Could not find a package configuration file provided by "manipulation_msgs" with any of the following names: manipulation_msgsConfig.cmake manipulation_msgs-config.cmake--------------------- 作者：pd很不专业 来源：CSDN 原文：https://blog.csdn.net/qq_42145185/article/details/80975975 版权声明：本文为博主原创文章，转载请附上博文链接！ 错误1：解决： 搜索这个功能包 能找到这个ros-kinetic-manipulation-msgs 包1sudo apt-get install ros-kinetic-manipulation-msgs 对ros安装对应的manipulation_msgsConfig包, 完成安装后重新去编译一下你的moveit包就行了。 问题2 错误二：错误提示： 123456" CMake Error at /opt/ros/kinetic/share/catkin/cmake/catkinConfig.cmake:83 (find_package): Could not find a package configuration file provided by "tf2_geometry_msgs" with any of the following names:tf2_geometry_msgsConfig.cmaketf2_geometry_msgs-config.cmakeAdd the installation prefix of "tf2_geometry_msgs" to CMAKE_PREFIX_PATH or set "tf2_geometry_msgs_DIR" to a directory containing one of the above files. If "tf2_geometry_msgs" provides a separate development package or SDK, be sure it has been installed." 错误二：解决： 先搜索这个需要安装的ros功能包 1apt-cache search ros-kinetic | grep tf2_geometry_msgs 发现存在这个包12porter@porter-Aspire:~/gym-gazebo/gym_gazebo/envs/installation$ apt-cache search ros-kinetic | grep tf2_geometry_msgsros-kinetic-tf2-geometry-msgs - tf2_geometry_msgs 执行这个功能包的安装12345678910111213141516porter@porter-Aspire:~/gym-gazebo/gym_gazebo/envs/installation$ sudo apt-get install ros-kinetic-tf2-geometry-msgs[sudo] porter 的密码： 正在读取软件包列表... 完成正在分析软件包的依赖关系树 正在读取状态信息... 完成 下列【新】软件包将被安装： ros-kinetic-tf2-geometry-msgs升级了 0 个软件包，新安装了 1 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 0 B/13.2 kB 的归档。解压缩后会消耗 86.0 kB 的额外空间。正在选中未选择的软件包 ros-kinetic-tf2-geometry-msgs。(正在读取数据库 ... 系统当前共安装有 415109 个文件和目录。)正准备解包 .../ros-kinetic-tf2-geometry-msgs_0.5.20-0xenial-20190320-171251-0800_amd64.deb ...正在解包 ros-kinetic-tf2-geometry-msgs (0.5.20-0xenial-20190320-171251-0800) ...正在设置 ros-kinetic-tf2-geometry-msgs (0.5.20-0xenial-20190320-171251-0800) ...porter@porter-Aspire:~/gym-gazebo/gym_gazebo/envs/installation$ 问题3： 问题3：错误提示 CMake Error at /opt/ros/kinetic/share/catkin/cmake/catkin_workspace.cmake:95 (message): 12345WARNING: Metapackage "ecl_tools" must buildtool_depend on catkin.WARNING: Metapackage "ecl_tools" should not have other dependencies besides a buildtool_depend on catkin and run_depends.WARNING: Metapackage "ecl_lite" must buildtool_depend on catkin.WARNING: Metapackage "ecl_lite" should not have other dependencies besides a buildtool_depend on catkin and run_depends.Packages "mav_msgs" not found in the workspace 问题3：解决 出现这个错误的原因是ecl升级，或这和你当前安装的ros版本不对应。造成了cmake版本比配。出错，方法是 打开gazebo.repos,修改如下部分：123456789101112ecl_lite: type: git url: https://github.com/stonier/ecl_lite version: release/0.61-indigo-kinetic ecl_navigation: type: git url: https://github.com/stonier/ecl_navigation version: devel ecl_tools: type: git url: https://github.com/stonier/ecl_tools version: release/0.61-indigo-kinetic (将ecl_core、 ecl_lite 和ecl_tools 的版本号（version）改成： release/0.61-indigo-kinetic） 不过最终解决还是建议你如果也是安装ros kenitic 直接复制我后面附录的gazebo.repos内容替换掉之前的 路径： vim ~/gym-gazebo/gym_gazebo/envs/installation/gazebo.repos gazebo.repos 内容修改gazebo.repos 修改后的文件内容，使适应kinetic环境，进行安装。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113repositories: ar_track_alvar: type: git url: https://github.com/ros-perception/ar_track_alvar version: kinetic-devel mav_comm: type: git url: https://github.com/ethz-asl/mav_comm.git version: master catkin_simple: type: git url: https://github.com/catkin/catkin_simple.git version: master control_toolbox: type: git url: https://github.com/ros-controls/control_toolbox.git version: kinetic-devel ecl_core: type: git url: https://github.com/stonier/ecl_core version: release/0.61-indigo-kinetic ecl_lite: type: git url: https://github.com/stonier/ecl_lite version: release/0.61-indigo-kinetic ecl_navigation: type: git url: https://github.com/stonier/ecl_navigation version: release/0.60-indigo-kinetic ecl_tools: type: git url: https://github.com/stonier/ecl_tools version: release/0.61-indigo-kinetic driver_base: type: git url: https://github.com/ros-drivers/driver_common.git version: indigo-devel gazebo_ros_pkgs: type: git url: https://github.com/ros-simulation/gazebo_ros_pkgs version: kinetic-devel hector_gazebo: type: git url: https://github.com/tu-darmstadt-ros-pkg/hector_gazebo/ version: kinetic-devel image_common: type: git url: https://github.com/ros-perception/image_common.git version: hydro-devel joystick_drivers: type: git url: https://github.com/ros-drivers/joystick_drivers.git version: master kobuki: type: git url: https://github.com/yujinrobot/kobuki version: kinetic kobuki_core: type: git url: https://github.com/yujinrobot/kobuki_core version: kinetic kobuki_desktop: type: git url: https://github.com/yujinrobot/kobuki_desktop version: kinetic kobuki_msgs: type: git url: https://github.com/yujinrobot/kobuki_msgs version: kinetic navigation: type: git url: https://github.com/ros-planning/navigation version: kinetic-devel pcl_ros: type: git url: https://github.com/ros-perception/perception_pcl.git version: kinetic-devel realtime_tools: type: git url: https://github.com/ros-controls/realtime_tools version: kinetic-devel ros_control: type: git url: https://github.com/ros-controls/ros_control version: kinetic-devel roslint: type: git url: https://github.com/ros/roslint version: master turtlebot: type: git url: https://github.com/turtlebot/turtlebot version: kinetic turtlebot_create: type: git url: https://github.com/turtlebot/turtlebot_create version: master turtlebot_simulator: type: git url: https://github.com/turtlebot/turtlebot_simulator version: indigo xacro: type: git url: https://github.com/ros/xacro version: kinetic-devel yocs_msgs: type: git url: https://github.com/yujinrobot/yocs_msgs version: release/0.6-kinetic yujin_ocs: type: git url: https://github.com/yujinrobot/yujin_ocs version: kinetic 安装结束效果123456789vim ~/.bashrc# 最后几行的环境应该是这样的source /home/porter/gym-gazebo/gym_gazebo/envs/installation/catkin_ws/devel/setup.bashexport GAZEBO_MODEL_PATH=/home/porter/gym-gazebo/gym_gazebo/envs/installation/../assets/modelsexport GYM_GAZEBO_WORLD_MAZE=/home/porter/gym-gazebo/gym_gazebo/envs/installation/../assets/worlds/maze.worldexport GYM_GAZEBO_WORLD_CIRCUIT=/home/porter/gym-gazebo/gym_gazebo/envs/installation/../assets/worlds/circuit.worldexport GYM_GAZEBO_WORLD_CIRCUIT2=/home/porter/gym-gazebo/gym_gazebo/envs/installation/../assets/worlds/circuit2.worldexport GYM_GAZEBO_WORLD_CIRCUIT2C=/home/porter/gym-gazebo/gym_gazebo/envs/installation/../assets/worlds/circuit2c.worldexport GYM_GAZEBO_WORLD_ROUND=/home/porter/gym-gazebo/gym_gazebo/envs/installation/../assets/worlds/round.world 打开终端执行的效果如下图 问题4： 问题4：错误提示 Pycharm 里面无法正常运行Gym_gazebo代码. ubuntu下PyCharm导入ros库 porter@porter-Aspire:~$ gedit /usr/share/applications/Pycharm.desktop123456789[Desktop Entry]Type=ApplicationName=PycharmGenericName=Pycharm3Comment=Pycharm3:The Python IDEExec=sh /home/porter/pycharm-2018.3.5/bin/pycharm.shIcon=/home/porter/pycharm-2018.3.5/bin/pycharm.pngTerminal=pycharmCategories=Pycharm; 问题4：错误提示 12345678910[Desktop Entry]Version=1.0Type=ApplicationName=PycharmGenericName=Pycharm3Icon=/home/porter/pycharm-2018.3.5/bin/pycharm.pngExec=bash -i -c "/home/porter/pycharm-2018.3.5/bin/pycharm.sh" %fComment=Pycharm3:The Python IDECategories=Development;IDE;Terminal=false 问题5：在终端中正常运行，在pycharm中运行出错 问题5：错误提示 12entry = _cache.get(encoding, _unknown) AttributeError: ‘NoneType’ object has no attribute ‘get’ 运行pycharm报错，内容如下： 问题5：解决方式： settings -&gt; tools -&gt;Python Scientific -&gt;Show plots in toolwindow(取消勾选) gym-gazebo 测试参见我的另一篇文章gym-gazebo安装后的测试]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>gym-gazebo</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gym-gazebo安装后的测试]]></title>
    <url>%2F%2Fgym-gazeboInstall%2F</url>
    <content type="text"><![CDATA[目录本节会安装以下内容 目录 第一步：bash turtlebot_setup.bash Running an environment Run any of the examples available in examples/. E.g.: 第二步：source setup_turtlebot.bash source 进行expert操作 第三步：eg export ROS_MASTER_URI=http://localhost:12795 第二步和第三步操作方法的截图 第四步：gzclient 五 最终效果 Display reward plot Killing background processes Edit By Porter, 积水成渊,蛟龙生焉。 第一步：bash turtlebot_setup.bashRunning an environmentLoad the environment variables corresponding to the robot you want to launch. E.g. to load the Turtlebot:12cd gym_gazebo/envs/installationbash turtlebot_setup.bash Note: all the setup scripts are available in gym_gazebo/envs/installation Run any of the examples available in examples/. E.g.:12cd examples/turtlebotpython3 circuit2_turtlebot_lidar_qlearn.py 第二步：source setup_turtlebot.bash 我的source bash文件是setup.bash不是setup_turtlebot.bash，所以我的是source setup.bash source12cd /home/porter/gym-gazebo/gym_gazebo/envs/installation/catkin_ws/develsource setup.bash 进行expert操作首先第一步：bash turtlebot_setup.bash过后，终端会有如下的提示 得到有用的终端输出信息12345678910111213porter@porter-Aspire:~/gym-gazebo/examples/turtlebot$ python3 circuit2_turtlebot_lidar_qlearn.pyROS_MASTER_URI=http://localhost:12795GAZEBO_MASTER_URI=http://localhost:12796Gazebo launched!Unable to register with master node [http://localhost:12795]: master may not be running yet. Will keep trying.... logging to /home/porter/.ros/log/ab3f7618-6fea-11e9-a24a-f0761cd1b3e0/roslaunch-porter-Aspire-11818.logChecking log directory for disk usage. This may take awhile.Press Ctrl-C to interruptDone checking log file disk usage. Usage is &lt;1GB.started roslaunch server http://porter-Aspire:33631/ 第三步：eg export ROS_MASTER_URI=http://localhost:1279512export ROS_MASTER_URI=http://localhost:12795 # 和上面的端口号一致export GAZEBO_MASTER_URI=http://localhost:12796 # 和上面的端口号一致 第二步和第三步操作方法的截图 第四步：gzclient执行如下命令打开gazebo1gzclient 五 最终效果 Display reward plotDisplay a graph showing the current reward history by running the following script: 123cd /home/porter/gym-gazebo/cd examples/utilitiespython3 display_plot.py HINT: use –help flag for more options. Killing background processesSometimes, after ending or killing the simulation gzserver and rosmaster stay on the background, make sure you end them before starting new tests. We recommend creating an alias to kill those processes. 1echo "alias killgazebogym='killall -9 rosout roslaunch rosmaster gzserver nodelet robot_state_publisher gzclient'" &gt;&gt; ~/.bashrc 参考来源：https://github.com/erlerobot/gym-gazebo/tree/master#installation]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>gym-gazebo</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gym 运行常见错误及解决办法]]></title>
    <url>%2F%2FgymError%2F</url>
    <content type="text"><![CDATA[摘要 Edit By Porter, 积水成渊,蛟龙生焉。 1. env.close()问题1.1 问题1描述(TypeError: ‘NoneType’ object is not iterable) 当我们在pycharm或者其他IDE运行一段gym例子,程序结束时都会弹出这个错误提示 12345678910111213141516OKException ignored in: &lt;bound method Viewer.__del__ of &lt;gym.envs.classic_control.rendering.Viewer object at 0x7f8758e0a4a8&gt;&gt;Traceback (most recent call last): File "/home/porter/gym/gym/envs/classic_control/rendering.py", line 152, in __del__ File "/home/porter/gym/gym/envs/classic_control/rendering.py", line 71, in close File "/home/porter/anaconda3/lib/python3.5/site-packages/pyglet/window/xlib/__init__.py", line 480, in close File "/home/porter/anaconda3/lib/python3.5/site-packages/pyglet/gl/xlib.py", line 345, in destroy File "/home/porter/anaconda3/lib/python3.5/site-packages/pyglet/gl/base.py", line 334, in destroy File "/home/porter/anaconda3/lib/python3.5/site-packages/pyglet/gl/xlib.py", line 335, in detach File "/home/porter/anaconda3/lib/python3.5/site-packages/pyglet/gl/lib.py", line 97, in errcheck File "&lt;frozen importlib._bootstrap&gt;", line 968, in _find_and_load File "&lt;frozen importlib._bootstrap&gt;", line 953, in _find_and_load_unlocked File "&lt;frozen importlib._bootstrap&gt;", line 887, in _find_specTypeError: 'NoneType' object is not iterableProcess finished with exit code 0 1.2 解决 原因是，我们没在迭代结束后加上这句话 在代码迭代结束后加上这句代码 1env.close() 1.3 测试代码如下：1234567891011121314151617181920import gymfrom time import sleepenv = gym.make('CartPole-v0')i = 0for i_episode in range(20): observation = env.reset() for step in range(100): env.render() print(observation) action = env.action_space.sample() observation, reward, done, info = env.step(action) if done: print("Episode finished after &#123;&#125; timesteps".format(step+1)) break i += 1 print("i=", i, )print("OK")sleep(3)env.close() 2. 在运行 ‘python circuit2_turtlebot_lidar_qlearn.py ’ 报错2.1 错误提示1234while processing /home/harish/gym-gazebo/gym_gazebo/envs/installation/catkin_ws/src/turtlebot_simulator/turtlebot_gazebo/launch/includes/kobuki.launch.xml:Invalid tag: Cannot load command parameter [robot_description]: command [/opt/ros/kinetic/lib/xacro/xacro --inorder '/home/harish/gym-gazebo/gym_gazebo/envs/installation/catkin_ws/src/turtlebot/turtlebot_description/robots/kobuki_hexagons_asus_xtion_pro.urdf.xacro'] returned with code [2].Param xml is The traceback for the exception was written to the log file PyCharm 中的错误提示 12345678910111213141516171819202122GAZEBO_MASTER_URI=http://localhost:10039Traceback (most recent call last): File "/home/porter/gym-gazebo/examples/turtlebot/circuit_turtlebot_lidar_qlearn.py", line 24, in &lt;module&gt; env = gym.make('GazeboCircuitTurtlebotLidar-v0') File "/home/porter/gym/gym/envs/registration.py", line 155, in make return registry.make(id, **kwargs) File "/home/porter/gym/gym/envs/registration.py", line 100, in make env = spec.make(**kwargs) File "/home/porter/gym/gym/envs/registration.py", line 72, in make env = cls(**_kwargs) File "/home/porter/gym-gazebo/gym_gazebo/envs/turtlebot/gazebo_circuit_turtlebot_lidar.py", line 20, in __init__ gazebo_env.GazeboEnv.__init__(self, "GazeboCircuitTurtlebotLidar_v0.launch") File "/home/porter/gym-gazebo/gym_gazebo/envs/gazebo_env.py", line 36, in __init__ ros_path = os.path.dirname(subprocess.check_output(["which", "roscore"])) File "/home/porter/anaconda3/lib/python3.5/subprocess.py", line 316, in check_output **kwargs).stdout File "/home/porter/anaconda3/lib/python3.5/subprocess.py", line 398, in run output=stdout, stderr=stderr)subprocess.CalledProcessError: Command '['which', 'roscore']' returned non-zero exit status 1Process finished with exit code 1 2.2 解决方法使用gedit打开kobuki.launch.xml文件 1gedit /home/zhw/gym-gazebo/gym_gazebo/envs/installation/catkin_ws/src/turtlebot_simulator/turtlebot_gazebo/launch/includes/kobuki.launch.xml 然后，将第六行替换成：1&lt;arg name="urdf_file" default="$(find xacro)/xacro.py '$(find turtlebot_description)/robots/$(arg base)_$(arg stacks)_$(arg 3d_sensor).urdf.xacro'"/&gt; 3.错误提示1234Multiple packages found with the same name "ecl_mobile_robot":- ecl_core/ecl_mobile_robot- ecl_navigation/ecl_mobile_robotsetup_kinetic.bash: 行 80: devel/setup.bash: 没有那个文件或目录 解决方法 打开gazebo.repos,修改如下部分：改写,原来的内容为：12345678910111213141516ecl_core: type: git url: https://github.com/stonier/ecl_core version: devel ecl_lite: type: git url: https://github.com/stonier/ecl_lite version: devel ecl_navigation: type: git url: https://github.com/stonier/ecl_navigation version: devel ecl_tools: type: git url: https://github.com/stonier/ecl_tools version: devel 改写为(将ecl_core、 ecl_lite 和ecl_tools 的版本号（version）改成： release/0.61-indigo-kinetic） 12345678910111213141516ecl_core: type: git url: https://github.com/stonier/ecl_core version: release/0.61-indigo-kineticecl_lite: type: git url: https://github.com/stonier/ecl_lite version: release/0.61-indigo-kineticecl_navigation: type: git url: https://github.com/stonier/ecl_navigation version: release/0.61-indigo-kineticecl_tools: type: git url: https://github.com/stonier/ecl_tools version: release/0.61-indigo-kinetic]]></content>
      <categories>
        <category>gym</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ros and gazebo and gym_gazebo安装]]></title>
    <url>%2F%2Fros%26gazeboInstall%2F</url>
    <content type="text"><![CDATA[摘要本节笔记主要记录ROS室内仿真环景的具体演示过程和 Edit By Porter, 积水成渊,蛟龙生焉。 ros 安装gazebo安装gym_gazebo安装安装配置中的问题python 环境下提示无法导入rospy报错解决12sudo pip install catkin-toolssudo pip install rospkg 12sudo pip3 install catkin-toolssudo pip3 install rospkg 效果123456789101112131415161718192021222324252627282930313233343536porter@porter-Aspire:~$ sudo pip3 install catkin-tools[sudo] porter 的密码： The directory '/home/porter/.cache/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.The directory '/home/porter/.cache/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.Requirement already satisfied: catkin-tools in /usr/local/lib/python3.5/site-packagesRequirement already satisfied: osrf-pycommon&gt;0.1.1 in /usr/local/lib/python3.5/site-packages (from catkin-tools)Requirement already satisfied: PyYAML in /usr/local/lib/python3.5/site-packages (from catkin-tools)Requirement already satisfied: setuptools in /usr/local/lib/python3.5/site-packages (from catkin-tools)Requirement already satisfied: catkin-pkg&gt;0.2.9 in /usr/local/lib/python3.5/site-packages (from catkin-tools)Requirement already satisfied: trollius in /usr/local/lib/python3.5/site-packages (from catkin-tools)Requirement already satisfied: docutils in /usr/local/lib/python3.5/site-packages (from catkin-pkg&gt;0.2.9-&gt;catkin-tools)Requirement already satisfied: pyparsing in /usr/local/lib/python3.5/site-packages (from catkin-pkg&gt;0.2.9-&gt;catkin-tools)Requirement already satisfied: python-dateutil in /usr/local/lib/python3.5/site-packages (from catkin-pkg&gt;0.2.9-&gt;catkin-tools)Requirement already satisfied: six in /usr/local/lib/python3.5/site-packages (from trollius-&gt;catkin-tools)You are using pip version 9.0.1, however version 19.1 is available.You should consider upgrading via the 'pip install --upgrade pip' command.porter@porter-Aspire:~$ sudo pip3 install rospkgThe directory '/home/porter/.cache/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.The directory '/home/porter/.cache/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.Requirement already satisfied: rospkg in /usr/local/lib/python3.5/site-packagesRequirement already satisfied: PyYAML in /usr/local/lib/python3.5/site-packages (from rospkg)Requirement already satisfied: catkin-pkg in /usr/local/lib/python3.5/site-packages (from rospkg)Requirement already satisfied: python-dateutil in /usr/local/lib/python3.5/site-packages (from catkin-pkg-&gt;rospkg)Requirement already satisfied: pyparsing in /usr/local/lib/python3.5/site-packages (from catkin-pkg-&gt;rospkg)Requirement already satisfied: docutils in /usr/local/lib/python3.5/site-packages (from catkin-pkg-&gt;rospkg)Requirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.5/site-packages (from python-dateutil-&gt;catkin-pkg-&gt;rospkg)You are using pip version 9.0.1, however version 19.1 is available.You should consider upgrading via the 'pip install --upgrade pip' command.porter@porter-Aspire:~$ python3Python 3.5.6 (default, Mar 29 2019, 21:29:42) [GCC 5.4.0 20160609] on linuxType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import rospy&gt;&gt;&gt;]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图书馆占座小工具使用手册]]></title>
    <url>%2F%2Fliberarytool%2F</url>
    <content type="text"><![CDATA[摘要 摘要 使用说明 房间情况查询操作帮助说明 查询功能描述 查询-软件操作步骤 注意 选座操作帮助说明 手动选座功能描述 选座-软件操作步骤 注意 自动选座操作帮助说明 自动选座功能描述 自动选座-软件操作步骤 注意 关于软件打包成exe方案 安装pyinstaller 打包成exe文件 Edit By Porter, 积水成渊,蛟龙生焉。 帮网友做的图书馆抢座和查学生信息的GUI操作界面 使用说明 注意自动抢座模式，电脑不能掉网哦，程序内部已经添加了学校网络账号自动登录功能，但是用的作者个人账号，所以为了不影响作者上网，除了调试阶段的程序，其他发布的程序，自动链接网络的功能都是注释掉的，望海涵，如果后期有需要，笔者可以在软件界面加个输入上网账号的输入口，实现用用户自己的上网号自动上网。 房间情况查询操作帮助说明查询功能描述 可以查询当前选择的房间号和当前填写的时间段的座位被占用情况 可以查询当前座位的同学姓名 查询-软件操作步骤 输入 【开始时间】-【结束时间】-【日期设置】 选择 【房间号】 填写 【座位号】 点击 【房间查询】按键 通过以上4步骤，即可返回你要查询年月日下的对应时间段房间预约情况。 注意 输入格式严格按照运行软件的实例格式输入，具体怎么输入，可咨询作者，但是非作者本人分享，你是找不到作者的，如果命令输入错误，拼写问题，会有相应提示错误原因。如果字符格式错误，软件将会气死的。为啥不人性化直接输入时间数值，原因很简单，害怕软件传播，影响其他爱学习的孩子，建议1楼的都不要抢啊，人家考研的辛苦的。 如果输入信息出错将会有相应错误信息提示，按照错误信息操作即可解决 选座操作帮助说明手动选座功能描述 可以选择当前选择的房间号和当前填写的时间段的座位，对对应房间号中的某座位进行预约 支持当天的位置预约和未来24小时的位置进行预约 更多功能自行探索 选座-软件操作步骤 输入 【输入学号】-【输入密码】-【验证码】 点击 【登录】按键 【开始时间】-【结束时间】-【日期设置】 选择 【房间号】 填写 【座位号】 然后点击【选座】 通过以上6步骤，即可成功预约在你指定的时间断中，你选择的房间号下对应的座位号，即成功按照你的需要预约成功。 注意 输入格式严格按照运行软件的实例格式输入，具体怎么输入，可咨询作者，但是非作者本人分享，你是找不到作者的，如果命令输入错误，拼写问题，会有相应提示错误原因。如果字符格式错误，软件将会气死的。为啥不人性化直接输入时间数值，原因很简单，害怕软件传播，影响其他爱学习的孩子，建议1楼的都不要抢啊，人家考研的辛苦的。 如果输入信息出错将会有相应错误信息提示，按照错误信息操作即可解决，成功预约会返回成功的相应信息。如“您已成功预约”等字样 自动选座操作帮助说明自动选座功能描述 可以在当天上午5:30时刻自动对明天8：30-22:00时间段的，当前选定的房间号和座位号进行座位的抢占 注意勾选自动抢座后，程序会到每天的上午5:30时刻进行自动预约24小时后的位置（相对今天，明天的位置） 自动选座-软件操作步骤 输入 【输入学号】-【输入密码】-【验证码】 点击 【登录】按键 选择 【房间号】 填写 【座位号】 然后勾选右下角的【自动选座】 通过以上5步骤，软件讲处于自动选座模式，此时需要保持软件处于运行状态，软件将会在每天的5:30开始抢座。 抢座的时间段固定为当天后一天（今天5:30开抢明天8:30-22:00）的座位。 抢占的座位和房间号可以在5:30前的任何时间填写好，（今天5:30开抢，一般昨天晚上睡觉前，在选择房间号和座位号后就点击自动选位开抢了）然后不要玩了勾选自动选择座位。 注意 输入格式严格按照运行软件的实例格式输入，具体怎么输入，可咨询作者，但是非作者本人分享，你是找不到作者的，如果命令输入错误，拼写问题，会有相应提示错误原因。如果字符格式错误，软件将会气死的。为啥不人性化直接输入时间数值，原因很简单，害怕软件传播，影响其他爱学习的孩子，建议1楼的都不要抢啊，人家考研的辛苦的。 如果输入信息出错将会有相应错误信息提示，按照错误信息操作即可解决，成功预约会返回成功的相应信息。如“您已成功预约”等字样 关于软件打包成exe方案安装pyinstaller www.pyinstaller.org 安装指令 1pip install pyinstaller 打包成exe文件12345-F, –onefile 打包成一个exe文件。-D, –onedir 创建一个目录，包含exe文件，但会依赖很多文件（默认选项）。-c, –console, –nowindowed 使用控制台，无界面(默认)-w, –windowed, –noconsole 使用窗口，无控制台更详细的使用方法可以参考下载包里的doc目录下的Manual.html文件。 生成的exe文件相对较小，而且可以不用安装运行环境 12cd 到name.py脚本的目录中pyinstaller -w -F name.py 这条指令后会生成一个exe，并且占用空间小，占内存和你代码写的有关系，一般占用内存也不大 界面升级]]></content>
      <categories>
        <category>Library Project</category>
      </categories>
      <tags>
        <tag>Library Project</tag>
        <tag>Pythton</tag>
        <tag>qt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.17 ubuntu下安装有道词典]]></title>
    <url>%2F%2Flinuxyoudaodict%2F</url>
    <content type="text"><![CDATA[摘要解决ubuntu16安装有道词典安装后”水土不服“的一些问题 不能取词 不能发音问题 具体步骤内容如下： 摘要 解决ubuntu16安装有道词典安装后”水土不服“的一些问题 下载有道词典的官方最新安装包 cd 到下载保存的目录执行解包,修改，打包等 创建youdao-dict目录，把该deb包解压到youdao-dict目录 解压deb包中的control信息（包的依赖就写在这个文件里面） 编辑control文件，删除Depends里面的gstreamer0.10-plugins-ugly,添加gstreamer1.0-libav 编辑后的control文件的依赖包内目如下 重新打包，安装 Edit By Porter, 积水成渊,蛟龙生焉。 下载有道词典的官方最新安装包youdao-dict_1.1.0-0-ubuntu_amd64.deb cd 到下载保存的目录执行解包,修改，打包等创建youdao-dict目录，把该deb包解压到youdao-dict目录1sudo dpkg -X ./youdao-dict_1.1.0-0-ubuntu_amd64.deb youdao-dict 解压deb包中的control信息（包的依赖就写在这个文件里面）1sudo dpkg -e ./youdao-dict_1.1.0-0-ubuntu_amd64.deb youdao-dict/DEBIAN 编辑control文件，删除Depends里面的gstreamer0.10-plugins-ugly,添加gstreamer1.0-libav1sudo vi ./youdao-dict/DEBIAN/control 注意可以直接先安装好有道词典单词发音的语音包修复如下 123456# 安装单词发音语音包# 搜索 gstreamer1 相关的包sudo apt-cache search gstreamer1 # 安装找到的 gstreamer1.0-libav 包sudo apt-get install gstreamer1.0-libav 编辑后的control文件的依赖包内目如下1Depends: python3, python3-pyqt5, python3-requests, python3-xlib, tesseract-ocr, tesseract-ocr-eng, tesseract-ocr-chi-sim, tesseract-ocr-chi-tra, python3-pil, ttf-wqy-microhei, python3-lxml, python3-xdg, python3-pyqt5.qtmultimedia, python3-pyqt5.qtquick, python3-pyqt5.qtwebkit, gir1.2-appindicator3-0.1, python3-dbus, qtdeclarative5-controls-plugin, libqt5multimedia5-plugins, gstreamer1.0-libav 重新打包，安装sudo dpkg-deb -b youdao-dict youdaobuild.deb 12345sudo dpkg -i youdaobuild.deb出现缺少的依赖使用如下命令安装所需依赖sudo apt install -f依赖安装完成后再次键入如下命令进行安装sudo dpkg -i youdaobuild.deb]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>有道词典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.15 ubuntu下goldendict有道爬虫小程序]]></title>
    <url>%2F%2Fgoldendictsetting%2F</url>
    <content type="text"><![CDATA[摘要有道翻译 for GoldenDict 半完美取词显示插件说道linux里面好用的取词软件，不得不数goldendict很不错的，比好几年都没更新linux客户端的有道来说好用的多，毕竟ubuntu18下，有道qt已经存在不兼容，要么降qt版本，要么自己折腾对官方提供的deb安装包进行解包，然后进行修改以来环境的代码，再打包，太麻烦了，当然目前也有基于官方的有道词典打包好的支持ubuntu18系统，可以去我的github下载直接安装就好了，但是打包后我发现一个问题，OCR屏幕取词，一天下来Python和取词插件会把你电脑内存占得满满的，结果就是，你的电脑很卡，所以还是转goldendict吧。 下面高能 将解决目前goldendict的网页引入有道的查词，界面各种不整洁，不友好的解决办法。 Edit By Porter, 积水成渊,蛟龙生焉。 原理原理是爬虫的，我是基于：完了，这是真的，原作者的代码我参考，忘了转移到我的github了，如果，原作看到了，记得给我留言，我加上你的参考地址啊，尴尬了 首先效果图如下图]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>goldendict</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.16 ubuntu18升级后部分应用不能中文输入的问题]]></title>
    <url>%2F%2FinputU18%2F</url>
    <content type="text"><![CDATA[摘要ubuntu18升级后部分应用不能中文输入的问题作者做死尝试新的系统和新的桌面gnome结果悲剧了 问题一：我的爽系统引导失效了，重启直接进入windows不进入ubuntu的登录界面 问题二：我的输入法抽风了，我卸载安装，又卸载安装好多遍，结果还是不能用。本文我们只写如何修复部分应用可以i中文输入，然而像浏览器，啥的并不能英文输入的解决办法 Edit By Porter, 积水成渊,蛟龙生焉。 解决办法是，首先卸载ibus，然后进入系统输入法设置选择输入法为fcitx ，然后重启，开机后就正常了 12345678sudo apt-get remove ibus*sudo apt-get purge ibus*# 卸载～/.cache中的不能中文输入的软件cahe全删除掉sudo rm -rf ~/.cache/gedit/sudo rm -rf ~/.cache/webkitgtk/sudo rm -rf ~/.cache/gnome-software/............sudo rm -rf ~/.cache/google-chrome/ 去官网下载fictx安装的binary 二进制安装文件deb fcitx 12345678910sudo rm -rf ~/.cache/ibus/sudo apt-get install fcitx-binsudo apt-get install fcitx-stablesudo apt-get remove ibussudo apt-get purge ibussudo apt-get remove indicator-keyboardsudo apt-get install fcitxfcitx -r# 下载搜狗官方安装包直接安装，双击或者cd到目录后执行如下代码sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb 比如我是x64的，我选择amd64对应的deb，下载后直接双击安装就好 fcitx_4.2.9.6-1_all.deb 建议上面的 sudo apt-get install fcitx-bin sudo apt-get install fcitx-stable 也换成直接官方下载deb包然后安装，在哪可以自己去fcitx官网找到. 最后一步重启，要重启才有用。 然后按照之前那样设置搜狗输入法。 提示，如果你本来就安装了搜狗输入法，你也不用卸载，直接忽略我上面安装搜狗的步骤就好了，效果和重装搜狗一样。笔者是捣鼓的时候，误卸载了搜狗的，所以后面重装了。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>不能中文输入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.14 ubuntu16_18安装peek工具录制gif]]></title>
    <url>%2F%2Fpeektool%2F</url>
    <content type="text"><![CDATA[摘要在写一些博客文章中，一般的png，jpg格式的图片往往满足不了复杂的演示过程，这时peek软件就能很好的帮助我们完成gif文件的制作，并且peek还是一个轻量级的gif制作软件，值得推荐，但是我根据官方的ubuntu安装步骤，发现确实能够安装，但是容易出问题，这里我把我的安装方法写出来，供安装后录制保存就死机的朋友参考。 Edit By Porter, 积水成渊,蛟龙生焉。 一、安装 获取deb包： 1wget https://github.com/phw/peek/releases/download/v0.7.2/peek-0.7.2-Linux.deb 安装依赖： 1sudo apt install libsdl1.2debian ffmpeg libavdevice-ffmpeg56 安装peek： 1sudo dpkg -i peek-0.7.2-Linux.deb 二、使用演示 已启用 类型 名称 命令行 图标 [v] html 词典名称随意填 /词典路径/wordtag.py %GDWORD% /图标路径/png.png]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>peek</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.12 vsftpd 文件配置]]></title>
    <url>%2F%2Fvsftpdconf%2F</url>
    <content type="text"><![CDATA[摘要 Edit By Porter, 积水成渊,蛟龙生焉。 名称vsftpd.conf - vsftpd的配置文件描述 vsftpd.conf可用于控制vsftpd行为的各个方面。默认情况下，vsftpd在/etc/vsftpd/vsftpd.conf位置查找此文件。但是，您可以通过为vsftpd指定命令行参数来覆盖它。命令行参数是vsftpd的配置文件的路径名。此行为很有用，因为您可能希望使用高级inetd（如 xinetd）以每个虚拟主机为基础启动vsftpd以及不同的配置文件。格式 vsftpd.conf的格式非常简单。每一行都是注释或指令。注释行以＃开头并被忽略。指令行的格式为：选项=值 重要的是要注意在选项，=和值之间放置任何空格是错误的。 每个设置都有一个默认编译，可以在配置文件中修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521布尔选项下面是布尔选项列表。布尔选项的值可以设置为YES 或NO。allow_anon_ssl仅在ssl_enable处于活动状态时适用。如果设置为YES，则允许匿名用户使用安全SSL连接。默认值：NOanon_mkdir_write_enable如果设置为YES，则允许匿名用户在特定条件下创建新目录。为此，必须激活选项write_enable，并且匿名ftp用户必须具有父目录的写权限。默认值：NOanon_other_write_enable如果设置为YES，则允许匿名用户执行除上载和创建目录之外的写入操作，例如删除和重命名。通常不建议这样做，但包括完整性。默认值：NOanon_upload_enable如果设置为YES，则允许匿名用户在特定条件下上载文件。为此，必须激活选项write_enable，并且匿名ftp用户必须具有所需上载位置的写入权限。虚拟用户上传也需要此设置; 默认情况下，虚拟用户使用匿名（即最大限制）权限处理。默认值：NOanon_world_readable_only启用后，将只允许匿名用户下载世界可读的文件。这是认识到ftp用户可能拥有文件，尤其是在上传的情况下。默认值：是anonymous_enable控制是否允许匿名登录。如果启用，则用户名ftp和anonymous都将被识别为匿名登录。默认值：是ascii_download_enable启用后，ASCII模式数据传输将在下载时受到尊重。默认值：NOascii_upload_enable启用后，上传时将遵循ASCII模式数据传输。默认值：NOasync_abor_enable启用后，将启用称为“异步ABOR”的特殊FTP命令。只有不明智的FTP客户端才会使用此功能。此外，此功能难以处理，因此默认情况下禁用。遗憾的是，除非此功能可用，否则某些FTP客户端将在取消传输时挂起，因此您可能希望启用它。默认值：NO背景启用后，vsftpd以“监听”模式启动，vsftpd将为侦听器进程提供背景。即控制将立即返回到启动vsftpd的shell。默认值：是check_shell注意！此选项仅对vsftpd的非PAM构建有效。如果禁用，vsftpd将不会检查/ etc / shells是否有用于本地登录的用户shell。默认值：是chmod_enable启用后，允许使用SITE CHMOD命令。注意！这仅适用于本地用户。匿名用户永远不会使用SITE CHMOD。默认值：是chown_uploads如果启用，则所有匿名上载的文件的所有权都将更改为设置chown_username中指定的用户。从管理方面，也许是安全方面来看，这很有用。默认值：NOchroot_list_enable如果激活，您可以在登录时提供其主目录中放置在chroot（）jail中的本地用户列表。如果chroot_local_user设置为YES，则含义略有不同。在这种情况下，列表将成为不被放置在chroot（）jail中的用户列表。默认情况下，包含此列表的文件是/ etc / vsftpd / chroot_list，但您可以使用chroot_list_file设置覆盖它。默认值：NOchroot_local_user如果设置为YES，则登录后本地用户（默认情况下）将放置在其主目录中的chroot（）jail中。警告：此选项具有安全隐患，尤其是在用户具有上载权限或shell访问权限的情况下。只有在您知道自己在做什么时才启用。请注意，这些安全隐患不是vsftpd特定的。它们适用于所有提供将本地用户放在chroot（）jail中的FTP守护进程。默认值：NOconnect_from_port_20这可以控制PORT样式数据连接是否在服务器计算机上使用端口20（ftp-data）。出于安全原因，一些客户可能会坚持认为是这种情况。相反，禁用此选项可使vsftpd以较低的权限运行。默认值：NO（但是示例配置文件启用它）debug_ssl如果为true，则将OpenSSL连接诊断转储到vsftpd日志文件。（在v2.0.6中添加）。默认值：NOdelete_failed_uploads如果为true，则删除任何失败的上载文件。（在v2.0.7中添加）。默认值：NOdeny_email_enable如果激活，您可能会提供一个匿名密码电子邮件响应列表，导致登录被拒绝。默认情况下，包含此列表的文件是/ etc / vsftpd / banned_emails，但您可以使用banned_email_file设置覆盖它。默认值：NOdirlist_enable如果设置为NO，则所有目录列表命令都将拒绝权限。默认值：是dirmessage_enable如果启用，FTP服务器的用户首次进入新目录时可以显示消息。默认情况下，会扫描目录以查找文件.message，但可以使用配置设置message_file覆盖该目录。默认值：NO（但是示例配置文件启用它）download_enable如果设置为NO，则所有下载请求都将拒绝权限。默认值：是dual_log_enable如果启用，则会并行生成两个日志文件，默认情况下为/ var / log / xferlog和/var/log/vsftpd.log。前者是一个wu-ftpd样式的传输日志，可以通过标准工具解析。后者是vsftpd自己的样式日志。默认值：NOforce_dot_files如果激活，则以。开头的文件和目录。即使客户端未使用“a”标志，也将显示在目录列表中。此覆盖不包括“。” 和“..”条目。默认值：NOforce_anon_data_ssl仅在激活ssl_enable时适用。如果激活，则强制所有匿名登录使用安全SSL连接，以便在数据连接上发送和接收数据。默认值：NOforce_anon_logins_ssl仅在激活ssl_enable时适用。如果激活，则强制所有匿名登录使用安全SSL连接以发送密码。默认值：NOforce_local_data_ssl仅在激活ssl_enable时适用。如果激活，则强制所有非匿名登录使用安全SSL连接，以便在数据连接上发送和接收数据。默认值：是force_local_logins_ssl仅在激活ssl_enable时适用。如果激活，则强制所有非匿名登录使用安全SSL连接以发送密码。默认值：是guest_enable如果启用，则所有非匿名登录都被归类为“访客”登录。guest 虚拟机登录将重新映射到guest_username设置中指定的用户。默认值：NOhide_ids如果启用，目录列表中的所有用户和组信息将显示为“ftp”。默认值：NOimplicit_ssl如果启用，则SSL握手是所有连接（FTPS协议）的首要任务。要支持显式SSL和/或纯文本，还应运行单独的vsftpd侦听器进程。默认值：NO听如果启用，vsftpd将以独立模式运行。这意味着不能从某种类型的inetd运行vsftpd。相反，vsftpd可执行文件直接运行一次。然后，vsftpd将负责监听和处理传入的连接。默认值：NOlisten_ipv6与listen参数一样，除了vsftpd将侦听IPv6套接字而不是IPv4套接字。此参数和listen参数是互斥的。默认值：NOlocal_enable控制是否允许本地登录。如果启用，则可以使用/ etc / passwd中的普通用户帐户（或PAM配置引用的任何位置）登录。必须启用此功能才能使任何非匿名登录工作，包括虚拟用户。默认值：NOlock_upload_files启用后，所有上载都会继续对上载文件进行写锁定。所有下载都继续对下载文件进行共享读锁定。警告！在启用此功能之前，请注意恶意阅读器可能会使想要添加文件的作者感到饥饿。默认值：是log_ftp_protocol启用后，将记录所有FTP请求和响应，前提是未启用xferlog_std_format选项。对调试很有用。默认值：NOls_recurse_enable启用后，此设置将允许使用“ls -R”。这是一个小的安全风险，因为大型站点顶层的ls -R可能会消耗大量资源。默认值：NOmdtm_write启用后，此设置将允许MDTM设置文件修改时间（根据通常的访问检查）。默认值：是no_anon_password启用后，这会阻止vsftpd请求匿名密码 - 匿名用户将直接登录。默认值：NOno_log_lock启用后，这会阻止vsftpd在写入日志文件时进行文件锁定。通常不应启用此选项。它的存在是为了解决操作系统错误，例如Solaris / Veritas文件系统组合，有时会出现试图锁定日志文件的挂起。默认值：NOone_process_model如果您有Linux 2.4内核，则可以使用不同的安全模型，每个连接只使用一个进程。它是一种不太纯粹的安全模型，但会提高您的性能。除非您知道自己在做什么，并且您的网站支持大量同时连接的用户，否则您真的不想启用它。默认值：NOpasswd_chroot_enable如果启用，则与chroot_local_user一起，然后可以基于每个用户指定chroot（）jail位置。每个用户的jail都是从/ etc / passwd中的主目录字符串派生的。主目录字符串中出现/./表示jail位于路径中的特定位置。默认值：NOpasv_addr_resolve如果要在pasv_address选项中使用主机名（而不是IP地址），请设置为YES 。默认值：NOpasv_enable如果要禁用PASV获取数据连接的方法，请设置为NO。默认值：是pasv_promiscuous如果要禁用PASV安全检查，则设置为YES，以确保数据连接源自与控制连接相同的IP地址。只有在你知道自己在做什么的情况下才能启用 对此的唯一合法用途是采用某种形式的安全隧道方案，或者可能是为了促进FXP支持。默认值：NOport_enable如果要禁止使用PORT方法获取数据连接，请设置为NO。默认值：是port_promiscuous如果要禁用PORT安全检查，则设置为YES，以确保传出数据连接只能连接到客户端。只有在你知道自己在做什么的情况下才能启用默认值：NOrequire_cert如果设置为yes，则需要所有SSL客户端连接来提供客户端证书。应用于此证书的验证程度由validate_cert控制（在v2.0.6中添加）。默认值：NOrequire_ssl_reuse如果设置为yes，则需要所有SSL数据连接以展示SSL会话重用（这证明它们知道与控制通道相同的主密钥）。虽然这是一个安全的默认设置，但它可能会破坏许多FTP客户端，因此您可能希望禁用它。有关后果的讨论，请参阅 http://scarybeastsecurity.blogspot.com/2009/02/vsftpd-210-released.html（在v2.1.0中添加）。默认值：是reverse_lookup_enable如果希望vsftpd在pam身份验证之前将ip地址转换为主机名，则设置为YES。如果您使用包含主机名的pam_access，这将非常有用。如果您希望vsftpd在某些主机名的反向查找可用并且名称服务器暂时不响应的环境中运行，则应将其设置为NO以避免性能问题。默认值：是run_as_launching_user如果您希望vsftpd作为启动vsftpd的用户运行，则设置为YES。在根访问不可用的情况下，这很有用。大规模警告！除非您完全知道自己在做什么，否则不要启用此选项，因为天真地使用此选项会产生大量安全问题。具体来说，当设置此选项时，vsftpd不会/不能使用chroot技术来限制文件访问（即使由root启动）。一个糟糕的替代品可能是使用deny_file 设置如&#123;/*,*..*&#125;，但这种可靠性无法与chroot相比，不应该依赖。如果使用此选项，则适用对其他选项的许多限制。例如，需要权限的选项（例如非匿名登录，上载所有权更改，从端口20连接以及小于1024的侦听端口）预计不起作用。其他选项可能会受到影响。默认值：NOsecure_email_list_enable如果您只想接受匿名登录的指定电子邮件密码列表，请设置为YES。这非常有用，可以在不需要虚拟用户的情况下限制对低安全性内容的访问。启用后，将禁止匿名登录，除非在email_password_file设置指定的文件中列出了提供的密码。文件格式是每行一个密码，没有额外的空格。默认文件名是/ etc / vsftpd / email_passwords。默认值：NOsession_support这可以控制vsftpd是否尝试维护登录会话。如果vsftpd正在维护会话，它将尝试更新utmp和wtmp。如果使用PAM进行身份验证，它也会打开pam_session，并且只有在注销时关闭它。如果您不需要会话日志记录，您可能希望禁用此功能，并希望为vsftpd提供更多机会以更少的进程和/或更少的权限运行。注 - utmp和wtmp支持仅在启用PAM的构建中提供。默认值：NOsetproctitle_enable如果启用，vsftpd将尝试在系统进程列表中显示会话状态信息。换句话说，报告的进程名称将更改以反映vsftpd会话正在执行的操作（空闲，下载等）。出于安全考虑，您可能希望将其关闭。默认值：NOssl_enable如果启用，并且vsftpd是针对OpenSSL编译的，则vsftpd将通过SSL支持安全连接。这适用于控制连接（包括登录）以及数据连接。您还需要一个支持SSL的客户端。注意！！请注意启用此选项。只有在需要时才启用它。vsftpd无法保证OpenSSL库的安全性。通过启用此选项，您声明您信任已安装的OpenSSL库的安全性。默认值：NOssl_request_cert如果启用，vsftpd会要求（但不一定需要;见 require_cert）一个证书上的传入 SSL 连接。通常这不应该造成任何麻烦，但IBM zOS似乎有问题。（v2.0.7中的新功能）。默认值：是ssl_sslv2仅在激活ssl_enable时适用。如果启用，此选项将允许SSL v2协议连接。TLS v1连接是首选。默认值：NOssl_sslv3仅在激活ssl_enable时适用。如果启用，此选项将允许SSL v3协议连接。TLS v1连接是首选。默认值：NOssl_tlsv1仅在激活ssl_enable时适用。如果启用，此选项将允许TLS v1协议连接。TLS v1连接是首选。默认值：是strict_ssl_read_eof如果启用，则需要通过SSL终止SSL数据上载，而不是套接字上的EOF。需要此选项以确保攻击者未使用伪造的TCP FIN过早终止上载。不幸的是，默认情况下它没有启用，因为很少有客户端能够正确使用它。（v2.0.7中的新功能）。默认值：NOstrict_ssl_write_shutdown如果启用，则需要通过SSL终止SSL数据下载，而不是套接字上的EOF。默认情况下这是关闭的，因为我无法找到执行此操作的单个FTP客户端。这是次要的。它影响的是我们判断客户是否确认完全收到该文件的能力。即使没有此选项，客户端也能够检查下载的完整性。（v2.0.7中的新功能）。默认值：NOsyslog_enable如果启用，那么将转到/var/log/vsftpd.log的任何日志输出都将转到系统日志。记录在FTPD工具下完成。默认值：NOtcp_wrappers的如果启用，并且vsftpd是使用tcp_wrappers支持编译的，则传入连接将通过tcp_wrappers访问控制提供。此外，还有一种基于每个IP的配置机制。如果tcp_wrappers设置VSFTPD_LOAD_CONF环境变量，则vsftpd会话将尝试加载此变量中指定的vsftpd配置文件。默认值：NOtext_userdb_names默认情况下，数字ID显示在目录列表的用户和组字段中。您可以通过启用此参数来获取文本名称。出于性能原因，它默认是关闭的。默认值：NOtilde_user_enable如果启用，vsftpd将尝试解析路径名，例如~chris / pics，即代字号后跟用户名。请注意，vsftpd将始终解析路径名〜和〜/ something（在这种情况下，〜解析为初始登录目录）。请注意，只有在_current_ chroot（）jail中找到文件/ etc / passwd时，〜用户路径才会解析 。默认值：NOuse_localtime如果启用，vsftpd将显示当前时区中包含时间的目录列表。默认为显示GMT。MDTM FTP命令返回的时间也受此选项的影响。默认值：NOuse_sendfile用于测试在平台上使用sendfile（）系统调用的相对好处的内部设置。默认值：是userlist_deny如果激活userlist_enable，则检查此选项。如果将此设置设置为NO，则将拒绝用户登录，除非它们明确列在userlist_file指定的文件中。拒绝登录时，将在要求用户输入密码之前发出拒绝。默认值：是userlist_enable如果启用，vsftpd将从userlist_file给出的文件名加载用户名列表。如果用户尝试使用此文件中的名称登录，则在要求输入密码之前，他们将被拒绝。这可能有助于防止传输明文密码。另请参见 userlist_deny。默认值：NOvalidate_cert如果设置为yes，则收到的所有SSL客户端证书都必须验证OK。自签名证书不构成OK验证。（v2.0.6中的新功能）。默认值：NOuserlist_log如果激活userlist_enable，则检查此选项。如果启用，将记录基于用户列表的每个登录拒绝。默认值：NOvirtual_use_local_privs如果启用，虚拟用户将使用与本地用户相同的权限。默认情况下，虚拟用户将使用与匿名用户相同的权限，这往往更具限制性（特别是在写访问方面）。默认值：NOWRITE_ENABLE这可以控制是否允许任何更改文件系统的FTP命令。这些命令是：STOR，DELE，RNFR，RNTO，MKD，RMD，APPE和SITE。默认值：NOxferlog_enable如果启用，将维护一个日志文件，详细说明上载和下载。默认情况下，此文件将放在/var/log/vsftpd.log中，但可以使用配置设置vsftpd_log_file覆盖此位置。默认值：NO（但是示例配置文件启用它）xferlog_std_format如果启用，传输日志文件将以标准xferlog格式写入，如wu-ftpd所使用。这很有用，因为您可以重用现有的传输统计信息生成器 但是，默认格式更具可读性。此样式的日志文件的缺省位置是/ var / log / xferlog，但您可以使用xferlog_file设置进行更改。默认值：NOisolate_network如果启用，请使用CLONE_NEWNET隔离不受信任的进程，以便它们不能执行任意connect（），而是必须向特权进程请求套接字（必须禁用port_promiscuous）。默认值：是隔离如果启用，请使用CLONE_NEWPID和CLONE_NEWIPC将进程隔离到其ipc和pid名称空间。因此，分离的流程不能相互交互。默认值：是数字选项以下是数字选项列表。必须将数字选项设置为非负整数。支持八进制数，以方便umask选项。要指定八进制数，请使用0作为数字的第一个数字。accept_timeout远程客户端与PASV样式数据连接建立连接的超时（以秒为单位）。默认值：60anon_max_rate匿名客户端允许的最大数据传输速率（以字节/秒为单位）。默认值：0（无限制）anon_umask为匿名用户设置用于文件创建的umask的值。注意！如果要指定八进制值，请记住“0”前缀，否则该值将被视为基数为10的整数！默认值：077chown_upload_mode要强制进行chown（）ed匿名上传的文件模式。（在v2.0.6中添加）。默认值：0600connect_timeout远程客户端响应PORT样式数据连接的超时（以秒为单位）。默认值：60data_connection_timeout超时（以秒为单位），大致是我们允许数据传输停止而没有进度的最长时间。如果超时触发，则启动远程客户端。默认值：300delay_failed_login报告登录失败之前暂停的秒数。默认值：1delay_successful_login允许成功登录之前暂停的秒数。默认值：0file_open_mode用于创建上载文件的权限。Umasks应用于此值之上。如果您希望上传的文件可执行，您可能希望更改为0777。默认值：0666ftp_data_portPORT样式连接源自的端口（只要命名不佳的connect_from_port_20已启用）。默认值：20idle_session_timeout超时（以秒为单位），即远程客户端在FTP命令之间可能花费的最长时间。如果超时触发，则启动远程客户端。默认值：300listen_port如果vsftpd处于独立模式，则它将侦听传入FTP连接的端口。默认值：21local_max_rate本地身份验证用户允许的最大数据传输速率（以字节/秒为单位）。默认值：0（无限制）local_umask为本地用户设置用于文件创建的umask的值。注意！如果要指定八进制值，请记住“0”前缀，否则该值将被视为基数为10的整数！默认值：077max_clients如果vsftpd处于独立模式，则这是可以连接的最大客户端数。连接的任何其他客户端都将收到错误消息。值0关闭限制。默认值：2000max_login_fails在此多次登录失败后，会话被终止。默认值：3max_per_ip如果vsftpd处于独立模式，则这是可以从同一源Internet地址连接的最大客户端数。如果客户端超过此限制，则会收到错误消息。值0关闭限制。默认值：50pasv_max_port为PASV样式数据连接分配的最大端口。可用于指定窄端口范围以协助防火墙。默认值：0（使用任何端口）pasv_min_port为PASV样式数据连接分配的最小端口。可用于指定窄端口范围以协助防火墙。默认值：0（使用任何端口）trans_chunk_size您可能不想更改此设置，但请尝试将其设置为8192，以获得更加平滑的带宽限制器。默认值：0（让vsftpd选择合理的设置）字符串选项以下是字符串选项列表。anon_root此选项表示vsftpd在匿名登录后尝试更改的目录。失败被默默地忽略了。默认值:(无）banned_email_file此选项是包含不允许的匿名电子邮件密码列表的文件的名称。如果启用了选项deny_email_enable，则会查询此文件 。默认值：/ etc / vsftpd / banned_emailsbanner_file此选项是包含要在有人连接到服务器时显示的文本的文件的名称。如果设置，它将覆盖ftpd_banner选项提供的标题字符串 。默认值:(无）ca_certs_file此选项是用于加载证书颁发机构证书的文件的名称，用于验证客户端证书。加载的证书也会通告给客户端，以满足TLSv1.0客户端的需求，例如z / OS FTP客户端。遗憾的是，由于vsftpd使用受限制的文件系统空间（chroot），因此未使用默认的SSL CA证书路径。（在v2.0.6中添加）。默认值:(无）chown_username这是获得匿名上传文件所有权的用户的名称。仅当设置了另一个选项chown_uploads时，此选项才有意义。默认值：rootchroot_list_file该选项是包含本地用户列表的文件的名称，该列表将放置在其主目录中的chroot（）jail中。仅当启用了选项chroot_list_enable时，此选项才有意义。如果启用了选项chroot_local_user，则列表文件将成为不放置在chroot（）jail中的用户列表。默认值：/etvsftpd.confc/vsftpd.chroot_listcmds_allowed此选项指定允许的FTP命令的逗号分隔列表（登录后.USER，PASS和QUIT以及其他始终允许在登录前使用）。其他命令被拒绝。这是一种真正锁定FTP服务器的强大方法。示例：cmds_allowed = PASV，RETR，QUIT默认值:(无）cmds_denied此选项指定以逗号分隔的拒绝FTP命令列表（登录后。始终允许登录前使用USER，PASS，QUIT等）。如果此命令和cmds_allowed上都出现命令，则拒绝优先。（在v2.1.0中添加）。默认值:(无）deny_file此选项可用于设置文件名（和目录名称等）的模式，这些模式不应以任何方式访问。受影响的项目不会被隐藏，但任何尝试对它们做任何事情（下载，更改到目录，影响目录内的某些内容等）都将被拒绝。此选项非常简单，不应用于严格的访问控制 - 应优先使用文件系统的权限。但是，此选项在某些虚拟用户设置中可能很有用。特别要注意的是，如果文件名可以通过各种名称访问（可能是由于符号链接或硬链接），那么必须注意拒绝访问所有名称。如果项目的名称包含hide_file给出的字符串，或者它们与hide_file指定的正则表达式匹配，则将拒绝访问项目。请注意，vsftpd' 正则表达式匹配代码是一个简单的实现，它是完整正则表达式功能的子集。因此，您需要仔细而详尽地测试此选项的任何应用程序。并且由于其更高的可靠性，建议您对任何重要的安全策略使用文件系统权限。支持的正则表达式语法是任意数量的* ,? 和unnested &#123;，&#125;运算符。仅在路径的最后一个组件上支持正则表达式匹配，例如a / b /？支持，但/？/ c不支持。示例：deny_file = &#123;*。mp3，*。mov，.private&#125; 并且由于其更高的可靠性，建议您对任何重要的安全策略使用文件系统权限。支持的正则表达式语法是任意数量的* ,? 和unnested &#123;，&#125;运算符。仅在路径的最后一个组件上支持正则表达式匹配，例如a / b /？支持，但/？/ c不支持。示例：deny_file = &#123;*。mp3，*。mov，.private&#125; 并且由于其更高的可靠性，建议您对任何重要的安全策略使用文件系统权限。支持的正则表达式语法是任意数量的* ,? 和unnested &#123;，&#125;运算符。仅在路径的最后一个组件上支持正则表达式匹配，例如a / b /？支持，但/？/ c不支持。示例：deny_file = &#123;*。mp3，*。mov，.private&#125;默认值:(无）dsa_cert_file此选项指定用于SSL加密连接的DSA证书的位置。默认值:(无 - RSA证书就足够了）dsa_private_key_file此选项指定用于SSL加密连接的DSA私钥的位置。如果未设置此选项，则预期私钥与证书位于同一文件中。默认值:(无）email_password_file此选项可用于提供secure_email_list_enable设置使用的备用文件。默认值：/ etc / vsftpd / email_passwordsftp_username这是我们用于处理匿名FTP的用户的名称。该用户的主目录是匿名FTP区域的根目录。默认值：ftpftpd_banner此字符串选项允许您在首次进入连接时覆盖vsftpd显示的问候语横幅。默认值:(无 - 显示默认的vsftpd横幅）guest_username有关guest虚拟机登录的说明，请参阅boolean设置guest_enable。此设置是访客用户映射到的真实用户名。默认值：ftphide_file此选项可用于设置文件名（和目录名称等）的模式，这些模式应该从目录列表中隐藏。尽管被隐藏，但是知道实际使用的名称的客户端可以完全访问文件/目录等。如果项目的名称包含hide_file给出的字符串，或者它们与hide_file指定的正则表达式匹配，则将隐藏项目。请注意，vsftpd的正则表达式匹配代码是一个简单的实现，它是完整正则表达式功能的子集。有关具体支持的正则表达式语法的详细信息，请参阅deny_file。示例：hide_file = &#123;*。mp3，.hidden，hide *，h？&#125;默认值:(无）listen_address如果vsftpd处于独立模式，则此设置可能会覆盖（所有本地接口的）默认侦听地址。提供数字IP地址。默认值:(无）listen_address6与listen_address类似，但指定IPv6侦听器的默认侦听地址（如果设置了listen_ipv6，则使用该地址）。格式是标准IPv6地址格式。默认值:(无）local_root此选项表示vsftpd在本地（即非匿名）登录后尝试更改的目录。失败被默默地忽略了。默认值:(无）message_file此选项是输入新目录时我们查找的文件的名称。内容显示给远程用户。仅当启用了选项dirmessage_enable时，此选项才有意义。默认值：.messagenopriv_user这是vsftpd在完全没有特权的情况下使用的用户名。请注意，这应该是专用用户，而不是任何人。在大多数机器上，用户没有倾向于使用很多重要的东西。默认值：没人pam_service_name此字符串是vsftpd将使用的PAM服务的名称。默认值：ftppasv_address设置使用此选项可覆盖vsftpd将响应PASV命令而通告的IP地址。提供数字IP地址，除非 启用了pasv_addr_resolve，在这种情况下，您可以提供在启动时为您解析的DNS主机名。默认值:(无 - 地址来自传入的连接套接字）rsa_cert_file此选项指定用于SSL加密连接的RSA证书的位置。默认值：/usr/share/ssl/certs/vsftpd.pemrsa_private_key_file此选项指定用于SSL加密连接的RSA私钥的位置。如果未设置此选项，则预期私钥与证书位于同一文件中。默认值:(无）secure_chroot_dir此选项应该是空目录的名称。此外，ftp用户不应该写入该目录。此目录有时用作安全chroot（）jail，vsftpd不需要文件系统访问。默认值：/ usr / share / empty的ssl_ciphers此选项可用于选择vsftpd允许加密SSL连接的SSL密码。有关更多详细信息，请参见密码手册页。请注意，限制密码可能是一种有用的安全预防措施，因为它可以防止恶意远程方强制使用已发现问题的密码。默认值：DES-CBC3-SHAuser_config_dir这个功能强大的选项允许基于每个用户覆盖手册页中指定的任何配置选项。用法很简单，最好用一个例子来说明。如果将user_config_dir设置为/ etc / vsftpd / user_conf然后以用户“chris”身份登录，则vsftpd将在会话期间应用文件/ etc / vsftpd / user_conf / chris中的设置。此文件的格式详见本手册页！请注意，并非所有设置都是基于每个用户有效。例如，许多设置仅在用户会话启动之前。不会影响每个用户的任何行为的设置示例包括listen_address，banner_file，max_per_ip，max_clients，xferlog_file等。默认值:(无）user_sub_token此选项与虚拟用户结合使用非常有用。它用于根据模板为每个虚拟用户自动生成主目录。例如，如果通过guest_username指定的真实用户的主目录是/ home / virtual / $ USER，并且user_sub_token设置为 $ USER，那么当虚拟用户fred登录时，他将结束（通常是chroot（）'ed ）在目录/ home / virtual / fred中。如果local_root包含user_sub_token，则此选项也会生效。默认值:(无）userlist_file此选项是userlist_enable选项处于活动状态时加载的文件的名称。默认值：/ etc / vsftpd / user_listvsftpd_log_file此选项是我们编写vsftpd样式日志文件的文件的名称。仅当设置了选项xferlog_enable并且未设置xferlog_std_format时， 才会写入此日志。或者，如果已设置选项dual_log_enable，则会写入。另一个复杂因素 - 如果您设置了syslog_enable，则不会写入此文件，而是将输出发送到系统日志。默认值：/var/log/vsftpd.logxferlog_file此选项是我们编写wu-ftpd样式传输日志的文件的名称。仅当 设置了xferlog_enable选项以及xferlog_std_format时才会写入传输日志。或者，如果已设置选项dual_log_enable，则会写入。默认值：/ var / log / xferlog 作者scarybeasts@gmail.com 英文参考文件位置]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.11 sublime text3插件介绍]]></title>
    <url>%2F%2FsublimeIntro%2F</url>
    <content type="text"><![CDATA[摘要Package Control 包控制安装最简单的安装方法是通过 Sublime Text 控制台。控制台可以通过 ctrl +` 快捷方式 或 View &gt; Show Console 菜单来开启/关闭。 打开后，将适用于你 Sublime Text 版本的 Python 代码粘贴到控制台中。 /Sublime Text 3 包控制安装代码/ 12345678910import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read();dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) Edit By Porter, 积水成渊,蛟龙生焉。 通过Package Control 包控制安装插件Package Control（包控制）是安装下面列出的所有插件和主题的最佳方式。继续，在包控制中安装插件。通过 Package Control（包控制）安装插件和主题很简单： 使用方法：进入命令面板（ctrl + shift+ p），然后键入 install。然后键入 remove 删除。 Emmet Emmet绝对的节省时间。您可以轻松快速地编写HTML。 BracketHighlighter 该插件提供行数列高亮的各种配对的语法符号。（愚人码头注：就是将配对的括号等显示在行数列上 Colorpicker 使用一个取色器改变颜色使用方法: ctrl + shift + c DocBlockr 一个真正简单的方式来轻松地创建许多语言包括JavaScript，PHP和CoffeeScript的文档块。只要在函数的上面输入/**，按Tab就可以了。DocBlockr会观察函数需要的变量名和类型，并创建文档块。 SidebarEnhancements 扩展文件树右键功能 CSSComb 用来给CSS属性进行排序的格式化注：因为Csscomb的快捷键是shift+ctrl+c，可能与其他快捷键冲突你可以去Preferences–&gt;插件设置–&gt;CssComb–&gt;key-Bindings-Defallut设置 ColorHighlighter 它可以展示你所选择的颜色代码（像“#FFFFFF”, “rgb(255,255,255)”, “white”）的真正颜色。同时它还包含一个颜色选择器让你可以方便地更改颜色。 使用：快捷键Windows: ctrl+shift+w Trailing spaces 功能：检测并一键去除代码中多余的空格使用：安装插件并重启，即可自动提示多余空格。一键删除多余空格：CTRL+SHITF+T（需配置）快捷键配置：在Preferences / Key Bindings – User加上代码（数组内）{ “keys”: [“ctrl+shift+t”], “command”: “delete_trailing_spaces” }, auto-save 功能：自动保存文件使用：默认是不会自动保存，按快捷键Ctrl+Shift+S开启。快捷键配置方法：首选项-快捷键设置，在数组内添加{ “keys”: [“ctrl+shift+s”], “command”: “auto_save” },如需自动启用，首选项-插件-auto-save## settings-usre粘帖一下配置{“auto_save_on_modified”: true,“auto_save_delay_in_seconds”: 10,“auto_save_all_files”: true,“auto_save_current_file”: “”,“auto_save_backup”: false,“auto_save_backup_suffix”: “autosave”} view in browser 功能：通过默认浏览器打开文件使用：快捷键配置方法：首选项-快捷键设置，在数组内添加快捷键：{ “keys”: [“f12”], “command”: “open_in_browser” }, autoprefixer 功能：CSS添加私有前缀简介：CSS还未标准化，所以要给各大浏览器一个前缀以解决兼容问题使用：快捷键配置方法：首选项-快捷键设置，在数组内添加{ “keys”: [“ctrl+shift+enter”], “command”: “autoprefixer” },快捷键：ctrl+shift+enter CSS Extended Completions 功能：关联CSS文件智能提示css文件中的类名，非常好用 JavaScript Completions 功能：支持javascript原生语法提示 jQuery 功能：jQ函数提示简介：快捷输入jQ函数，是偷懒的好方法 AutoFileName 功能：快捷输入文件名简介：自动完成文件名的输入，如图片选取使用：输入”/”即可看到相对于本项目文件夹的其他文件 HTML-CSS-JS Prettify 功能：快捷输入文件名简介: 编辑HTML, CSS, JS时，经常会出现缩进不对，代码行不对其的情况。装了这个插件之后，只要按下 Ctrl+Shift+h (Windows), Command+Shift+h (Mac), 你的文档就会被整理干净。 注: 需要配置node文件路径 HTML-CSS-JS Prettify &gt; plugin Options 问题：Ubuntu中Ctrl+Shift+P. 输入ip,提示Package Control: There are no packages available for installation. 12Package Control: Error downloading channel. URL error [Errno 65] No route to host downloading https://packagecontrol.io/channel_v3.json. 解决方法一：官方解决办法 解决办法二： 解决方法：Package Control.sublime-settings]修改方法：Preferences &gt; Package Settings &gt; Package Control &gt; Settings - User添加1234567"channels":[ "http://static.bolin.site/channel_v3.json", //"https://packagecontrol.io/channel_v3.json", //"https://web.archive.org/web/20160103232808/https://packagecontrol.io/channel_v3.json", //"https://gist.githubusercontent.com/nick1m/660ed046a096dae0b0ab/raw/e6e9e23a0bb48b44537f61025fbc359f8d586eb4/channel_v3.json"],]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>sublime test3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.13 mysql 笔记]]></title>
    <url>%2F%2Fmysqlnotes%2F</url>
    <content type="text"><![CDATA[摘要本文主要记录mysql的相关文档，包括安装，配置和数据库访问相关代码 Edit By Porter, 积水成渊,蛟龙生焉。 一、下载安装mysql1.1 准备工作 MySQL8.0 For Windows zip包 -&gt; : 下载地址 [1] 解压 我的解压在了D:\program\mysql\mysql-8.0.11-winx64 [2] 配置环境变量 [3] 配置初始化的my.ini文件 我们发现解压后的目录并没有my.ini文件，没关系可以自行创建。在安装根目录下添加 my.ini（新建文本文件，将文件类型改为.ini），写入基本配置： 12345678910111213141516171819202122232425[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=D:\Program Files\MySQL# 设置mysql数据库的数据的存放目录datadir=D:\Program Files\MySQL\Data# 允许最大连接数max_connections=200# 允许连接失败的次数。max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证#mysql_native_passworddefault_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 注意：其中的data目录不需要创建，下一步初始化工作中会自动创建 1.2 安装工作在安装时，必须以管理员身份运行cmd，否则在安装时会报错，会导致安装失败的情况 1.2.1 初始化数据库1CD \d D:/ 在MySQL安装目录的 bin 目录下执行命令： 1mysqld --initialize --console 执行完成后，会打印 root 用户的初始默认密码，比如： 12345D:\Program Files\mysql\bin&gt;mysqld --initialize --console2019-02-14T11:47:59.282979Z 0 [System] [MY-013169] [Server] D:\Program Files\mysql\bin\mysqld.exe (mysqld 8.0.15) initializing of server in progress as process 137522019-02-14T11:47:59.284705Z 0 [Warning] [MY-013242] [Server] --character-set-server: 'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.2019-02-14T11:48:40.707445Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: 7CwffH5&lt;(lem2019-02-14T11:49:02.894787Z 0 [System] [MY-013170] [Server] D:\Program Files\mysql\bin\mysqld.exe (mysqld 8.0.15) initializing of server has completed 注意！执行输出结果里面有一段： [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: 7CwffH5&lt;(lem,D 其中root@localhost:后面的“7CwffH5&lt;(lem,D”就是初始密码（不含首位空格）。在没有更改密码前，需要记住这个密码，后续登录需要用到。要是你手贱，关快了，或者没记住，那也没事，删掉初始化的 datadir 目录，再执行一遍初始化命令，又会重新生成的。当然，也可以使用安全工具，强制改密码，用什么方法，自己随意。 1.3 安装服务在MySQL安装目录的 bin 目录下执行命令： 1mysqld --install [服务名] 后面的服务名可以不写，默认的名字为 mysql。当然，如果你的电脑上需要安装多个MySQL服务，就可以用不同的名字区分了，比如 mysql5 和 mysql8。安装完成之后，就可以通过命令net start mysql启动MySQL的服务了。通过命令net stop mysql停止服务。通过命令sc delete MySQL/mysqld -remove卸载 MySQL 服务 1.4 更改密码下面提供两种方法修改密码，一种是GUI界面的一种是终端操作 1.4.1 GUI界面修改密码（推荐） 这里附上软件下载地址: 链接: https://pan.baidu.com/s/19mjZmCgZYaXRezxdukuG0w 提取码: m7de 复制这段内容后打开百度网盘手机App，操作更方便哦 新建的MySQL的连接 还记得刚刚让你复制的root @ localhost：后面的初始密码了吗？现在要用到它了复制粘贴上去！测试一下！ MySQL的是成功安装了也可以登录现在就是改密码的时候了写SQL改密码吗？太麻烦了太低来我有个简单的方法用Navicat的点击刚刚的连接就会提示我们输入新密码 1.4.2 终端方式修改密码终端里管理员身份运行cmd,并CD 到在MySQL安装目录的 bin 目录下执行命令： 1mysql -u root -p 这时候会提示输入密码，记住了上面第3.1步安装时的密码，填入即可登录成功，进入MySQL命令模式。 在MySQL中执行命令： 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;新密码&apos;; 修改密码，注意命令尾的；一定要有，这是mysql的语法 二、账号配置与使用测试2.1 数据库的创建、表单和字段配置 创建数据库：iodata 创建数据库表单：teacher ，user_info 创建数据库表单中的字段：user_id，user_pass，user_modified 等等 设置数据库表单中的主键。 1234567891011121314151617CREATE DATABASE iodata;use iodata;/*show tables;create table teacher ( code varchar(20) primary key, name varchar(20));*/CREATE TABLE user_info( ID int NOT NULL AUTO_INCREMENT,/* 设置自动加的用户ID*/ user_id VARCHAR(200) NOT NULL,/*支持中英文200个字符的用户字符串*/ user_pass VARCHAR(200) NOT NULL, user_create datetime(3) NULL DEFAULT CURRENT_TIMESTAMP(3), user_modified datetime(3) NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3), PRIMARY KEY (ID)/* 设置主键*/); 2.2 配置数据库的用户访问账号密码，权限123456use iodata;CREATE USER &apos;porter&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;shuruniziji_mima&apos;;/* 创建用户 */INSERT INTO iodata.user_info ( user_id, user_pass) VALUES ( &apos;porter&apos;, &apos;123&apos;); grant all privileges on *.* to &apos;porter&apos;@&apos;%&apos;; /* 放行用户的所有权限并允许远程网络连接 */ Python 代码来链接数据库 如下代码功能是链接数据库并从数据库中读取数据并打印出来 123456789101112131415161718192021222324# -*- coding:utf-8 -*-import pymysqlimport sysdef get_db_data(): connect = pymysql.Connect( host="210.28.33.2", port=3306, user="porter", passwd="smrit", db="iodata", charset='utf8' ) print("写入中，请等待……") cursor = connect.cursor() sql = "select * from user_info" cursor.execute(sql) number = cursor.fetchall() print(number) cursor.close() connect.close()if __name__ == "__main__": get_db_data() 三、简单的操作例程3.1 存储图片的数据库读写操作使用上面推荐的GUI数据库操作工具：Navicat Premium, 软件，在软件中执行 12use iodata;CREATE TABLE Images(Id INT PRIMARY KEY AUTO_INCREMENT, Data MEDIUMBLOB); 读取数据库中图片的Python 代码 1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-import pymysqlimport matplotlib.pyplot as pltimport matplotlib.image as mpimg # mpimg 用于读取图片import sysdef get_loan_number(file): connect = pymysql.Connect( host="210.28.33.2", port=3306, user="porter", passwd="smriti", db="iodata", charset='utf8' ) print("写入中，请等待……") cursor = connect.cursor() sql = "select Data from images LIMIT 1" cursor.execute(sql) fout = open('2.jpg','wb') image_file = cursor.fetchone()[0] fout.write(image_file) fout.close() cursor.close() connect.close() print("写入完成,共写入%d条数据……" % 1)if __name__ == "__main__": # file = r"C:\Users\test\Desktop\loanNUmber.txt" file = "task1.txt" get_loan_number(file) 3.2 读取数据数据并保存在txt文件中123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding:utf-8 -*-import pymysqldef get_loan_number(file): connect = pymysql.Connect( host="106.14.221.55", port=3306, user="nadersidc", passwd="366583", db="defect_detecting", charset='utf8' ) print("写入中，请等待……") cursor = connect.cursor() # sql = "select id from application where status='SUBMITTING' and contract like 'Performance-%' and " \ # "loan_org_party='166490194444444444'" # sql = "select Element.Id,Element.FileName,DefectPosition.TopX,DefectPosition.TopY,\ # DefectPosition.Width,DefectPosition.Height from Element,DefectPosition where Element.DefectId=6 \ # and Element.ImageTypeId=2 and DefectPosition.ElementId=Element.Id" # sql = "select * from Element LIMIT 1,5" # sql = "select * from * LIMIT 1,5" # 查询数据库表中所有的表名字 # sql = "select table_name from information_schema.tables where table_schema='defect_detecting'" sql = "select * from TrainProject LIMIT 1,5" cursor.execute(sql) number = cursor.fetchall() fp = open(file, "w") loan_count = 0 for loanNumber in number: loan_count += 1 fp.write(str(loanNumber)+'\n') fp.close() cursor.close() connect.close() print("写入完成,共写入%d条数据……" % loan_count)if __name__ == "__main__": # file = r"C:\Users\test\Desktop\loanNUmber.txt" file = "task2.txt" get_loan_number(file) 3.2 读取数据数据并直接显示 涉及一个问题，就是数据库中的图片是二进制流的，如何直接从数据库中获取数据并显示]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 帮助文档检索方法]]></title>
    <url>%2F%2FpythonHelp%2F</url>
    <content type="text"><![CDATA[摘要本节主要是学习Python 相关如何查找帮助文档，提升编程效率。 Edit By Porter, 不积跬步无以至千里。 Python中的Module很丰富，一段时间不用，我们就会忘记各个模块的功能作用，以及如何调用模块中的方法。所以会使用帮助文档，以及高效的使用帮助文档，将变得十分重要。 一、查看python中模块的所有方法命令行下使用pydoc命令1在命令行下运行$ pydoc modules即可查看 在python交互解释器中使用help()查看1在交互式解释器中输入&gt;&gt;&gt; help("modules")即可，效果跟在命令行下输入$ pydoc modules是一样的 又如： 123456789&gt;&gt;&gt; help(math.sin)Help on built-in function sin in module math:sin(...) sin(x) Return the sine of x (measured in radians).&gt;&gt;&gt; 查看函数信息的另一种方法print(func_name.doc)如查看内建函数print用法 123456&gt;&gt;&gt; print(print.__doc__)print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)Prints the values to a stream, or to sys.stdout by default....&gt;&gt;&gt; doc前后是两个短下划线，在python中会合并为长下划线python中的help()类似unix中的man指令，熟悉后会对我们的编程带来很大帮助 查看模块下所有函数dir(module_name)如我们需要列举出math模块下所有的函数名称 123&gt;&gt;&gt; dir(math)['__doc__', '__loader__', '__name__',...]&gt;&gt;&gt; 又如： 12345678910import requests,os,randomprint(dir(random))# [&apos;BPF&apos;, &apos;LOG4&apos;, &apos;NV_MAGICCONST&apos;, &apos;RECIP_BPF&apos;, &apos;Random&apos;, &apos;SG_MAGICCONST&apos;, &apos;SystemRandom&apos;, # &apos;TWOPI&apos;, &apos;_BuiltinMethodType&apos;, &apos;_MethodType&apos;, &apos;_Sequence&apos;, &apos;_Set&apos;, &apos;__all__&apos;, &apos;__builtins__&apos;, # &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;_acos&apos;, # &apos;_ceil&apos;, &apos;_cos&apos;, &apos;_e&apos;, &apos;_exp&apos;, &apos;_inst&apos;, &apos;_log&apos;, &apos;_pi&apos;, &apos;_random&apos;, &apos;_sha512&apos;, &apos;_sin&apos;, &apos;_sqrt&apos;, &apos;_test&apos;,# &apos;_test_generator&apos;, &apos;_urandom&apos;, &apos;_warn&apos;, &apos;betavariate&apos;, &apos;choice&apos;, &apos;expovariate&apos;, &apos;gammavariate&apos;, &apos;gauss&apos;, # &apos;getrandbits&apos;, &apos;getstate&apos;, &apos;lognormvariate&apos;, &apos;normalvariate&apos;, &apos;paretovariate&apos;, &apos;randint&apos;, &apos;random&apos;, &apos;randrange&apos;, # &apos;sample&apos;, &apos;seed&apos;, &apos;setstate&apos;, &apos;shuffle&apos;, &apos;triangular&apos;, &apos;uniform&apos;, &apos;vonmisesvariate&apos;, &apos;weibullvariate&apos;] 在python交互是解释器下导入sys模块查看python的sys模块也是可以用来查看模块信息的 12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules.keys() 命令行下使用pip查看 如果你使用的是pip来作为你的python包管理器的话，可以在命令行下直接运行$ pip freeze或者$ pip list来查看安装包的信息，当然其它的包管理器也有类似的功能，同时，你也可以在python交互式解释器中导入pip模块来查看包信息 12345import pipinstalled_packages = pip.get_installed_distributions()installed_packages_list = sorted(["%s==%s" % (i.key, i.version) for i in installed_packages])print(installed_packages_list) 使用yolk来查看 如果你安装过yolk的话可以使用yolk命令来查看包信息，你可以使用$ pip install yolk来安装它yolk使用简单，只需在命令行下操作即可 1234$ yolk -l #列出所有安装模块$ yolk -a #列出激活的模块$ yolk -n #列出非激活模块$ yolk -U [packagename] # 通过查询pypi来查看（该）模块是否有新版本]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Module篇使用__future__]]></title>
    <url>%2F%2Fpython_future%2F</url>
    <content type="text"><![CDATA[摘要本节主要是学习Python 相关编程的总结及其他信息。 Edit By Porter, 不积跬步无以至千里。 官方定义参考地址— Future statement definitions。 future is a real module, and serves three purposes: To avoid confusing existing tools that analyze import statements and expect to find the modules they’re importing. To ensure that future statements run under releases prior to 2.1 at least yield runtime exceptions (the import of future will fail, because there was no module of that name prior to 2.1). To document when incompatible changes were introduced, and when they will be — or were — made mandatory. This is a form of executable documentation, and can be inspected programmatically via importing future and examining its contents. Python 的每个版本或多或少会添加一些新的功能，或者修改某些现存的功能，所以在不同版本的环境中我们写的某一些代码可能会存在不兼容的现象，比如Python2.5与Python3.6等等之间的版本就存在不兼容的问题，为了解决这种问题，Python加入了future模块。方便将工程代码过渡到新的版本上。比如2.x里的字符串用’xxx’表示str，Unicode字符串用u’xxx’表示unicode，而在3.x中，所有字符串都被视为unicode，因此，写u’xxx’和’xxx’是完全一致的，而在2.x中以’xxx’表示的str就必须写成b’xxx’，以此表示“二进制字符串”。 要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。 Python提供了future模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。举例说明如下： 为了适应Python 3.x的新的字符串的表示方法，在2.7版本的代码中，可以通过unicode_literals来使用Python 3.x的新的语法： 此处借鉴廖雪峰的博客: 12345678# still running on Python 2.7from __future__ import unicode_literalsprint '\'xxx\' is unicode?', isinstance('xxx', unicode)print 'u\'xxx\' is unicode?', isinstance(u'xxx', unicode)print '\'xxx\' is str?', isinstance('xxx', str)print 'b\'xxx\' is str?', isinstance(b'xxx', str) 注意到上面的代码仍然在Python 2.7下运行，但结果显示去掉前缀u的’a string’仍是一个unicode，而加上前缀b的b’a string’才变成了str： 12345$ python task.py'xxx' is unicode? Trueu'xxx' is unicode? True'xxx' is str? Falseb'xxx' is str? True 类似的情况还有除法运算。在Python 2.x中，对于除法有两种情况，如果是整数相除，结果仍是整数，余数会被扔掉，这种除法叫“地板除”： 12&gt;&gt;&gt; 10 / 33 要做精确除法，必须把其中一个数变成浮点数： 12&gt;&gt;&gt; 10.0 / 33.3333333333333335 而在Python 3.x中，所有的除法都是精确除法，地板除用//表示： 12345678$ python3Python 3.3.2 (default, Jan 22 2014, 09:54:40) [GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.2.79)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 10 // 33 如果你想在Python 2.7的代码中直接使用Python 3.x的除法，可以通过future模块的division实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152使用__future__阅读: 142513Python的每个新版本都会增加一些新的功能，或者对原来的功能作一些改动。有些改动是不兼容旧版本的，也就是在当前版本运行正常的代码，到下一个版本运行就可能不正常了。从Python 2.7到Python 3.x就有不兼容的一些改动，比如2.x里的字符串用'xxx'表示str，Unicode字符串用u'xxx'表示unicode，而在3.x中，所有字符串都被视为unicode，因此，写u'xxx'和'xxx'是完全一致的，而在2.x中以'xxx'表示的str就必须写成b'xxx'，以此表示“二进制字符串”。要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。Python提供了__future__模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。举例说明如下：为了适应Python 3.x的新的字符串的表示方法，在2.7版本的代码中，可以通过unicode_literals来使用Python 3.x的新的语法：# still running on Python 2.7from __future__ import unicode_literalsprint '\'xxx\' is unicode?', isinstance('xxx', unicode)print 'u\'xxx\' is unicode?', isinstance(u'xxx', unicode)print '\'xxx\' is str?', isinstance('xxx', str)print 'b\'xxx\' is str?', isinstance(b'xxx', str)注意到上面的代码仍然在Python 2.7下运行，但结果显示去掉前缀u的'a string'仍是一个unicode，而加上前缀b的b'a string'才变成了str：$ python task.py'xxx' is unicode? Trueu'xxx' is unicode? True'xxx' is str? Falseb'xxx' is str? True类似的情况还有除法运算。在Python 2.x中，对于除法有两种情况，如果是整数相除，结果仍是整数，余数会被扔掉，这种除法叫“地板除”：&gt;&gt;&gt; 10 / 33要做精确除法，必须把其中一个数变成浮点数：&gt;&gt;&gt; 10.0 / 33.3333333333333335而在Python 3.x中，所有的除法都是精确除法，地板除用//表示：$ python3Python 3.3.2 (default, Jan 22 2014, 09:54:40) [GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.2.79)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 10 // 33如果你想在Python 2.7的代码中直接使用Python 3.x的除法，可以通过__future__模块的division实现：from __future__ import divisionprint '10 / 3 =', 10 / 3print '10.0 / 3 =', 10.0 / 3print '10 // 3 =', 10 // 3 结果如下： 12310 / 3 = 3.3333333333310.0 / 3 = 3.3333333333310 // 3 = 3 由于Python是由社区推动的开源并且免费的开发语言，不受商业公司控制，因此，Python的改进往往比较激进，不兼容的情况时有发生。Python为了确保你能顺利过渡到新版本，特别提供了future模块，让你在旧的版本中试验新版本的一些特性。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Module</tag>
        <tag>__future__</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5 梯度下降和最小二乘法]]></title>
    <url>%2F%2Ftiduxiajiang%2F</url>
    <content type="text"><![CDATA[摘要本节笔记主要记录梯度下降算法和最小二乘法的相同点和不同点，为了简单的理解和推导，我们暂只讨论一元线性回归下的梯度下降算法和最小二乘。从实现++代码上的最大不同就是梯度下降采用了迭代算法—预先给一个参数设置初始值，然后通过迭代和学习率实现线性方程直线的无限靠近理想函数。最小二乘采用了高中数学求凸函数（下凹）的最小值—即求导数为零的参数方程。 Edit By Porter, 积水成渊,蛟龙生焉。 梯度下降和最小二乘发的相同点和不同点如下： 第一部分、最小二乘法1.1 狭义的最小二乘法：指的是在线性回归下采用最小二乘准则（或者说叫做最小平方），进行线性拟合参数求解的、矩阵形式的公式方法，是线性假设下的一种有闭式解的参数求解方法，最终结果为全局最优； 1.2 广义的最小二乘法：是最小二乘准则，本质上是一种evaluation rule或者说objective funcion。是一种对于偏差程度的评估准则。 梯度下降法，是假设条件更为广泛（无约束）的，一种通过迭代更新来逐步进行的参数优化方法，最终结果为局部最优； 1.3 最小二乘与极大似然的区别 二乘法：即观测值与实际数据误差平方和最小，其没有假设，几何意义上就是距离最小 最大似然估计：估计参数可能值，使样本发生概率最大 1.4 对于回归问题，两者对于最优参数的不同解法假设一元回归方程为 $$f(x_i)=\omega x_i +b$$ 实际中我们会采样得到关于[x,y]的很多样本，此时我们会通过损失函数loss，来求最优$\omega , b$的最优解。 $$loss = (\omega x + b -y)^2$$ 假设$E_(\omega, b)=loss_(\omega, b)$,于是： 为求得最优的$\omega ， b$,即求解$E_(\omega, b)=\sum_{i=1}^{m} (y_i - \omega x_i -b)^2$的最小取值下的$\omega ， b$ 最优解。 注意此时的$E_(\omega, b)$是一个凸函数，注意也就是对应国内教材下凹函数曲线。 1.5 最小二乘法的求解最优的$\omega ， b$的方法直接通过对$E_(\omega, b)$ 对$\omega ， b$ 分别求偏导，并将偏导设为0，求取凸函数取得最小值下的对应$\omega ， b$ 参数。 1.6 最小二乘法的局限性和适用场景 从上面可以看出，最小二乘法适用简洁高效，比梯度下降这样的迭代法似乎方便很多。但是这里我们就聊聊最小二乘法的局限性。 首先，最小二乘法需要计算的逆矩阵，有可能它的逆矩阵不存在，这样就没有办法直接用最小二乘法了，此时梯度下降法仍然可以使用。当然，我们可以通过对样本数据进行整理，去掉冗余特征。让的行列式不为0，然后继续使用最小二乘法。 第二，当样本特征n非常的大的时候，计算的逆矩阵是一个非常耗时的工作（nxn的矩阵求逆），甚至不可行。此时以梯度下降为代表的迭代法仍然可以使用。那这个n到底多大就不适合最小二乘法呢？如果你没有很多的分布式大数据计算资源，建议超过10000个特征就用迭代法吧。或者通过主成分分析降低特征的维度后再用最小二乘法。 第三，如果拟合函数不是线性的，这时无法使用最小二乘法，需要通过一些技巧转化为线性才能使用，此时梯度下降仍然可以用。 第四，讲一些特殊情况。当样本量m很少，小于特征数n的时候，这时拟合方程是欠定的，常用的优化方法都无法去拟合数据。当样本量m等于特征说n的时候，用方程组求解就可以了。当m大于n时，拟合方程是超定的，也就是我们常用与最小二乘法的场景了。 原文地址：http://www.cnblogs.com/pinard/p/5976811.html 第二部分、梯度下降算法2.1 梯度下降算法的求解最优的$\omega ， b$的方法同样，梯度下降算法也是要求最小损失函数 $$loss = (\omega x + b -y)^2$$ 但是方法不一样了，梯度下降算法，在上面的基础上设定一个学习率的参数，假设为:$lr$ 对于待求解的参数$\omega ， b$ 则转化为 –&gt; 求最终待求的$\omega ‘ ， b’$ 关于前一时刻的$\omega ， b$ 的函数，如下 $$\frac{\bigtriangledown loss}{\bigtriangledown \omega} = \frac{2(\omega x+b-y)*x}{N}$$ $$\frac{\bigtriangledown loss}{\bigtriangledown b} = \frac{2(\omega x+b-y)}{N}$$ 2.2 梯度下降算法的算法核心公式对于$\omega$和$b$ , 算法的核心在于如何更新这两个参数，这两个参数的更新不是能用公式可以简单的推到的，但是可以用下面的举例进行理解 $\omega$和$b$ 参数更新的理解，首先我们需要的是最小化这个loss代价函数，这个代价函数是一个下凸函数，所以我们按照凸函数的特点来理解，类似于一个山，人闭着眼往山下走小碎步(这个小碎步就是学习率乘梯度，如下公式) $$lr * \frac{\bigtriangledown loss}{\bigtriangledown \omega}$$ 我们要求解的是，找这个loss的局部最优解，由于我们是针对线性一元的，所以loss是只有一个极小值点，也就是局部解就是最优解，所以接下来理解。 人要走到山下，那么问题来了，我怎么怎么确保我们一直是朝向山谷走的呢，(比如人走在山谷的左边,应该接着忘右边走，才能到达山谷；又如，我们走超了，小碎步跨大了，跨到山谷的左边去了，我们应该要要朝山谷的左边走才能到山谷)，这里就需要个方向，这个在局部最优点的左边还是右边的方向由$\frac{\bigtriangledown loss}{\bigtriangledown \omega}$ 确定。 第三个问题是，人走小碎步时，要的方向是朝着局部最优点(山谷)走的,即loss数值(代价函数)减少的方向，所以我们要在小碎步前乘以负数，来确保，取(点，人)在(山)左边时(左边时梯度=斜率，就是loss的导数为负数,负数乘以负数，就为正数)我们要确保我们需要预测的$\omega , b$所确定的 $$f(x; \omega , b)= \omega * x+b$$ 接近原数据y,所以对于价值函数，人在左边时 $\omega$, 我们要确保人是往loss梯度下降(loss减少)的方向移动, 此时$\omega$ 就可以看作走碎步的人，方向都已确定 $$-lr * \frac{\bigtriangledown loss}{\bigtriangledown \omega}$$ ,现在就是在前一步$\omega_{0}$ 的基础上，走下一步得到 $\omega_{1}$即有 $$\omega_{1} = \omega_{0}+(-lr*\frac{\bigtriangledown loss}{\bigtriangledown \omega})$$ 进一步简化为 $$\omega ‘=\omega - lr * \frac{\bigtriangledown loss}{\bigtriangledown \omega}$$ 同理： 人，走碎步(小碎步的步长是$- lr * \frac{\bigtriangledown loss}{\bigtriangledown b}$)，上一步是b, 方向是$\frac{\bigtriangledown loss}{\bigtriangledown \omega}$ ,走到的下一步就是$b^{‘}$ ,即得到 $$b ‘=b - lr * \frac{\bigtriangledown loss}{\bigtriangledown b}$$ 根据上面的式子，假设学习率lr的初始值为0，然后通过for循环进行迭代，此时求解的关于$\omega ， b$ 的曲线会随着迭代的次数增加，一步步无限的靠近最优的解，理论上会求解到最优的$\omega ， b$ 。 这里我相信题主对梯度下降法的整体理念是认可的，只是不清楚这个更新公式的实质含义。首先这个梯度更新公式确实不是推导而是创造出来的，所以只能从概念上去理解。设想下有个函数，你的目标是：找到一个参数 使得它的值 最小。但它很复杂，你无法找到这个参数的解析解，所以你希望通过梯度下降法去猜这个参数。 问题是怎么猜？对于多数有连续性的函数来说，显然不可能把每个 都试一遍。所以只能先随机取一个 ，然后看看怎么调整它最有可能使得 变小。把这个过程重复n遍，自然最后得到的 的估值会越来越小。 作者：老董链接：https://www.zhihu.com/question/57747902/answer/240695458 来源：知乎 针对上面的一元回归梯度下降算法的代码实现，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import numpy as np# y = wx + bdef compute_error_for_line_given_points(b, w, points): totalError = 0 for i in range(0, len(points)): x = points[i, 0] y = points[i, 1] totalError += (y - (w * x + b)) ** 2 return totalError / float(len(points))def step_gradient(b_current, w_current, points, learningRate): b_gradient = 0 w_gradient = 0 N = float(len(points)) for i in range(0, len(points)): x = points[i, 0] y = points[i, 1] b_gradient += -(2/N) * (y - ((w_current * x) + b_current)) w_gradient += -(2/N) * x * (y - ((w_current * x) + b_current)) new_b = b_current - (learningRate * b_gradient) new_m = w_current - (learningRate * w_gradient) return [new_b, new_m]def gradient_descent_runner(points, starting_b, starting_m, learning_rate, num_iterations): b = starting_b m = starting_m for i in range(num_iterations): b, m = step_gradient(b, m, np.array(points), learning_rate) return [b, m]def run(): points = np.genfromtxt("data.csv", delimiter=",") learning_rate = 0.0001 initial_b = 0 # initial y-intercept guess initial_m = 0 # initial slope guess num_iterations = 1000 print("Starting gradient descent at b = &#123;0&#125;, m = &#123;1&#125;, error = &#123;2&#125;" .format(initial_b, initial_m, compute_error_for_line_given_points(initial_b, initial_m, points)) ) print("Running...") [b, m] = gradient_descent_runner(points, initial_b, initial_m, learning_rate, num_iterations) print("After &#123;0&#125; iterations b = &#123;1&#125;, m = &#123;2&#125;, error = &#123;3&#125;". format(num_iterations, b, m, compute_error_for_line_given_points(b, m, points)) )if __name__ == '__main__': run() 对应的数据集如下(data.csv)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910032.502345269453031,31.7070058465699253.426804033275019,68.7775959816389161.530358025636438,62.56238229794580347.475639634786098,71.54663223356777759.813207869512318,87.23092513368739355.142188413943821,78.21151827079923252.211796692214001,79.6419730498087439.299566694317065,59.17148932186950848.10504169176825,75.33124229706305652.550014442733818,71.30087988685035345.419730144973755,55.16567714595912354.351634881228918,82.47884675749791944.164049496773352,62.00892324572582558.16847071685779,75.39287042599495756.727208057096611,81.4361921588786448.955888566093719,60.72360244067396544.687196231480904,82.89250373145371560.297326851333466,97.37989686216607845.618643772955828,48.84715331735507238.816817537445637,56.87721318626850666.189816606752601,83.87856466460276365.41605174513407,118.5912173025224947.48120860786787,57.25181946226896941.57564261748702,51.39174407983230751.84518690563943,75.38065166531235759.370822011089523,74.76556403215137457.31000343834809,95.45505292257473763.615561251453308,95.22936601755530746.737619407976972,79.05240616956558650.556760148547767,83.43207142132371252.223996085553047,63.35879031749787835.567830047746632,41.41288530370056342.436476944055642,76.61734128007404458.16454011019286,96.76956642610819957.504447615341789,74.08413011660252345.440530725319981,66.58814441422859461.89622268029126,77.76848241779302433.093831736163963,50.71958891231208436.436009511386871,62.12457081807178137.675654860850742,60.81024664990221144.555608383275356,52.68298336638778143.318282631865721,58.56982471769286750.073145632289034,82.90598148507051243.870612645218372,61.42470980433912362.997480747553091,115.2441528007952932.669043763467187,45.57058882337608540.166899008703702,54.08405479622361253.575077531673656,87.99445275811041333.864214971778239,52.72549437590042564.707138666121296,93.57611869265824138.119824026822805,80.16627544737096444.502538064645101,65.10171157056032640.599538384552318,65.56230126040037541.720676356341293,65.28088692082282351.088634678336796,73.43464154632430155.078095904923202,71.1397278586189441.377726534895203,79.10282968354985762.494697427269791,86.52053844034715349.203887540826003,84.74269780782621841.102685187349664,59.35885024862493341.182016105169822,61.68403752483362750.186389494880601,69.84760415824918352.378446219236217,86.09829120577410350.135485486286122,59.10883926769964333.644706006191782,69.8996816436276339.557901222906828,44.86249071116439856.130388816875467,85.49806777884022357.362052133238237,95.53668684646721960.269214393997906,70.25193441977158735.678093889410732,52.72173496477498831.588116998132829,50.39267013507989653.66093226167304,63.64239877565775346.682228649471917,72.24725106866236543.107820219102464,57.81251297618140270.34607561504933,104.2571015854382244.492855880854073,86.64202031882200657.50453330326841,91.48677800011013536.930076609191808,55.23166088621283655.805733357942742,79.55043667850760938.954769073377065,44.84712424246760156.901214702247074,80.20752313968276356.868900661384046,83.1427497920434634.33312470421609,55.72348926054391459.04974121466681,77.63418251167786457.788223993230673,99.05141484174826954.282328705967409,79.12064627468002751.088719898979143,69.58889785111847550.282836348230731,69.51050331149438944.211741752090113,73.68756431831728538.005488008060688,61.36690453724013132.940479942618296,67.17065576899511853.691639571070056,85.66820314500154268.76573426962166,114.8538712339139446.230966498310252,90.12357206996742368.319360818255362,97.91982103524284850.030174340312143,81.53699078301502849.239765342753763,72.11183246961566350.039575939875988,85.23200734232567348.149858891028863,66.22495788805463225.128484647772304,53.454394214850524 总结以上就是关于简单的一元回归的关于梯度下降和最小二乘的区别，对于代码中，的迭代的实现下一小节中会有详细的介绍，会通过代码来直观例说迭代算法和递归算法的差异和原理。 无聊时刻看部综艺：]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>梯度下降和最小二乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4 Decision tree]]></title>
    <url>%2F%2Fdecisiontree%2F</url>
    <content type="text"><![CDATA[摘要决策树是在已知各种情况发生的概率的基础上，通过决策树来求取净现值的期望值大于或等于零的概率，从而评价项目风险，判断其可能性的决策分析方法，是直观的运用概率分析的一种图解方法。由于决策树画成的图像就像一棵树的树干，故称决策树。在机器学习中决策树是一种预测模型，他表示对象属性和对象之间的一种映射关系。决策树是一种判断其可行性的决策分析的方法，也是一种能够直观运用概率分析的一种图解法。 Edit By Porter, 积水成渊,蛟龙生焉。 决策树是一种树形结构，其中每个内部节点表示一个属性上的测试，每个分支代表一个测试输出，每个叶节点代表一种类别。 分类树（决策树）是一种十分常用的分类方法。他是一种监管学习，所谓监管学习就是给定一堆样本，每个样本都有一组属性和一个类别，这些类别是事先确定的，那么通过学习得到一个分类器，这个分类器能够对新出现的对象给出正确的分类。这样的机器学习就被称之为监督学习。 参考自百度百科：决策树 一、组成 决策树是一种树形的结构图，在计算机预测模型中，其中每个内部节点代表一个属性上的测试，每个分支代表一个测试输出（可能的属性值），每个叶节点代表一种类别。他由分支来对该类型的对象依靠属性进行分类。当不能在进行分割或一个单独的类可以被应用于某一分支时，递归过程就完成了。 A、先画一个方框作为出发点，又称决策节点； B、从出发点向右引出若干条直线，这些直线叫做方案枝； C、在每个方案枝的末端画一个圆圈，这个圆圈称为概率分叉点，或自然状态点； D、从自然状态点引出代表各自然状态的分枝，称为概率分枝； E、如果问题只需要一级决策，则概率分枝末端画三角形，表示终点 。 二、 决策树的作用 尽可能最大化地规避项目风险。 能够直观地通过图示的方式传达信息背后的价值。 显示出项目所有可供选择的行动方案，行动方案之间的关系，行动方案的后果以及发生的概率，甚至是每种方案的损益期望值。 具体的决策树绘制方法与很多，下面给一个国内的强大绘图软件：亿方图软件绘制决策树的方法。 三、实例理解还是纯粹的理论有点不好理解，接下来进行实例，来进一步了解决策树算法。 第一个例子是引用百科的。 3.1 案例一为了适应市场的需要，某地准备扩大电视机生产。市场预测表明：产品销路好的概率为0.7；销路差的概率为0.3。 [ ] 备选方案有三个：第一个方案是建设大工厂，需要投资600万元，可使用10年；如销路好，每年可赢利200万元；如销路不好，每年会亏损40万元。 [ ] 第二个方案是建设小工厂，需投资280万元；如销路好，每年可赢利80万元；如销路不好，每年也会赢利60万元。 [ ] 第三个方案也是先建设小工厂，但是如销路好，3年后扩建，扩建需投资400万元，可使用7年，扩建后每年会赢利190万元。 根据如上绘制决策树如下图所示： 各点期望： 点②：0.7×200×10+0.3×（-40）×10-600（投资）=680（万元） 点⑤：1.0×190×7-400=930（万元） 点⑥：1.0×80×7=560（万元） 比较决策点4的情况可以看到，由于点⑤（930万元）与点⑥（560万元）相比，点⑤的期望利润值较大，因此应采用扩建的方案，而舍弃不扩建的方案。把点⑤的930万元移到点4来，可计算出点③的期望利润值。 点③：0.7×80×3+0.7×930+0.3×60×（3+7）-280 = 719（万元） 最后比较决策点1的情况。由于点③（719万元）与点②（680万元）相比，点③的期望利润值较大，因此取点③而舍点②。这样，相比之下，建设大工厂的方案不是最优方案，合理的策略应采用前3年建小工厂，如销路好，后7年进行扩建的方案。 3.2 实例学习2假设有一项工程，施工管理人员需要决定下月是否开工。如果开工后天气好，则可为国家创收4万元，若开工后天气坏，将给国家造成损失1万元，不开工则损失1000元。根据过去的统计资料，下月天气好的概率是0.3,天气坏的概率是0.7。请做出决策。现采用决策树方法进行决策。 解： 第一步：将题意表格化 自然状态 概率 行动方案 行动方案 开工 不开工 天气好 0.3 40000 -1000 天气坏 0.7 -10000 -1000 第二步：画决策树形，根据第一步所列的表格，在绘制决策树，如下图： 第三步：计算期望值 一般按反向的时间程序逐步计算，将各方案的几种可能结果的数值和它们各自的概率相乘，并汇总所得之和，其和就是该方案的期望值。 第四步：确定决策方案 在比较方案考虑的是收益值时，则取最大期望值；若考虑的是损失时，则取最小期望值。根据计算出的期望值分析，本题采取开工方案较好。 更多的可以参考这个PPT]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.10 hexo网页定制]]></title>
    <url>%2F%2Fwebcustomization%2F</url>
    <content type="text"><![CDATA[摘要本文记录了1.10 hexo网页定制，要知道原作官方提供的hexo yeele网站的手机页面和电脑页面css布局和java页面交互的文本进行个性定制。第一部分，设置手机页面的 mobile-slider.styl 等文件， 里面的css文件。 第二部分是java交互界面的文件设置。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook 一、样式定制之css样式文件定制 使用之前删掉里面的注释1.1 mobile-slider.styl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#viewer&#123; position: fixed; z-index: 1000000; top: 0; bottom: 0; left: 0; right: 0; overflow: hidden;&#125;//mune bar setting#viewer-box&#123; display: flex; width: 100%; height: 100%; position: relative;//设置浮窗的左边距 left:30px; color: #0f0; -webkit-transform: translate3d(-100%, 0, 0 ); -webkit-transition: -webkit-transform .25s ease-in-out;//设置悬浮的弹窗页面 .viewer-box-l&#123; background: rgba(20,20,20,1); width: 80%; height: auto; flex-grow: 0; min-width: 8em; max-width: 23em; .viewer-box-wrap&#123; //revise the moble menu margin: 20px 10px 10px 0px; &#125; //frends links menu .viewer-title&#123; line-height: 32px; //black background: rgba(0,0,0,1); &amp;:before&#123; content: ""; width: 6px; height: 6px; //border: 1px solid #999; border: 1px solid #006699; -webkit-border-radius: 10px; border-radius: 10px; //background is tabar of list content background: #0000cc; display: inline-block; margin-right: 10px; &#125; &#125; //div Underline, dash .viewer-div&#123; //setting div 黄色背景幕布 background: rgba(255,255,153,0.85); //蓝色圆点 border-bottom: 1px dotted #0000cc; padding-bottom: 13px; line-height: 20px; &amp;:last-child&#123; //设置标签背景白色透明，不继承上面的白色 border-bottom: none; background: rgba(229,229,255,0.01); &#125; .switch-friends-link&#123; line-height: 20px; &#125; &#125; &#125; //black .viewer-box-r&#123; flex-grow: 1 width: auto height: auto background: rgba(0,0,0,1) &amp;:hover &#123; cursor: w-resize &#125; &#125;&#125;#viewer-box.anm-swipe&#123; -webkit-transform: translate3d(0, 0, 0); .viewer-box-r&#123; background: rgba(0,0,0,1); &#125;&#125;.hide&#123; display: none;&#125;#viewer-box .viewer-list&#123; margin: 0; padding: 0; height: 100%; overflow: hidden;&#125; 1.1 mobile.styl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325.left-col &#123; display: none;&#125;.mid-col &#123; left: 0;&#125;#header&#123; .header-nav&#123; position: relative; &#125; .header-menu &#123; line-height: 1.3 min-height 3rem &#125;&#125;.header-author&#123; &amp;.fixed&#123; position: fixed; top: -8px; width: 100%; color: #ddd; a &#123; color: white; &#125; &#125;&#125;.overlay&#123; .slider-trigger&#123; position: absolute;/*设置手机页面滑动图标置于最上层显示*/ z-index: 999; bottom: 0; left: 0; width: 42px; height: 42px; &amp;:hover&#123; background: #3399; /*background: #444;*/ &#125; &amp;:before&#123; /*background: #ff3399;*/ color: #ddd; content: "\f00b"; font: 16px FontAwesome; width: 16px; height: 16px; margin-left: 9px; margin-top: 14px; display: block; &#125; &#125;&#125;.article-header&#123; border-left: none; padding: 0; border-bottom: 1px dotted #ddd; h1&#123; margin-bottom: 2px; &#125;&#125;#header .header-subtitle&#123; padding: 0 3em; font-size: 1em;&#125;.article-info-index.article-info&#123; padding-top: 10px; margin: 0; border-top: 1px solid #ddd;&#125;.article-info-post.article-info&#123; margin: 0; padding-top: 10px; border: none;&#125;#viewer-box .viewer-box-l&#123; font-size: 14px;&#125;.article&#123; margin: (10/16)rem 10px; .article-entry&#123; padding-left: 0; padding-right: 0; .highlight &#123; padding .35em .6em &#125; &#125; .article-title&#123; display: block; margin: 0; font-size 1.5rem font-weight bold &#125; .article-meta&#123; display: none; &#125;&#125;.article-inner &#123; padding: 12px;&#125;.archive-article-inner .article-meta &#123; top: 0; margin-top: .5em;&#125;.archives &#123; .archive-article &#123; padding: 0; &#125; .archive-article-date &#123; margin-right: 0; &#125; .article-info &#123; display: none; &#125;&#125;.archive-article-inner .article-meta .archive-article-date.share&#123; padding: 3px 10px;&#125;.duoshuo &#123; padding: 0 13px;&#125;#disqus_thread &#123; padding: 0 13px;&#125;#mobile-nav&#123; display: block;&#125;#page-nav .extend&#123; opacity: 1;&#125;#page-nav &#123; margin-top: 1em; .page-number &#123; margin-bottom: 1.5em; &#125;&#125;.instagram .open-ins&#123; left: 2px; top: -30px; color: #aaa;&#125;.info-on-right&#123; float: initial;&#125;.archives-wrap&#123; margin: 10px 10px 0px; padding: 10px; padding-right: 0; .archive-year-wrap&#123; position: relative; padding: 0 0 0 0; a&#123; padding: 0 0 0 0; &#125; &#125; h1 &#123; font-size: 1.2em; margin-bottom: .3em; &#125;&#125;.archives&#123; .archive-article&#123; padding: 10px 0; margin-left: 0; &#125;&#125;#footer &#123; .footer-left&#123; float: initial; margin-bottom: .5em; &#125; .footer-right&#123; float: initial; margin-bottom: 1em; &#125; .visit &#123; margin: 0; &#125;&#125;.article-category::before&#123; display: none;&#125;.article-tag::before &#123; display: none;&#125;.article-meta time:before &#123; display: none;&#125;.visit &#123; margin-top: 1em;&#125;#tocButton &#123; z-index: 100; position: fixed; left: .5em; top: auto; /*In order to cover style in article.styl*/ bottom: 10px; padding: .2em .4em; border-radius: 6px; border-style : outset; background: rgba(255, 255, 255, .7); font-size: 1em; font-weight: bold; color: gray; &amp;:hover &#123; color: #88acdb; font-size: 1em; &#125;&#125;.toc-article &#123; display: none; z-index: 99 left: 0; top: 38%; bottom: 1em; height: auto; max-height: 58%; width: none; width: auto; min-width: 7em; max-width: 61.8%; overflow: auto; margin-left: 0; padding: 10px; padding-left: 0; border-radius: 2.8%; background: none; font-size: 1em; line-height: 1.25em; .toc-title &#123; display: none; padding: .3em; color: white; background: lightgray; border-radius 3px &#125; .toc &#123; padding: 0.5em; &#125; ol &#123; margin: 0; padding: 0.5em; border-radius: 5px; background: rgba(255, 255, 255, .85); ol &#123; padding: 0.1em 0; padding-left: 1.2em; &#125; &#125; a &#123; color: #767676; &#125;&#125;if toc-nowrap li.toc-item line-height: 1.2.copyright &#123; width: 90%; padding: .5em .8em;&#125;.scroll &#123; right: 1.2em; li &#123; font-size: 1.7em; &#125;&#125;.hide-labels &#123; z-index: 100; position: fixed; left: .5em; top: auto; bottom: 10px; padding: .2em .4em; border-radius: 6px; border-style : outset; opacity: .9; background: rgba(255, 255, 255, .8); font-weight: bold; color: gray;&#125;#post-nav-button &#123; display: none;&#125;.post-list &#123; visibility: hidden;&#125;/*多说 UA*/.ua &#123; display: none !important;&#125;if hexo-config("github_widget") .github-text display none.copyright font-size 16px .copy-path display none// Tags Cloud Page.tags a line-height 45px]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>css</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.9 hexo 实现本地图片加载]]></title>
    <url>%2F%2Fhexolocalimage%2F</url>
    <content type="text"><![CDATA[摘要本文记录了1.9 hexo 实现本地图片加载，要知道原作官方提供的hexo-asset-image，根本不能满足自己的需要，所以这里是基于原作的代码进行修改实现，原作并未其提供的代码做出解释说明，本文将对更改后能实现本地图片加载的代码进行解释，并有针对性的对后来遇到问题的，或者可以给你们提供二次修改说明的解释并提醒。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook hexo-asset-image,这是原作者提供的代码，有一个特别致命的问题，是每次hexo g,后，需要手动将图片一张张对应复制到public文件夹中对应你的博文对应生成的文件夹的路径下才可以实现，本地图片显示。那么问题来了，我如果写了很多博文，需要每次复制如此多的图片到不同博文对应生成的文件夹中去。太麻烦了 若，我是写的书的格式，分章分节，一章我有10几节，那一个文件一个文件复制太麻烦了。 一、要解决的问题 我们要解决既要加载本地图库在我们的站点显示 又不想一个博文一个博文区分开了分别拷贝对应图片到public文件夹中 假设：如果我们能够把每章节的很多文章的不同图片放到该章节的图库文件夹中，这样每章就一个图库文件，我们把图库（image1文件夹）直接复制到（source文件夹下），然后直接hexo clean &amp;&amp; hexo g 就可以，这样不用手动添加文件到问文件夹中。 二、操作2.1 下载原作者的文件，然后修改原文件代码 安装原作者的hexo-asset-image 1npm install hexo-asset-image --save 2,2 原始作者的代码如下（还未经过博主修改前的代码）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 2.3 修改原作代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string//获取对应链接的'/'分开的某部分function getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; //调用上面的函数，取link链接的第三个'/'位置的数组下标值，做下面取链接的首地址区间。 var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". //取link链接的最后一个'/'，做下面取链接的尾地址区间。 var endPos = link.lastIndexOf('/') + 1; //取link连接中我们认为有用的地址部分。 link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); //取图片的名字，比如 x.png var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); //$(this).attr('src', config.root + link + src); //notes: src is image name,and config.root is localhost:port,the middle cahr string is my local image Repository //这我们做判断，判断原始link链接的前3个字是不是“第一章”,如果是，我们将link地址写成'image1'，（image1是我们存放第一章所有图片的图库文件夹） if(link.substring(0,3)=="第一章")&#123; //第一章的所有图片放到这个文件夹下 link="image1/"; console.info&amp;&amp;console.info("judement the fist capture!"); &#125; //这我们做判断，判断原始link链接的前3个字是不是“第二章”,如果是，我们将link地址写成'image2'，（image2是我们存放第二章所有图片的图库文件夹） else if(link.substring(0,3)=="第二章")&#123; link="image2/"; console.info&amp;&amp;console.info("judement the second capture!"); &#125; else if(link.substring(0,3)=="第三章")&#123; link="image3/"; console.info&amp;&amp;console.info("judement the third capture!"); &#125; else if(link.substring(0,3)=="第四章")&#123; link="image4/"; console.info&amp;&amp;console.info("judement the fourth capture!"); &#125; else if(link.substring(0,3)=="第五章")&#123; link="image5/"; console.info&amp;&amp;console.info("judement the fifth capture!"); &#125; else if(link.substring(0,3)=="第六章")&#123; link="image6/"; console.info&amp;&amp;console.info("judement the sixth capture!"); &#125; else if(link.substring(0,3)=="第七章")&#123; link="image7/"; console.info&amp;&amp;console.info("judement the seventh capture!"); &#125; //$(this).attr('src', config.root + "image1/" + src); //这里我们做字符串的拼接，将最终输出的图片链接地址改为：config.root + link + src //其中config.root 是'/'表示根目录。link使我们的图库相对根目录的位置。src是图片的名字: x.png或其他格式图片 $(this).attr('src', config.root + link + src); //终端上打印调试信息，供自己调试，是否每个图片输出地址是正确的。 console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + "==" + link + "==" + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 2.3 修改你站点文件根目录的_config.yml文件的配置信息找到如下条，将默认的false改为true,注意_config.yml不是你的主题文件家中的文件 1post_asset_folder: true # local image to url,revise true 2.4 我的博文目录格式如下图片所示： 2.5 将你的的博文直接放到你站点根目录下的：source-&gt;_post文件夹下，如下图 2.6 将你的所有章节的图库文件夹直接放到source文件夹中即可如图： 三、Hexo手机页面优化文件路径 1站点根目录/themes/yelee/source/css/_partial/mobile-slider.styl 修改mobile-slider.styl文件内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#viewer&#123; position: fixed; z-index: 1000000; top: 0; bottom: 0; left: 0; right: 0; overflow: hidden;&#125;#viewer-box&#123; display: flex; width: 100%; height: 100%; position: relative; color: #ccc; -webkit-transform: translate3d(-100%, 0, 0 ); -webkit-transition: -webkit-transform .25s ease-in-out; .viewer-box-l&#123; background: rgba(20,20,20,1); width: 80%; height: auto; flex-grow: 0; min-width: 8em; max-width: 23em; .viewer-box-wrap&#123; //revise the moble menu margin: 20px 10px 0px 60px; &#125; .viewer-title&#123; line-height: 32px; &amp;:before&#123; content: ""; width: 6px; height: 6px; border: 1px solid #999; -webkit-border-radius: 10px; border-radius: 10px; background: #0000cc; display: inline-block; margin-right: 10px; &#125; &#125; .viewer-div&#123; border-bottom: 1px dotted #666; padding-bottom: 13px; line-height: 20px; &amp;:last-child&#123; border-bottom: none; &#125; .switch-friends-link&#123; line-height: 20px; &#125; &#125; &#125; .viewer-box-r&#123; flex-grow: 1 width: auto height: auto background: rgba(0,0,0,0) &amp;:hover &#123; cursor: w-resize &#125; &#125;&#125;#viewer-box.anm-swipe&#123; -webkit-transform: translate3d(0, 0, 0); .viewer-box-r&#123; background: rgba(0,0,0,0); &#125;&#125;.hide&#123; display: none;&#125;#viewer-box .viewer-list&#123; margin: 0; padding: 0; height: 100%; overflow: hidden;&#125;]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>hexo</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.12 logistic regression]]></title>
    <url>%2F%2FlogisticRe%2F</url>
    <content type="text"><![CDATA[摘要 Edit By Porter, 积水成渊,蛟龙生焉。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>logistic regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.13 局部响应归一化]]></title>
    <url>%2F%2FLRN%2F</url>
    <content type="text"><![CDATA[摘要LRN(Local Reponse Normalization, 局部响应归一化), 该层中其作用类似DROPOUT和数据增强作为relu激励之后防止数据过拟合而提出的一种处理方法。 作用： 有利于增加泛化能力 做了平滑处理 防止过拟合 LRN 层模仿生物神经系统的侧抑制机制，对局部神经元的活动创建竞争机制，使得响应比较大的值相对更大，提高模型的泛化能力。 Edit By Porter, 积水成渊,蛟龙生焉。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>LRN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朴素贝叶斯法]]></title>
    <url>%2F%2Fpusubeiyesi%2F</url>
    <content type="text"><![CDATA[摘要朴素贝叶斯方法是基于贝叶斯定理与条件假设的分类方法 [1] 特征条件独立假设，求输入/出的联合概率分布d [2] 利用贝叶斯定理求出最大后验概率 [x] Edit By Porter, 积水成渊,蛟龙生焉。 贝叶斯公式$$p(c|x)= \frac{p(x|c)P(c)}{P(x)}$$ 朴素贝叶斯基本方法(X,Y 独立同分布)训练数据集T: $$T={(x_{1},y_{1}),(x_{2},y_{2}),…,(x_{N},y_{N}),} $$ 由$$P(x,y)$$独立同分布产生. $$P(Y=c_{k}|X=x)=\frac{P(X=x|Y=c_{k})P(Y=c_{k})}{\sum_{k}^{}P(X=x|Y=c_{k})P(Y=c_{k}) }$$ 公式概念 联合概率分布 $$P(X,Y)$$ 是独立同分布产生的联合概率分布。 先验概率分布 $$P(Y=c_{k}),k=1,2,3,…,k$$ 条件概率分布 $$P(X=x|Y=c_{k}) = P(X^{1}=x^{1},X^{2}=x^{2},…X^{N}=x^{N}|Y=c_{k}) , k=1,2,3,…,k$$ 后验概率分布 $$P(Y=c_{k}|X=x)$$ 朴素贝叶斯的表达式由于朴素二字的前提是独立特征分布概率，所以条件独立假设为(条件概率)为： $$P(X=x|Y=c_{k})=P(X^{1}=x^{1},X^{2}=x^{2},…,X^{n}=x^{n}|Y=c_{k})$$$$=\prod {j=1}^{n}P(X^{j}=x^{j}|Y=c{k})$$ 朴素贝叶斯实际上是学习到生成数据的机制，所以属于生成学习模型 朴素贝叶斯分类器于是朴素贝叶斯分类器可表示为: $$y=f(x)=arg\;max_{c_{k}}\frac{P(Y=c_{k})\prod_{j} P(X^{j}=x^{j}|y=c_{k})}{\sum_{k}^{}P(Y=c_{k})\prod_{j}P(X^{j}=x^{j}|Y=c_{k}) }$$ 由于上式分母对$$c_{k}$$，都是相同的，所以分类器的输出y又可以是： $$y=f(x)=arg\;max_{c_{k}}P(Y=c_{k})\prod_{j} P(X^{j}=x^{j}|y=c_{k})$$ 贝叶斯估计条件概率贝叶斯估计$$P(X^{j}=a_{jl}|Y=c_{k})=\frac{\sum_{i=1}^{N}I(x_{i}^{j}=a_{jl},y_{i}=c_{k})+\lambda }{\sum_{i=1}^{N}I(y_{i}=c_{k})+S_{j}\lambda }, j=1,2,…,n;l=1,2,..,S_{j};k=1,2,…,K$$ 先验概率的贝叶斯估计$$P(Y=c_{k})=\frac{\sum_{N}^{i=1}I(y_{i}=c_{k})+lambda }{N+k\lambda },k=1,2,…,K$$ 参考参考文档来源2:李航-朴素贝叶斯]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS室内仿真环境]]></title>
    <url>%2F%2FrosSimulink%2F</url>
    <content type="text"><![CDATA[摘要本节笔记主要记录ROS室内仿真环景的具体演示过程和 Edit By Porter, 积水成渊,蛟龙生焉。 《机器人操作系统入门》课程代码示例 前言欢迎来到中国大学MOOC—《机器人操作系统入门》课程，本ROS软件包是课程的代码示例，课程中使用的例子均出自本代码包。除了代码包，课程还提供讲义，欢迎各位朋友下载、学习和分享。 本示例包含了XBot机器人和中科院软件博物馆仿真、ROS通信示例程序、导航与SLAM功能演示，在每个软件包下都有相应的功能介绍。 如果你遇到任何问题，可以在Github上方的issues栏目中提问，我们课程团队会耐心回答。本示例将长期维护，不断更新，如果你认可我们的工作，请点击右上角的star按钮，您的鼓励是我们的动力。 示例介绍本仓库为ROS入门教程的代码示例，包括以下ROS软件包: 软件包 内容 robot_sim_demo 机器人仿真程序，大部分示例会用到这个软件包 topic_demo topic通信，自定义msg，包括C++和python两个版本实现 service_demo service通信，自定义srv，分别以C++和python两种语言实现 action_demo action通信，自定义action，C++和python两种语言实现 param_demo param操作，分别以C++和python两种语言实现 msgs_demo 演示msg、srv、action文件的格式规范 tf_demo tf相关API操作演示，tf示例包括C++和python两个版本 tf_follower 制作mybot机器人 实现mybot跟随xbot的功能 urdf_demo 创建机器人urdf模型，在RViz中显示 navigation_sim_demo 导航演示工具包，包括AMCL, Odometry Navigation等演示 slam_sim_demo 同步定位与建图演示，包括Gmapping, Karto, Hector等SLAM演示 robot_orbslam2_demo ORB_SLAM2的演示 ros_academy_for_beginners Metapacakge示例，依赖了本仓库所有的pacakge 下载和编译 克隆或下载ROS-Academy-for-Beginners教学包到工作空间的/src目录下，例如 ~/catkin_ws/src 12$ cd ~/catkin_ws/src$ git clone https://github.com/DroidAITech/ROS-Academy-for-Beginners.git 安装教学包所需的依赖 12$ cd ~/catkin_ws$ rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y 如果安装失败,出现如下的错误信息： 1234ERROR: the following packages/stacks could not have their rosdep keys resolved to system dependencies:slam_sim_demo: No definition of [hector_mapping] for OS [debian]navigation_sim_demo: No definition of [dwa_local_planner] for OS [debian]robot_sim_demo: No definition of [yocs_cmd_vel_mux] for OS [debian] 可以执行如下的命令(在ubuntu16下对应-xenial) 1rosdep install --from-paths src --ignore-src --rosdistro=$&#123;ROS_DISTRO&#125; -y --os=ubuntu:xenial 编译并刷新环境 12$ catkin_make$ source ~/catkin_ws/devel/setup.bash 运行示例 运行须知 建议在本地Ubuntu 16.04下运行仿真程序。目前Gazebo模拟器的兼容性是一大问题，在虚拟机或配置较低的电脑上可能无法运行。如果你的显卡是N卡，建议安装Ubuntu下的显卡驱动。 运行Gazebo仿真程序robot_sim_demo前，请将Gazebo升级到7.x版本以上（推荐7.9版本）。 查看Gazebo版本方法 1$ gazebo -v #确认7.0以上，推荐7.9 升级方法 1234$ sudo sh -c 'echo "deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main" &gt; /etc/apt/sources.list.d/gazebo-stable.list'$ wget http://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add -$ sudo apt-get update$ sudo apt-get install gazebo7 确保所有依赖都已安装，如gazebo_ros, gmapping, slam_karto, amcl。 Copyright 项目运行ROS 场景搭建 前言目前这个项目是借鉴的XBot机器人和中科院软件博物馆仿真，在此做操作备注 运行指令如下1. 编译并刷新环境123$ cd to/catkin_ws/$ catkin_make$ source ./devel/setup.bash #source devel/setup.bash 2.执行打开指令123porter@porter-Aspire:~/ROS_Project/catkin_ws$ source ./devel/setup.bashporter@porter-Aspire:~/ROS_Project/catkin_ws$ rospack profileporter@porter-Aspire:~/ROS_Project/catkin_ws$ roslaunch robot_sim_demo robot_spawn.launch 3.等待启动将会花费数秒时间，然后才会出现效果 4.运行12porter@porter-Aspire:~/ROS_Project/catkin_ws$ source devel/setup.bashporter@porter-Aspire:~/ROS_Project/catkin_ws$ rosrun robot_sim_demo robot_keyboard_teleop.py 注意每次运行rosrun 都source一下。 聚焦控制程序窗口，按下i、j、l等按键，这样你就可以通过键盘来控制机器人的移动了。javascript:void(0);]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.11 极大似然估计]]></title>
    <url>%2F%2Fjidasiranguji%2F</url>
    <content type="text"><![CDATA[摘要极大似然估计, 摘要 原理： 举个例子 贝叶斯的参数估计 先验概率的极大似然估计 条件概率极大似然估计 参考 原理： 极大似然估计是建立在极大似然原理的基础上的一个统计方法，是概率论在统计学中的应用。 极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。 通过若干次试验，观察其结果，利用试验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。 [x] Edit By Porter, 积水成渊,蛟龙生焉。 举个例子由于样本集中的样本都是独立同分布，可以只考虑一类样本集D，来估计参数向量θ。记已知的样本集为： $$D={x_{1}, x_{2},…, x_{N}}$$ 似然函数（linkehood function）：联合概率密度函数$P(D|\theta )$称为相对于$${x_{1}, x_{2},…, x_{N}}$$的$\theta$的似然函数。 $$l(\theta)=P(D|\theta)=P(x_{1}, x_{2},…,x_{N}|\theta)=\prod {i=1}^{N}P(x{i}|\theta)$$ 如果 $\hat{\theta}$是参数空间中能使似然函数$l(\theta)$最大的θ值，$\hat{\theta}$则应该是“最可能”的参数值，那么 $\hat{\theta}$ 就是θ的极大似然估计量。它是样本集的函数，记作： $$\hat{\theta}=d(x_{1},x_{2},…,xx_{N})=d(D)$$ $$\theta(x_{1},x_{2},…,xx_{N})$$,称为极大似然估计值 贝叶斯的参数估计先验概率的极大似然估计$$P(Y=c_{k})=\frac{\sum_{N}^{i=1}I(y_{i}=c_{k})}{N},k=1,2,…,K$$ I 为指示函数，上式的分子，表示$y_{i}=c_{k}$时的统计次数，分母表示一共有多少个样本。 条件概率极大似然估计$$P(X^{j}=a_{jl}|Y=c_{k})=\frac{\sum_{i=1}^{N}I(x_{i}^{j}=a_{jl},y_{i}=c_{k})}{\sum_{i=1}^{N}I(y_{i}=c_{k})}, j=1,2,…,n;l=1,2,..,S_{j};k=1,2,…,K$$ 参考参考文献1：鹏大大大-CSDN参考文档来源2:李航-极大似然估计]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>最大似然估计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.3 隐马尔科夫HMM]]></title>
    <url>%2F%2Fyingmaerkefu%2F</url>
    <content type="text"><![CDATA[摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍隐马尔科夫HMM相关实际应用搞得入门例子，很简单，但是能说明隐马尔科夫HMM的原理相关。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook HMM（隐马尔可夫模型）隐马尔可夫模型是一种统计模型，用来描述一个含有隐含未知参数的马尔可夫过程。其难点是从可观察的参数中确定该过程的隐含参数。然后利用这些参数来作进一步的分析，例如模式识别。 是在被建模的系统被认为是一个马尔可夫过程与未观测到的（隐藏的）的状态的统计马尔可夫模型。 本文简述的是离散情况下的隐马尔可夫模型. 一、贝叶斯公式定义：假设以硬币的例子，从5角和1元的一堆硬币中，随意取出一枚硬币，然后然我们猜这枚硬币是5角还是1元。假设允许我们称这枚硬币的重量x（单位：g），(但是不允许我们直接看硬币，一般1元是比5角重的)。现在应考察在一直这枚硬币的重量x的情况下硬币属于各类（5角还是一元)的概率，分别记$$P(\omega_{1}|x)$$,(知重量为x时，是5角的概率),$$P(\omega_{2}|x)$$, (知重量为x时，是一元的概率)，这种概率成为后验概率（我们需要求的）。这时的决策为：如果$$P(\omega_{1}|x)&gt;P(\omega_{2}|x)$$,则$$x \epsilon \omega_{1} $$; 反之，则$$x \epsilon \omega_{2} $$ 最终我们要的就是这个决策。 概率论中的贝叶斯公式： $$P(\omega_{i}|x)=\frac{p(x,\omega_{i})}{p(\omega_{i})}=\frac{p|\omega_{i}P(\omega_{i})}{p(x)} ,i=1,2$$ 分布 表示 $$x \epsilon \left { \omega_{1},\omega_{2} \right }$$ 类条件概率： $$p(x\mid \omega_{i})$$ 表示得到硬币结果是$$\omega_{i}$$条件下，得到x的概率密度 后验概率： $$P(\omega_{i}\mid x)$$ 在重量为x，的条件下，得到是哪种硬币（5/1）的概率 先验概率： $$P(\omega_{i})$$ 根据之前的经验，得到5角和1元各自取得的概率 硬币重量概率密度函数: $$p(x)$$ 硬币重量的概率密度函数 联合概率密度： $$p(x,\omega_{i})$$ 在重量不同条件下，每种情况对应的取得不同硬币结果的联合概率 $$P(Q_{i}|O)=\frac{P(O,Q_{i})}{P(O)}=\frac{P(O|Q_{i})P(Q)}{P(O)}$$ $$P(Q_{i}|O)=\frac{P(O,Q_{i})}{P(O)}=\frac{P(O|Q_{i})P(Q)}{P(O)}$$ $$P(Q_{i}|O)$$ ,后验概率，$$P(O,Q_{i})$$ ,表示O与Q的联合概率密度；P(O)表示两类所有的概率密度； P(Q_{i})是先验概率；$$P(O|Q_{i})$$是第i类状态随机序列的类条件概率密度 贝叶斯决策：在类条件概率密度和鲜艳概率已知（或可估计）的情况下，通过贝叶斯公式比较样本属于两类的后验概率，将类别决策为后验概率大的一类，这样做的目的是为了使总体错误率最小。 一条隐藏的马尔可夫链生成的 状态随机序列 (State sequence, 图中的白色节点) $$Q=(q_{1},q_{2},…..,q_{T})$$是不可观测的，并记所有可能状态的集合为$$S={S_{1},S_{2},…..,S_{N}}$$;由它们产生一个可观测的观测随机序列（observation sequence，图示的深色节点）$$O=(o_{1},o_{2},……,o_{T})$$, 并记所有可能观测的集合为$$V={v_{1},v_{2},……,v_{M}}$$。 序列的值可以看作是随时刻产生的，每个时刻对应着序列的一个值。所以HMM是个双重随机过程（doubly embedded stochastic process），一个是状态转移，另一个是由状态释放出观测值。在序列标注（Sequence labelling）任务中，模型就是需要对状态序列进行标注。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>隐马尔科夫HMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K近邻算法]]></title>
    <url>%2F%2Fkjinglin%2F</url>
    <content type="text"><![CDATA[摘要K近邻算法(K-nearest neighbor, k-NN)是一种基本的分类与回归的方法。 k近邻算法： 输入：训练数据集 $$T={(x_{1},y_{1}), (x_{2},y_{2})…, (x_{N},y_{N})}$$ 其中 $$x_{i}\epsilon \chi \subseteq R^{n}$$ 为实例的特征向量 $$y_{i} \epsilon Y={c_{1}, c_{2}……, c_{K}, }$$ 为实例的类别,i=1,2,…,N 输出：给定实例x，要能输出新给的特征向量所属y中的类 (1). 根据给定的距离度量，在训练集T中找出与x最邻近的k个点，涵盖这k个点的x的邻域基座 $N_{k} (x)$ ; (2). 在 $N_{k} (x)$ 中根据分类决策规则（如多数表决表，对$N_{k} (x)$ 进行排序，然后取出现频率最高的第k个点的类）决定x的类别y： $$y=arg\, \max_{c_{j}}^{\ } \sum_{x_{i}\subseteq N_{k}(x)}^{\ } I(y_{i}=c_{j})$$ 其中I为指示函数，为$$y_{i}=c_{j}$$情况下, I = 1 否则I = 0 Edit By Porter, 积水成渊,蛟龙生焉。 更通俗的理解可以为如下： KNN是通过测量不同特征值之间的距离进行分类 它的思路是： 如果选择一个待分类的样本，其在特征空间中有k个最相似的样本值（即特征空间中和这个待分类的点为最邻近点集）。 这k个样本集中的绝大多数属于某一类别，则该待分类的样本也属于这个绝大多数的同一类别。 其中K通常是不大于20的整数。 KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。 例子下面通过一个简单的例子说明一下：如下图，绿色圆要被决定赋予哪个类，是红色三角形还是蓝色四方形？如下图所示 如果K=3，最小的圆, 由于红色三角形所占比例为2/3，绿色圆将被赋予红色三角形那个类。 如果K=5，虚线内，由于蓝色四方形比例为3/5，因此绿色圆被赋予蓝色四方形类。 由此也说明了KNN算法的结果很大程度取决于K的选择。 在KNN中，通过计算对象间距离来作为各个对象之间的非相似性指标，避免了对象之间的匹配问题，在这里距离一般使用欧氏距离或曼哈顿距离： 欧氏距离：$$d(x,y)=\sqrt{\sum_{k=1}^{n}(x_{k}-y_{k})^{2}}$$ 曼哈顿距离：$$d(x,y)=\sqrt{\sum_{k=1}^{n}|x_{k}-y_{k}|}$$ 同时，KNN通过依据k个对象中占优的类别进行决策，而不是单一的对象类别决策。这两点就是KNN算法的优势。 接下来对KNN算法的思想总结一下就是在训练集中数据和标签已知的情况下，输入测试数据，将测试数据的特征与训练集中对应的特征进行相互比较，找到训练集中与之最为相似的前K个数据，则该测试数据对应的类别就是K个数据中出现次数最多的那个分类，其算法的描述为： 1）计算测试数据与各个训练数据之间的距离； 2）按照距离的递增关系进行排序； 3）选取距离最小的K个点； 4）确定前K个点所在类别的出现频率； 5）返回前K个点中出现频率最高的类别作为测试数据的预测分类。 python 代码实现： 123456789101112131415161718192021222324252627282930313233343536#coding:utf-8from numpy import *import operator##给出训练数据以及对应的类别def createDataSet(): group = array([[1.0,2.0],[1.2,0.1],[0.1,1.4],[0.3,3.5]]) labels = ['A','A','B','B'] return group,labels###通过KNN进行分类def classify(input,dataSe t,label,k): dataSize = dataSet.shape[0] ####计算欧式距离 diff = tile(input,(dataSize,1)) - dataSet sqdiff = diff ** 2 squareDist = sum(sqdiff,axis = 1)###行向量分别相加，从而得到新的一个行向量 dist = squareDist ** 0.5 ##对距离进行排序 sortedDistIndex = argsort(dist)##argsort()根据元素的值从大到小对元素进行排序，返回下标 classCount=&#123;&#125; for i in range(k): voteLabel = label[sortedDistIndex[i]] ###对选取的K个样本所属的类别个数进行统计 classCount[voteLabel] = classCount.get(voteLabel,0) + 1 ###选取出现的类别次数最多的类别 maxCount = 0 for key,value in classCount.items(): if value &gt; maxCount: maxCount = value classes = key return classes 测试代码如下： 12345678910#-*-coding:utf-8 -*-import syssys.path.append("...文件路径...")import KNNfrom numpy import *dataSet,labels = KNN.createDataSet()input = array([1.1,0.3])K = 3output = KNN.classify(input,dataSet,labels,K)print("测试数据为:",input,"分类结果为：",output) 回车之后的结果为： 测试数据为： [ 1.1 0.3] 分类为： A 答案符合我们的预期，要证明算法的准确性，势必还需要通过处理复杂问题进行验证，之后另行说明。 【提示】python版本为3.7 具体的KNN视频教程地址为： 参考参考文档来源1:Yabea-博客 参考文档来源2:李航-统计学习方法]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.2 最大熵模型]]></title>
    <url>%2F%2Fzuidashangmoxing%2F</url>
    <content type="text"><![CDATA[摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍最大熵相关实际应用搞得入门例子，很简单，但是能说明最大熵的原理相关。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook 2.1.2 隐马尔科夫HMM在讲HMM前先看看什么是熵的概念 一、什么是熵(Entropy)信息熵的概念这个得从 热熵 开始说起，信熵是香农老先生从热力学引进来的，为了表示把信息中排除了冗余后的平均信息量称为“信息熵”。 热力学中的热熵是表示分子状态混乱程度的物理量。香农用信息熵的概念来描述信源的不确定度。 1.1 热力学中–热熵从能量角度来看,熵定律意味着自然进行的能量转化过程总是由有序度高的能量向有序度低的能量转化,这个过程必定朝着熵增加的方向进行。 高温物体所有分子的平均能量要高于低温物体,所以相接触时总是从高温物体向低温物体传递热量,因为碰撞使它们的状态向平衡过渡,系统才会稳定; 热熵是向着熵增大的方向进行。从宇宙形成到地球诞生以及地球生命的形成,热熵一直有缓慢变大的趋势。 热熵改变是指在某个空间内热量分布的变化。 1、在热力学中熵是对热量状态的描述，空间内热量分布差异越大则熵越小，做功的能力越强；空间内热量分布差异越小则熵越大，做功的能力越弱。热熵改变是指在某个空间内热量分布的变化，熵越大则热量分布的差异越小。正常情况下熵会从小到大的变化，最终熵达到最大而呈热寂。 2、根据热力学第二定律，作为一个“孤立”的系统，宇宙的熵会随着时间的流逝而增加，由有序向无序，当宇宙的熵达到最大值时，宇宙中的其他有效能量已经全数转化为热能，所有物质温度达到热平衡。这种状态称为热寂。这样的宇宙中再也没有任何可以维持运动或是生命的能量存在。 3、热熵改变的本质是热量分布由有序向无序发展，所以也可以看成系统混乱程度的改变。 4、熵最初是根据热力学第二定律引出的一个反映自发过程不可逆性的物质状态参量。热力学第二定律是根据大量观察结果总结出来的规律，有下述表述方式：热量总是从高温物体传到低温物体，不可能作相反的传递而不引起其他的变化；功可以全部转化为热，但任何热机不能全部地，连续不断地把所接受的热量转变为功；在孤立系统中，实际发生过程总使整个系统的熵值增大，此即熵增原理。 简单总结：热熵是熵增的过程，热量由有序的状态，转移，或是机械能，或是向其他低温物体转移，产生的影响是，最终达到系统平衡的目的，但也使得整个系统不再是以前清晰的状态，相反是变成了另一种混乱的状态，可以这样白话理解。 1.2 信息论中的信息熵–信熵 香农用信息熵的概念来描述信源的不确定度。 信息量信息量：一个事件发生的概率越小，信息量越大，所以信息量应该为概率的减函数，对于相互独立的两个事有p(xy)=p(x)p(y)，对于这两个事件信息量应满足h(xy)=h(x)+h(y)，那么信息量应为对数函数： 信息熵根据Charles H. Bennett对Maxwell’s Demon的重新解释，对信息的销毁是一个不可逆过程，所以销毁信息是符合热力学第二定律的。而产生信息，则是为系统引入负（热力学）熵的过程。所以信息熵的符号与热力学熵应该是相反的。 假设离散随机变量X的概率分布为P(x)，则其熵为： H(x) = E[I(xi)] = E[ log(2,1/p(xi)) ] = -∑p(xi)log(2,p(xi)) (i=1,2,..n) 其中，x表示随机变量，与之相对应的是所有可能输出的集合，定义为符号集,随机变量的输出用x表示。P(x)表示输出概率函数。变量的不确定性越大，熵也就越大 ，把它搞清楚所需要的信息量也就越大. 能量角度，高温向低温转变，一般是熵增的过程；而信息论中，为了最大可能接收到正确的（发出==收到）的信息，我们处理（优化）系统，是一种熵减的过程，信熵越小，系统有用信息量越大。 信息熵：信息的基本作用就是消除人们对事物的不确定性 。多数粒子组合之后，在它似像非像的形态上押上有价值的数码，具体地说，这就是一个在博弈对局中现象信息的混乱。 举个例子-(p1log(2,p1) + p2 log(2,p2) + ．．． +p32 *log(2,p32))，其中，p1，p2 ， ．．．，p32 分别是这 32 个球队夺冠的概率。香农把它称为“信息熵” (Entropy)，一般用符号 H 表示，单位是比特。 有兴趣的读者可以推算一下当 32 个球队夺冠概率相同时，对应的信息熵等于五比特。有数学基础的读者还可以证明上面公式的值不可能大于五。因为得冠军的频率相同代表整个系统信息量最小。 熵是随机变量不确定性的度量，不确定性越大，熵值就越大；若随机变量退化成定值，熵为0。均匀分布(信熵最大)是“最不确定”的分布。 熵最早来原于物理学. 德国物理学家鲁道夫·克劳修斯首次提出熵的概念，用来表示任何一种能量在空间中分布的均匀程度，能量分布得越均匀，熵就越大。 总结：香农，描述一个信息系统的时候就借用了熵的概念，这里熵表示的是这个信息系统的平均信息量(平均不确定程度),信熵越小，系统信息不确定程度越低，反之，系统信息输出越混乱，有用信息越不容易被确认。 1.3 联合熵联合熵是一集变量之间不确定性的衡量手段。两个变量和的联合信息熵定义为： 一集变量的联合熵大于或等于这集变量中任一个的独立熵。 少于独立熵的和 这表明，两个变量关联之后不确定性会增大，但是又由于相互有制约关系，不确定小于单独两个变量的不确定度之和。 1.4 条件熵 条件熵H(X|Y) = H(X,Y) - H(Y) X在条件Y下的条件熵 条件熵 H(Y|X) 表示在已知随机变量 X 的条件下随机变量 Y 的不确定性。条件熵 H(Y|X) 定义为 X 给定条件下 Y 的条件概率分布的熵对 X 的数学期望： 证明如下： 条件熵 H(Y|X) 相当于联合熵 H(X,Y) 减去单独的熵 H(X)，即 举个例子，比如环境温度是低还是高，和我穿短袖还是外套这两个事件可以组成联合概率分布 H(X,Y)，因为两个事件加起来的信息量肯定是大于单一事件的信息量的。假设 H(X) 对应着今天环境温度的信息量，由于今天环境温度和今天我穿什么衣服这两个事件并不是独立分布的，所以在已知今天环境温度的情况下，我穿什么衣服的信息量或者说不确定性是被减少了(条件熵减少，联合熵是不变)。当已知 H(X) 这个信息量的时候，H(X,Y) 剩下的信息量就是条件熵： H(Y|X)=H(X,Y)−H(X) 1.5 相对熵与互信息 相对熵 (Relative entropy)，也称KL散度 (Kullback–Leibler divergence) 设p(x),q(x)是X中取值的两个概率分布，则p对q的相对熵是： 性质： 1、如果 p(x) 和 q(x) 两个分布相同，那么相对熵等于0 2、 ,相对熵具有不对称性。大家可以举个简单例子算一下。 3、DKL(p||q)≥0 证明如下（利用Jensen不等式https://en.wikipedia.org/wiki/Jensen%27s_inequality）： 因为： 所以： 总结：相对熵可以用来衡量两个概率分布之间的差异，上面公式的意义就是求 p 与 q 之间的对数差在 p 上的期望值。 相对熵，两者相同，那么相对熵等于0，两者差距越大，则相对熵值越大。 互信息两个随机变量X，Y的联合分布与独立分布乘积的相对熵，即： 1.6 交叉熵 (Cross entropy)熵的公式：$$H(p)=-\displaystyle\sum_{x}p(x)logp(x)$$ 相对熵的公式： $$H(p,q)=\displaystyle\sum _{x}p(x)log\frac{1}{q(x)}=-\sum _{x}p(x)logq(x)$$ 所以有： $$D_{KL}(p||q)=H(p,q)-H(p)$$ 当用非真实分布 q(x) 得到的平均码长比真实分布 p(x) 得到的平均码长多出的比特数就是相对熵） 并且当 H(p) 为常量时（注：在机器学习中，训练数据分布是固定的），最小化相对熵 DKL(p||q) 等价于最小化交叉熵 H(p,q) 也等价于最大化似然估计（具体参考Deep Learning 5.5）。 在机器学习中，我们希望在训练数据上模型学到的分布 P(model) 和真实数据的分布 P(real) 越接近越好，所以我们可以使其相对熵最小。 信息熵是衡量随机变量分布的混乱程度，是随机分布各事件发生的信息量的期望值，随机变量的取值个数越多，状态数也就越多，信息熵就越大，混乱程度就越大。当随机分布为均匀分布时，熵最大；信息熵推广到多维领域，则可得到联合信息熵；条件熵表示的是在 X 给定条件下，Y 的条件概率分布的熵对 X的期望。 相对熵可以用来衡量两个概率分布之间的差异。 交叉熵可以来衡量在给定的真实分布下，使用非真实分布所指定的策略消除系统的不确定性所需要付出的努力的大小。 几种熵的关系： 二、最大熵模型 最大熵模型在形式上是最漂亮的统计模型，而在实现上是最复杂的模型之一。最大熵模型，可以说是集简与繁于一体，形式简单，实现复杂。值得一提的是，在Google的很多产品中，比如机器翻译，都直接或间接地用到了最大熵模型。 达拉皮垂兄弟等科学家在那里，用于最大熵模型和其他一些先进的数学工具对股票预测，获得了巨大的成功。(值得一提的是，信息处理的很多数学手段，包括隐含马尔可夫模型、子波变换、贝叶斯网络等等，在华尔街多有直接的应用。由此可见，数学模型的作用)。 我们平常说的最大熵模型，只是运用最大熵思想的多分类模型，最大熵的思想却是一种通用的思维方法。所以，理解最大熵模型只需要搞清楚两件事就可以： 最大熵思想是什么 最大熵模型是如何运用最大熵思想的 2.1 最大熵思想我们知道，分类模型有判别模型和生成模型两种，判别模型是要学习一个条件概率分布 P(y|x)。举例说明 ，设：x是病人身体指标，体温、血压、血糖，y是各种可能的疾病，可简化为小病、中病、大病三种。 现在，我们有一个样本x1={体温：30，血压：160，血糖：60}，那么P(y|x1)就是一个概率分布，该分布的值就是上面简化的三种，小病、中病、大病。可能的概率分布如下所示： 之前参考样本\病况 小病 中病 大病 假设之前有和X1一样的情况有1/2的患者为小病，则此时的最大熵参考样本为 1/2 1/4 1/4 先前12个人和X1一样，结果有3个小病，4个中病的患者，则5个大病 1/4 1/3 5/12 无先前参考样本，假设取最大熵的概率 1/3 1/3 1/3 当然，这样的分布有无数种，上面只是举例说明而已。那么，问题来了，在这无数种概率分布中，哪一个才是好的呢？ 1、也就是说我们没有过往的经验可以参考，那么，就直接选一个熵最大的分布就是，也就是上面表格中的第三个分布，因为均匀分布总是同类分布中熵最大的分布。 2、如果查看以往病例后，我们得到一个经验，指标x1={体温：30，血压：160，血糖：60}有1/2的概率是小病，于是我们有了一定的经验知识，此时，最好的分布就是符合这个经验知识的前提下，熵最大的分布，显然，第一个分布就是最好的分布。 以上，我们就是运用了 最大熵的思想 。总结来说，最大熵的思想是，当你要猜一个概率分布时，如果你对这个分布一无所知，那就猜熵最大的均匀分布，如果你对这个分布知道一些情况，那么，就猜满足这些情况的熵最大的分布。 2.2 运用最大熵思想来做多分类问题 最大熵原理认为，学习概率模型时，在所有可能的概率模型（分布）中，上最大的模型是最好 的模型。 假设离散随机变量X的概率分布是P(X)，则其熵是： 熵取值范围为（当且仅当X是均匀分布时右边的等号成立）： 直观的，最大熵原理认为，要选择的概率模型首先必须要满足已有的事实，即约束条件后，对那些不确定的部分进行等可能概率分配。最大熵原理通过熵的最大化来表示为约束部分等可能性。 最大熵定义 2.3 最大熵的例题解说题：假设随机变量X有5个取值{A,B,C,D,E}, 要估计取各个值的概率P(A),P(B),P(C),P(D),P(E). 假设约束条件如下： 满足上述两个约束条件的可能取值任然很多，于是在求最大熵的过程中，为了得到最大熵，认为为约束的概率分布为等概率分布（等概率分布能确定为最大熵） 解：有约束条件和概率分布知识可知, $$min -H(P) = \sum_{i=1}^{5}P(y_{i})logP(y_{i})$$ 1s.t. P(y_&#123;1&#125;)+P(y_&#123;2&#125;)=\widetilde&#123;P(y_&#123;1&#125;)&#125;+\widetilde&#123;P(y_&#123;2&#125;)&#125;=\frac&#123;3&#125;&#123;10&#125; 1\sum_&#123;i=1&#125;^&#123;5&#125;P(y_&#123;i&#125;) = \sum_&#123;i=1&#125;^&#123;5&#125;\widetilde&#123;P(y_&#123;i&#125;)&#125;=1 其中带波浪的是实际经验分布概率函数。 引进拉格朗日乘子、 。由上面的约束条件得到的三个方程式结合拉格朗日乘子得到如下拉格朗日函数L(P,w)的表达式。 1L(P,w)=-H(P)+\omega _&#123;0&#125;(\sum_&#123;y&#125;^&#123; &#125;)P(y|x))+\sum_&#123;i=1&#125;^&#123;n&#125;\omega_&#123;1&#125;(E_&#123;\widetilde&#123;P&#125;&#125;(f_&#123;i&#125;)-E_&#123;P&#125;(f_&#123;i&#125;))=\sum_&#123;x,y&#125;\widetilde&#123;P(x)&#125;P(y|x)logP(y|x)+\omega_&#123;0&#125;(1-\sum_&#123;y&#125;^&#123; &#125;P(y|x))+\sum_&#123;i=1&#125;^&#123;n&#125;\omega_1(\sum_&#123;x,y&#125;\widetilde&#123;P(x,y)&#125;-\sum_&#123;x,y&#125;^&#123; &#125;\widetilde&#123;P(x)&#125;P(y|x)f_&#123;i&#125;(x,y)) 带入题干信息可得如下的拉格朗日函数对应本题的表达式： 1L(P,w)=-H(P)+\omega_&#123;0&#125;(1-\sum_&#123;y&#125;^&#123; &#125;P(y|x))+\sum_&#123;i=1&#125;^&#123;n&#125;\omega_&#123;i&#125;(E_&#123;\widetilde&#123;P&#125;&#125;(f_&#123;i&#125;)-E_&#123;P&#125;(f_&#123;i&#125;))=\sum_&#123;i=1&#125;^&#123;5&#125;P(y_&#123;i&#125;)logP(y_&#123;i&#125;)+\omega_&#123;1&#125;(P(y_&#123;1&#125;)+P(y_&#123;2&#125;)-\frac&#123;3&#125;&#123;10&#125;)+\omega_&#123;0&#125;(\sum_&#123;i=1&#125;^&#123;5&#125;P(y_&#123;i&#125;)-1) 这里只有3个限制条件，所以带入三个变量w得： 原始问题和对偶问题 根据拉格朗日函数（Ｌ)的对偶性，可以通过求解Ｌ(w)函数的对偶最优化问题得到我们原是函数（Ｌ(p))的最优解。即： 即，对于构造的Ｌ函数，求Ｐ的最小值问题对应ｗ参数的最大值最优解问题，Ｐ是要求的原始问题。Ｐ是原始问题的对偶问题的求解函数变量。 接下来开始求解了原始问题和对偶问题的最优解问题，步骤如下： 第一步先将原始问题（Ｐ参数的Ｌ函数）的最优解换化出来，即 令各偏导数等于0，解得： 于是， 第二步，将原始问题对应的对偶问题（ｗ参数，对应Ｌ函数的最优解）的最优解解出来，即 $$L(P_{w},w)$$ 关于$$w$$的极大化问题。 $$\max_{\omega}L(P_{w},w)=-2e^{-w_{1}-w_{0}-1}-3e^{-w_{1}-1}-\frac{3}{10}w_{1}-w_{0}$$ 分别求$$L(P_{w},w)$$关于$$w_{0},w_{1}$$的偏导数并令其为0，得到： $$e^{-w_{1}-w_{0}-1}=\frac{3}{20},e^{-w_{0}-1}=\frac{7}{30}$$ 于是得到所要求的概率分布为： $$P(y_{1})=P(y_{2})=\frac{3}{20},P(y_{3})=P(y_{4})=P(y_{5})=\frac{7}{30}$$ 总结：最大熵模型，形式简单，但是训练的代价太大，比如最原始的最大熵训练模型GIS（通用迭代算法）和IIS（改进迭代算法），每次迭代时间都很长，而且每步需要迭代很多次，实现复杂了。 追加 ：此处记录下拉格朗日函数的相关性质： 拉格朗日中值定理： 如果函数f(x)满足：（1）在闭区间[a, b]上连续；（2）在开区间[a, b]内可导；那么在开区间(a, b)内至少有一点 使等式 成立。 拉格朗日差值法： 1、两点确定一条直线，这条直线就是线性插值 2、 ，这个$$P_{1}(x)$$函数就是线性插值函数 为了和后面公式进行对比，上面公式可以转化为下面表达式， 这两个都是叫做线性插值的基函数 . 得到的插值效果如下： 线性插值仅仅利用两个节点信息，精确度很低，故接下来讲二次差值(考察曲线问题) 3、拉格朗日二次插值 如果按照线性插值的形式，以每3个相邻点做插值，就得到了二次插值(3个点：xi,xi+1,xi+2)： 得到的曲线效果是： 二次插值在每段二次曲线内是光滑的，但在每条曲线的连接处其光滑性可能甚至比线性插值还差。二次插值只适合3个节点的情形，当节点数超过3个时，就需要分段插值了。 4、拉格朗日多项式插值 一个n次的拉格朗日插值函数可以绘制经过(n+1)个节点的曲线，但运算量非常大。而且在次数比较高时，容易产生剧烈的震荡（龙格现象）。所以要选择位置特殊的节点（比如切比雪夫多项式的零点）进行插值，或使用多个次数较低的拉格朗日函数分段插值。（关于拉格朗日多项式和龙格现象，详见维基百科链接） 使用4次拉格朗日多项式分段插值： 如果直接使用20次的拉格朗日插值，得到的图像如下： 等，更多的插值，[请参考这里] 数值分析（拟合、插值和逼近）之数据插值方法（线性插值、二次插值、Cubic插值、埃米尔特、拉格朗日多项式插值、牛顿插值、样条插值 参考地址1参考地址2参考地址3]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>最大熵模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prioritized Experience Replay]]></title>
    <url>%2F%2FPrioritizedEP%2F</url>
    <content type="text"><![CDATA[摘要 创新点：在抽取经验池中过往经验样本时，采取按优先级抽取的方法 改进：同上 改进原因： 原来随机抽取经验忽略了经验之间的重要程度，实际上如人脑中一定会有更为重要的记忆 带来益处：使得算法更快收敛，效果更好 经验回放使得在线强化学习的agent能够记住和重新利用过去的经验，在以往的研究中，过去的经验（transition，经验池中的一条记录，表示为元祖形式，包含state，action，reward,discount factor,next state），只是通过均匀采样来获取。然而这种方法，只要原来有过这个经验，那么就跟别的经验以相同的概率会被再次利用，忽略了这些经验各自的重要程度。 本文我们提出了一种优先回放结构，这种方法可以使重要的经验被回放的概率大，从而使学习变得更有效率。 Edit By Porter, 积水成渊,蛟龙生焉。 论文笔记7：Prioritized Experience Replay]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3 线性回归]]></title>
    <url>%2F%2Fxianxinghuigui23%2F</url>
    <content type="text"><![CDATA[摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍线性回归相关基础相关实际应用搞得入门例子，很简单，但是能说明线性回归相关基础的原理相关。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook LinearRegression算法 学习参考来源 一、最小二乘法的拟合原理 最小二乘法定义如上图所示，但是初看可能会有点懵，上面的表示是啥意思，好接下来总结下我的理解 最小二乘法（又称最小平方法）是一种数学优化技术，除了能拟合直线还能拟合曲线问题。 书中截取部分如果可以这样理解$$\alpha_{i}$$，如果是二次项的话$$y=\alpha_{1} x^{2}+\alpha_{2} x + \alpha_{3} $$，知道了吧，就是一个二项式子中的待解参数。 本文为了推导和笔记的简单化，直接以拟合直线 $$f(x;a,b): y=ax+b$$ 1.1 代数推导： [1]. 假设拟合直线 $$f(x;a,b): y=ax+b$$ [2]. 已经由n个样本$$(x_{n}, y_{n})$$ [3]. 误差$$e_{i}=y_{i}-(ax_{i}+b)$$ [4]. 当$$S = \sum_{i=1}^{n} e_{i}^{2}$$为最小值时，即得到的a,b参数就是最小二乘法得到的解. 如何求解这些参数（a，b） $$\frac{\partial S}{\partial b}=-2(\sum_{i=1}^{n}y_{i}-nb-a\sum_{i=1}^{n}x_{i})$$ $$\frac{\partial S}{\partial a}=-2(\sum_{i=1}^{n}x_{i}y_{i}-b\sum_{i=1}{n}x_{i}-a\sum_{i=1}^{n}x_{i}^{2})$$ 分别令上式中对a,b求偏导数的有点等于0,以此求取对a,b的最值.有：$$n\bar x=\sum_{i=1}^{n}x_i,n\bar y=\sum_{i=1}^{n}y_i$$ 得到： $$a=\frac {\sum_{i=1}^{n}({x_i-\bar x})(y_i-\bar y)} {\sum_{i=1}^{n}({x_i-\bar x})^2}$$ $$b=\bar y-a\bar x$$ $$a=\frac {n\sum_{}^{}{x_iy_i}-\sum_{}^{}{x_i}\sum_{}^{}{y_i}} {n\sum_{}^{}{x_i}^2-(\sum_{}^{}{x_i})^2}$$ $$b=\frac {\sum_{}^{}{x_i}^2\sum_{}^{}{y_i}-\sum_{}^{}{x_i}\sum_{}^{}{x_iy_i}} {n\sum_{}^{}{x_i}^2-(\sum_{}^{}{x_i})^2}$$ 1.1.1 代数推导的代码实现123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltdef calcAB(x,y): n = len(x) sumX,sumY,sumXY,sumXX =0,0,0,0 for i in range(0,n): sumX += x[i] sumY += y[i] sumXX += x[i]*x[i] sumXY += x[i]*y[i] a = (n*sumXY -sumX*sumY)/(n*sumXX -sumX*sumX) b = (sumXX*sumY - sumX*sumXY)/(n*sumXX-sumX*sumX) return a,b,xi = [1,2,3,4,5,6,7,8,9,10]yi = [10,11.5,12,13,14.5,15.5,16.8,17.3,18,18.7]a,b=calcAB(xi,yi)print("y = %10.5fx + %10.5f" %(a,b))x = np.linspace(0,10)y = a * x + bplt.plot(x,y)plt.scatter(xi,yi)plt.show() 1.2 矩阵推导对于$$y=ax+b$$,转为向量的形式为$$W=\begin{bmatrix}w_0\w_1\end{bmatrix},X=\begin{bmatrix}1\x_1\end{bmatrix}$$ 于是：$$y=w_1x_1+w_0=W^TX$$ 损失函数为: $$L=\frac{1}{n}\sum_{i=1}^{n}(y_n-(W^TX)^2)=\frac{1}{n}(y-XW)^T(y-XW)$$ 最后可化为 $$\frac{1}{n}X^TW^TXW-\frac{2}{n}X^TW^Ty+\frac{1}{n}y^Ty$$ 令偏导为0 $$\frac{\partial L}{\partial W}=\frac{2}{n}X^TXW-\frac{2}{n}X^Ty=0$$ 另外： $$(X^TX)^{-1}X^TX=E,EW=W$$,则 $$(X^TX)^{-1}X^TXW=(X^TX)^{-1}X^Ty,W=(X^TX)^{-1}X^Ty$$ 1.2.1 代码实现：12345678910111213141516import numpy as npimport matplotlib.pyplot as pltx = [1,2,3,4,5,6,7,8,9,10]y = [10,11.5,12,13,14.5,15.5,16.8,17.3,18,18.7]A = np.vstack([x,np.ones(len(x))]).Ta,b = np.linalg.lstsq(A,y)[0]print("y = %10.5fx + %10.5f" %(a,b))x = np.array(x)y = np.array(y)plt.plot(x,y,'o',label='data',markersize=10)plt.plot(x,a*x+b,'r',label='line')plt.show() 拟合的效果（蓝线） 1.3 小结 二、线性回归线性回归的目的是找到一个与这些数据最为温和的线性函数，用来预测或者分类，主要解决线性问题。一般来说，线性回归问题都可以通过最小二乘法来求出方程。线性回归属于监督学习,因此方法和监督学习应该一样，先给一个训练集，根据这个训练集学习出一个线性函数，然后测试这个函数训练的好不好（拟合是否恰当）。Cost Function 越小的函数，说明训练数据拟合程度越好。 线性回归，通过数据集的线性组合来预测函数： $$f(x)=\omega_{1}x_{1}+\omega_{2}x_{2}+\omega_{3}x_{3}+…+\omega_{d}x_{d}+b$$ 一般向量形式写为： $$f(x)=\omega^{T}x+b$$ 其中的$$\omega=(\omega_{1};\omega_{2};\omega_{2};…\omega_{d})$$ $$x_{1},x_{2},…x_{k}$$是一组独立的预测变量 $$\omega_{1},\omega_{2},…\omega_{k}$$为模型从训练数据中学习得到的参数，或称赋予每个变量的权值。 b是一个学习到的参数，这个现行函数中的常量也称模型的偏置（Bias） 根据输入属性可分为一元，二元……多元线性回归。 多元数据集的定义如下： $$D=\left [ x_{i,j}, y_{i}\right ]$$，其中i,表示数据集第i位序列的值，而j则表示在第i位x的属性是j种属性，即数据集中，x(i,j)，i维行，j维纵坐标的矩阵。 即数据集j元的属性矩阵表示为：$$\begin{bmatrix}x_{1,1} &amp; x_{1,2} &amp; … &amp; x_{1,j-1} &amp; x_{1,j}\x_{2,1} &amp; x_{2,2} &amp; … &amp; x_{2,j-1} &amp; x_{2,j}\… &amp; … &amp; … &amp; … &amp; …\x_{i,1} &amp; x_{i,2} &amp; … &amp; x_{i,j-1} &amp; x_{i,j}\end{bmatrix}$$ 比如3元的表示一个西瓜好坏，【hue, root, echo】，加入预测函数的参数已经求得$$\omega=\left [ 0.2, 0.5, 0.3 \right ],b=1$$，则好瓜（good)函数$$f_{good}(x)=0.2 \cdot x_{hue}+0.5 \cdot x_{root}+0.3 \cdot x_{echo}+1$$ 2.1 一元线性回归 输入属性只有一个的情况，称一元线性回归 属性： 这里考虑一元的情况则数据集为： $$D=\left [ x_{i}, y_{i}\right ]_{i=1}^{m} $$,即上面矩阵表示的j元数据集中j=1，现在我们来尝试一元的线性回归。 [1] 假设我们预测函数形式：$$f(x_{i})=\omega x_{i}+b_{i}$$,使得$$f(x_{i})\approx y_{i}$$. 接下来我们引入上面的最小二乘法求参数$$\omega , b$$. [2] 假设最小均方误差函数为： $$e_{\omega^,b^}=arg_{(\omega,b)}min \sum_{i=1}^{m}(f(x_{i})-y_{i})^2 $$ [3] 对上式e的函数分别对$$\omega,b$$求偏导，对偏导结果赋值0，求$$\omega,b$$值。 [4] 偏导数 $$\frac{\partial E_{\omega,b}}{\partial \omega}=2(\omega\sum_{i=1}^{m}x_{i}^{2}-\sum_{i=1}^{m}(y_{i}-b)x_{i})$$ $$\frac{\partial E_{\omega,b}}{\partial b}=2(mb-\sum_{i=1}^{m}(y_{i} - \omega x_{i}))$$ [5] 上一步骤中的偏导数都设为零，以此来求得$$\omega , b$$. $$\omega = \frac{\sum_{i=1}^{m} y_{i}(x_{i}-\bar{x})}{\sum_{i=1}^{m}x_{i}^{2}-\frac{1}{m}(\sum_{i=1}^{m}x_{i})^2}$$ $$b=\frac{1}{m}\sum_{i=1}^{m}(y_{i}-\omega x_{i}),\bar{x}=\frac{1}{m}\sum_{i=1}^{m}x_{i}$$,$$\bar{x}$$为序列x的均值。 这里一元的线性回归，用最小二乘法求解的参数估计，称为线性回归模型的最小二乘法“参数估计”(parameter estimation). 2.2 多元线性回归类似一元，但是求解 估计的参数矩阵$$\omega, b$$，就需要全部看成矩阵的求解方法求出。见最小二乘法矩阵推导那一节，不再具体推推导了，在2.1节基础上明白线性回归，多元回归思想即可明白。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.7 神经网络浅学笔记]]></title>
    <url>%2F%2Fshenjingwanguo%2F</url>
    <content type="text"><![CDATA[摘要本文主要记录神经网络相关的基础知识 Edit By Porter, 积水成渊,蛟龙生焉。 一、神经网络神经网络是一种模拟人脑的神经网络以期能够实现类人工智能的机器学习技术。 对于神经元的研究由来已久，1904年生物学家就已经知晓了神经元的组成结构。 一个神经元通常具有多个树突，主要用来接受传入信息；而轴突只有一条，轴突尾端有许多轴突末梢可以给其他多个神经元传递信息。轴突末梢跟其他神经元的树突产生连接，从而传递信号。这个连接的位置在生物学上叫做“突触”。 1.1 神经元1.1.1 让我们来看一个经典的神经网络。这是一个包含三个层次的神经网络。 红色的是输入层，绿色的是输出层，紫色的是中间层（也叫隐藏层）。 输入层有3个输入单元，隐藏层有4个单元，输出层有2个单元。 后文中，我们统一使用这种颜色来表达神经网络的结构。 1.1.2 在开始介绍前，有一些知识可以先记在心里 设计一个神经网络时，输入层与输出层的节点数往往是固定的，中间层则可以自由指定； 神经网络结构图中的拓扑与箭头代表着预测过程时数据的流向，跟训练时的数据流有一定的区别； 结构图里的关键不是圆圈（代表“神经元”），而是连接线（代表“神经元”之间的连接）。每个连接线对应一个不同的权重（其值称为权值），这是需要训练得到的。 1.1.3 神经元结构神经元模型是一个包含输入，输出与计算功能的模型。输入可以类比为神经元的树突，而输出可以类比为神经元的轴突，计算则可以类比为细胞核。 下图是一个典型的神经元模型：包含有3个输入，1个输出，以及2个计算功能。注意中间的箭头线。这些线称为“连接”。每个上有一个“权值”。 连接是神经元中最重要的东西。每一个连接上都有一个权重。 一个神经网络的训练算法就是让权重的值调整到最佳，以使得整个网络的预测效果最好。 我们使用a来表示输入，用w来表示权值。一个表示连接的有向箭头可以这样理解：在初端，传递的信号大小仍然是a，端中间有加权参数w，经过这个加权后的信号会变成aw，因此在连接的末端，信号的大小就变成了aw。 在其他绘图模型里，有向箭头可能表示的是值的不变传递。而在神经元模型里，每个有向箭头表示的是值的加权传递。 如果我们将神经元图中的所有变量用符号表示，并且写出输出的计算公式的话，就是下图。 可见z是在输入和权值的线性加权和叠加了一个函数g的值。在MP模型里，函数g是sgn函数，也就是取符号函数。这个函数当输入大于0时，输出1，否则输出0。 下面对神经元模型的图进行一些扩展。首先将sum函数与sgn函数合并到一个圆圈里，代表神经元的内部计算。其次，把输入a与输出z写到连接线的左上方，便于后面画复杂的网络。最后说明，一个神经元可以引出多个代表输出的有向箭头，但值都是一样的。 神经元可以看作一个计算与存储单元。计算是神经元对其的输入进行计算功能。存储是神经元会暂存计算结果，并传递到下一层。 当我们用“神经元”组成网络以后，描述网络中的某个“神经元”时，我们更多地会用“单元”（unit）来指代。同时由于神经网络的表现形式是一个有向图，有时也会用“节点”（node）来表达同样的意思。 1.1.4 神经元模型的使用可以这样理解 我们有一个数据，称之为样本。样本有四个属性，其中三个属性已知，一个属性未知。我们需要做的就是通过三个已知属性预测未知属性。 具体办法就是使用神经元的公式进行计算。三个已知属性的值是a1，a2，a3，未知属性的值是z。z可以通过公式计算出来。 这里，已知的属性称之为特征，未知的属性称之为目标。假设特征与目标之间确实是线性关系，并且我们已经得到表示这个关系的权值w1，w2，w3。那么，我们就可以通过神经元模型预测新样本的目标。 1.2 单层神经网络（感知器）1958年，计算科学家Rosenblatt提出了由两层神经元组成的神经网络。他给它起了一个名字–“感知器”（Perceptron） 感知器是当时首个可以学习的人工神经网络。 1.2.1 感知器模型结构在原来MP模型的“输入”位置添加神经元节点，标志其为“输入单元”。其余不变，于是我们就有了下图：从本图开始，我们将权值w1, w2, w3写到“连接线”的中间。 在“感知器”中，有两个层次。分别是输入层和输出层。输入层里的“输入单元”只负责传输数据，不做计算。输出层里的“输出单元”则需要对前面一层的输入进行计算。 我们把需要计算的层次称之为“计算层”，并把拥有一个计算层的网络称之为“单层神经网络”。有一些文献会按照网络拥有的层数来命名，例如把“感知器”称为两层神经网络。但在本文里，我们根据计算层的数量来命名。 假如我们要预测的目标不再是一个值，而是一个向量，例如[2,3]。那么可以在输出层再增加一个“输出单元”。 可以看到，z1的计算跟原先的z并没有区别。 我们已知一个神经元的输出可以向多个神经元传递，因此z2的计算公式如下图。 可以看到，z2的计算中除了三个新的权值：w4，w5，w6以外，其他与z1是一样的。整个网络的输出如下图。 目前的表达公式有一点不让人满意的就是：w4，w5，w6是后来加的，很难表现出跟原先的w1，w2，w3的关系。 因此我们改用二维的下标，用wx,y来表达一个权值。下标中的x代表后一层神经元的序号，而y代表前一层神经元的序号（序号的顺序从上到下）。 例如，w1,2代表后一层的第1个神经元与前一层的第2个神经元的连接的权值（这种标记方式参照了Andrew Ng的课件）。根据以上方法标记，我们有了下图。 如果我们仔细看输出的计算公式，会发现这两个公式就是线性代数方程组。因此可以用矩阵乘法来表达这两个公式。 例如，输入的变量是[a1，a2，a3]T（代表由a1，a2，a3组成的列向量），用向量a来表示。方程的左边是[z1，z2]T，用向量z来表示。 系数则是矩阵W（2行3列的矩阵，排列形式与公式中的一样）。 于是，输出公式可以改写成： $$g(W * a) = z;$$ 这个公式就是神经网络中从前一层计算后一层的矩阵运算。 1.2.2 效果与神经元模型不同，感知器中的权值是通过训练得到的。因此，根据以前的知识我们知道，感知器类似一个逻辑回归模型，可以做线性分类任务。 我们可以用决策分界来形象的表达分类的效果。决策分界就是在二维的数据平面中划出一条直线，当数据的维度是3维的时候，就是划出一个平面，当数据的维度是n维时，就是划出一个n-1维的超平面。 下图显示了在二维平面中划出决策分界的效果，也就是感知器的分类效果。 感知器只能做简单的线性分类任务。 1.3 两层神经网络（多层感知器）Minsky说过单层神经网络无法解决异或问题。但是当增加一个计算层以后，两层神经网络不仅可以解决异或问题，而且具有非常好的非线性分类效果。不过两层神经网络的计算是一个问题，没有一个较好的解法。 1986年，Rumelhar和Hinton等人提出了反向传播（Backpropagation，BP）算法，解决了两层神经网络所需要的复杂计算量问题，从而带动了业界使用两层神经网络研究的热潮。目前，大量的教授神经网络的教材，都是重点介绍两层（带一个隐藏层）神经网络的内容。 这时候的Hinton还很年轻，30年以后，正是他重新定义了神经网络，带来了神经网络复苏的又一春。 1.3.1 两层神经网络的结构（多层感知器）Minsky说过单层神经网络无法解决异或问题。但是当增加一个计算层以后，两层神经网络不仅可以解决异或问题，而且具有非常好的非线性分类效果。不过两层神经网络的计算是一个问题，没有一个较好的解法。 两层神经网络除了包含一个输入层，一个输出层以外，还增加了一个中间层。此时，中间层和输出层都是计算层。我们扩展上节的单层神经网络，在右边新加一个层次（只含有一个节点）。 现在，我们的权值矩阵增加到了两个，我们用上标来区分不同层次之间的变量。 例如$$a_{x} ^{(y)}$$代表第y层的第x个节点。$$z_{1},z_{2}$$变成了$$a_{1} ^{(2)} , a_{2} ^{(2)}$$。下图给出了$$a_{1} ^{(2)} , a_{2} ^{(2)}$$的计算公式。 计算最终输出z的方式是利用了中间层的$$a_{1} ^{(2)}, a_{2} ^{(2)}$$和第二个权值矩阵计算得到的，如下图。 假设我们的预测目标是一个向量，那么与前面类似，只需要在“输出层”再增加节点即可。 我们使用向量和矩阵来表示层次中的变量。$$a_{1} , a_{2} , z $$是网络中传输的向量数据。$$W^{(1)}, W^{(2)}$$是网络的矩阵参数。如下图。 使用矩阵运算来表达整个计算公式的话如下： $$g(W^{(1)} a^{(1)}) = a^{(2)}; g(W^{(2)} a^{(2)}) = z;$$ 上面写的全是权重w但还未引入偏置。下面我们接着写偏置 由此可见，使用矩阵运算来表达是很简洁的，而且也不会受到节点数增多的影响（无论有多少节点参与运算，乘法两端都只有一个变量）。因此神经网络的教程中大量使用矩阵运算来描述。 需要说明的是，至今为止，我们对神经网络的结构图的讨论中都没有提到偏置节点（bias unit）。事实上，这些节点是默认存在的。它本质上是一个只含有存储功能，且存储值永远为1的单元。在神经网络的每个层次中，除了输出层以外，都会含有这样一个偏置单元。正如线性回归模型与逻辑回归模型中的一样。 偏置单元与后一层的所有节点都有连接，我们设这些参数值为向量b，称之为偏置。如下图。 可以看出，偏置节点很好认，因为其没有输入（前一层中没有箭头指向它）。有些神经网络的结构图中会把偏置节点明显画出来，有些不会。一般情况下，我们都不会明确画出偏置节点。 在考虑了偏置以后的一个神经网络的矩阵运算如下： $$g(W^{(1)} a^{(1)}+b^{(1)}) = a^{(2)}; g(W^{(2)} a^{(2)}+b^{(1)}) = z;$$ 需要说明的是，在两层神经网络中，我们不再使用sgn函数作为函数g，而是使用平滑函数sigmoid作为函数g。我们把函数g也称作激活函数（active function）。 事实上，神经网络的本质就是通过参数与激活函数来拟合特征与目标之间的真实函数关系。初学者可能认为画神经网络的结构图是为了在程序中实现这些圆圈与线，但在一个神经网络的程序中，既没有“线”这个对象，也没有“单元”这个对象。实现一个神经网络最需要的是线性代数库。 1.4 多层神经网络（深度学习）1.4.1 多层神经网络的结构（深度学习）我们延续两层神经网络的方式来设计一个多层神经网络。 在两层神经网络的输出层后面，继续添加层次。原来的输出层变成中间层，新加的层次成为新的输出层。所以可以得到下图。 依照这样的方式不断添加，我们可以得到更多层的多层神经网络。公式推导的话其实跟两层神经网络类似，使用矩阵运算的话就仅仅是加一个公式而已。 在已知输入$$a^{(1)}$$，参数$$W^{(1)},W^{(2)},W^{(3)}$$的情况下，输出z的推导公式如下：$$g(W^{(1)} * a^{(1)}) = a^{(2)}; g(W^{(2)} * a^{(2)}) = a^{(3)}; g(W^{(3)} * a^{(3)}) = z;$$ 多层神经网络中，输出也是按照一层一层的方式来计算。从最外面的层开始，算出所有单元的值以后，再继续计算更深一层。只有当前层所有单元的值都计算完毕以后，才会算下一层。有点像计算向前不断推进的感觉。所以这个过程叫做“正向传播”。 下面讨论一下多层神经网络中的参数。 首先我们看第一张图，可以看出$$W^{(1)}$$中有6个参数，$$W^{(2)}$$中有4个参数，$$W^(3)$$中有6个参数，所以整个神经网络中的参数有16个（这里我们不考虑偏置节点，下同）。 假设我们将中间层的节点数做一下调整。第一个中间层改为3个单元，第二个中间层改为4个单元。 经过调整以后，整个网络的参数变成了33个。 虽然层数保持不变，但是第二个神经网络的参数数量却是第一个神经网络的接近两倍之多，从而带来了更好的表示（represention）能力。表示能力是多层神经网络的一个重要性质，下面会做介绍。 在参数一致的情况下，我们也可以获得一个“更深”的网络。 上图的网络中，虽然参数数量仍然是33，但却有4个中间层，是原来层数的接近两倍。这意味着一样的参数数量，可以用更深的层次去表达。 1.4.2 多层神经网络的效果（深度学习）与两层层神经网络不同。多层神经网络中的层数增加了很多。 增加更多的层次有什么好处？更深入的表示特征，以及更强的函数模拟能力。 更深入的表示特征可以这样理解，随着网络的层数增加，每一层对于前一层次的抽象表示更深入。在神经网络中，每一层神经元学习到的是前一层神经元值的更抽象的表示。例如第一个隐藏层学习到的是“边缘”的特征，第二个隐藏层学习到的是由“边缘”组成的“形状”的特征，第三个隐藏层学习到的是由“形状”组成的“图案”的特征，最后的隐藏层学习到的是由“图案”组成的“目标”的特征。通过抽取更抽象的特征来对事物进行区分，从而获得更好的区分与分类能力。 关于逐层特征学习的例子，可以参考下图。 更强的函数模拟能力是由于随着层数的增加，整个网络的参数就越多。而神经网络其实本质就是模拟特征与目标之间的真实关系函数的方法，更多的参数意味着其模拟的函数可以更加的复杂，可以有更多的容量（capcity）去拟合真正的关系。 通过研究发现，在参数数量一样的情况下，更深的网络往往具有比浅层的网络更好的识别效率。这点也在ImageNet的多次大赛中得到了证实。从2012年起，每年获得ImageNet冠军的深度神经网络的层数逐年增加，2015年最好的方法GoogleNet是一个多达22层的神经网络。 在最新一届的ImageNet大赛上，目前拿到最好成绩的MSRA团队的方法使用的更是一个深达152层的网络！关于这个方法更多的信息有兴趣的可以查阅ImageNet网站。 1.4.3 多层神经网络的训练（深度学习）在单层神经网络时，我们使用的激活函数是sgn函数。到了两层神经网络时，我们使用的最多的是sigmoid函数。而到了多层神经网络时，通过一系列的研究发现，ReLU函数在训练多层神经网络时，更容易收敛，并且预测性能更好。因此，目前在深度学习中，最流行的非线性函数是ReLU函数。ReLU函数不是传统的非线性函数，而是分段线性函数。其表达式非常简单，就是y=max(x,0)。简而言之，在x大于0，输出就是输入，而在x小于0时，输出就保持为0。这种函数的设计启发来自于生物神经元对于激励的线性响应，以及当低于某个阈值后就不再响应的模拟。 在多层神经网络中，训练的主题仍然是优化和泛化。当使用足够强的计算芯片（例如GPU图形加速卡）时，梯度下降算法以及反向传播算法在多层神经网络中的训练中仍然工作的很好。目前学术界主要的研究既在于开发新的算法，也在于对这两个算法进行不断的优化，例如，增加了一种带动量因子（momentum）的梯度下降算法。 在深度学习中，泛化技术变的比以往更加的重要。这主要是因为神经网络的层数增加了，参数也增加了，表示能力大幅度增强，很容易出现过拟合现象。因此正则化技术就显得十分重要。目前，Dropout技术，以及数据扩容（Data-Augmentation）技术是目前使用的最多的正则化技术。 文章参考来源：计算机的潜意识]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.6 递归算法与迭代算法]]></title>
    <url>%2F%2Fdiguiyudiedai%2F</url>
    <content type="text"><![CDATA[摘要本文主要记录迭代算法的相关笔记 Edit By Porter, 积水成渊,蛟龙生焉。 一、引入实例举个例子(引用)我想求1+2+3+4+..+100的值。 迭代的做法： 从1到100，顺着往下累加。1+2=3,3+3=6,6+4=10,10+5=15……程序表示 1234int i=1,sum=0;while(i&lt;=100)&#123; sum = sum +i; &#125; 递归的做法： 我要求1到100的累加值，如果我已经得到1到99的累加值，将这个值加上100就是1到100的累加值； 要得到1到99的累加值，如果已经得到1到98的累加值，将这个值加上99，就是1到99的累加值…… 最后我要得到1到2的累加值，我如果得到1自身累加值，再加上2即可，1自身的累加值显然就是1了。 于是现在我们得到了1到2的累加值，将这个值加3就得到了1到3的累加值，……最后直到得到1到100的累加值。 程序表示，其中函数会调用自身，这就是递归方法的典型特征 12345int GetSum(int n)&#123; if(n&lt;=0) return 0; else return n+GetSum(n-1);&#125; 上述例子中，其实递归最后得到结果也是用迭代方法完成的，只是在程序的处理上直观看不出来。 两者都能很好的完成计算任务，不同之处在于思维方式上，从而导致不同的计算方法： 迭代是正向思维，从头到尾思考问题； 递归是逆向思维，他假设我们已经得到了部分结果(假设我已经知道了1到99的累加值，把这个值加上100我们就得到了1到100的累加值了)，从尾部追溯到头部，从而让问题简化(当然这个例子中看不出来，这里只是方便理解）]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>迭代算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1 马尔科夫链]]></title>
    <url>%2F%2Fmaerkefu21%2F</url>
    <content type="text"><![CDATA[摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍马尔科夫相关的性质和几个实例进行论述。状态空间中经过从一个状态到另一个状态的转换的随机过程，需要具备“无记忆”的性质：下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。这种特定类型的“无记忆性”称作马尔可夫性质。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook 马尔科夫链一、常见的马尔可夫过程：(1) 独立随机过程为马尔可夫过程。 (2) 独立增量过程为马尔可夫过程：没{X(t)，t∈[0，+∞)}为一独立增量过程，且有P(X(0)=x0)=1，x0为常数，则X(t)为马尔可夫过程。 (3) 泊松过程为马尔可夫过程。 (4) 维纳过程为马尔可夫过程。 (5) 质点随机游动过程为马尔可夫过程。 二、模型的创立条件 无后效性—只与前一时刻状态相关和其他历史时刻无关。 图2-1 马尔科夫表示式 系统平稳性—平稳分布（马尔可夫链的）具有某种不变（或者说平稳）性质的概率分布。 图2-2 马尔科夫平稳分布表示式 2.1 无后效性状态空间中经过从一个状态到另一个状态的转换的随机过程。该过程要求具备“无记忆”的性质：下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。这种特定类型的“无记忆性”称作马尔可夫性质。马尔科夫链作为实际过程的统计模型具有许多应用。 在马尔可夫链的每一步，系统根据概率分布，可以从一个状态变到另一个状态，也可以保持当前状态。状态的改变叫做转移，与不同的状态改变相关的概率叫做转移概率。随机漫步就是马尔可夫链的例子。随机漫步中每一步的状态是在图形中的点，每一步可以移动到任何一个相邻的点，在这里移动到每一个点的概率都是相同的（无论之前漫步路径是如何的）。 作者：bitcarmanlee来源：CSDN原文：https://blog.csdn.net/bitcarmanlee/article/details/82819860版权声明：本文为博主原创文章，转载请附上博文链接！ 2.2 平稳分布概念 平稳分布是一种概率分布。平稳分布（马尔可夫链的）具有某种不变（或者说平稳）性质的概率分布。 图2-3 平稳分布，百度百科解释 三、马尔科夫相关的例子直接看理论是有点头痛的，但是接下来直接上例子，学习致用，在应用中学习。 3.1 马尔科夫股市模型实例假设股市三种状态：牛市（Bull market）, 熊市（Bear market）和横盘（Stagnant market），每一个状态都以一定的概率转化到下一个状态。 3.1 题设 图3-1 股市概率转移状态图 比如，牛市以0.025的概率转化到横盘的状态。这个状态概率转化图可以以矩阵的形式表示。如果我们定义矩阵阵P某一位置P(i, j)的值为P(j|i)， 即从状态i变为状态j的概率 。另外定义牛市、熊市、横盘的状态分别为0、1、2，这样我们得到了马尔科夫链模型的状态转移矩阵为： 图3-2 马尔科夫状态转移概率矩阵 当这个状态转移矩阵P确定以后，整个股市模型就已经确定！ 3.1.1 用计算结果说明马尔科夫的性质（无后效性，和系统平稳性） 步骤一、假设初始状态：t0​=[0.1,0.2,0.7]，然后算之后的状态。 步骤二、计算方法是用这个初始的状态分布概率向量(t0)点乘我们的马尔科夫状态转移概率矩阵(P)。 如图2-2 所说的，当P^n –&gt; 会趋向一个稳定的转移概率矩阵。 Python 代码验证： 1234567891011import numpy as npdef markov(): init_array = np.array([0.1, 0.2, 0.7]) transfer_matrix = np.array([[0.9, 0.075, 0.025], [0.15, 0.8, 0.05], [0.25, 0.25, 0.5]]) restmp = init_array for i in range(25): res = np.dot(restmp, transfer_matrix) print i, "\t", res restmp = res markov() 执行以上代码后，输出结果，如图所示 图3-3 马尔科夫股市代码输出 从第18次开始，状态就开始收敛至[0.624,0.312,0.0625]。最终数字上略有不同，只是计算机浮点数运算造成的罢了。 如果我们换一个初始状态t0​，比如[0.2,0.3.0.5]，继续运行上面的代码，只是将init_array变一下，最后结果为： 到第18次的时候，又收敛到了[0.624,0.312,0.0625]!这个转移矩阵就厉害了。不管我们的初始状态是什么样子的，只要状态转移矩阵不发生变化，当n→∞时，最终状态始终会收敛到一个固定值。 3.1.2 后续接着代码验证 图2-2 马尔科夫平稳分布表示式（3点）我们也看看这个状态转移矩阵P的25(本是n-&gt;∞幂次方) 幂次方有什么有意思的地方？ 12345678910def matrixpower(): transfer_matrix = np.array([[0.9, 0.075, 0.025], [0.15, 0.8, 0.05], [0.25, 0.25, 0.5]]) restmp = transfer_matrix for i in range(25): res = np.dot(restmp, transfer_matrix) print i, "\t", res restmp = res matrixpower() 执行以上代码 发现了，从第20次开始，结果开始收敛，并且每一行都为[0.625,0.312,0.0625]! 再次验证了图2.2的定理0.4.2的 3.2 马尔科夫的人类上中下阶层分布模型假设，社会学家把人按其经济状况分为3类：下层，中层，上层，我们用1,2,3表示这三个阶层。社会学家发现决定一个人的收入阶层最重要的因素就是其父母的收入阶层。如果一个人的收入属于下层类别，则它的孩子属于下层收入的概率为0.65，属于中层收入的概率为0.28，属于上层收入的概率为0.07。从父代到子代，收入阶层转移概率如下 我们用P表示这个转移矩阵，则 假设第1代人的阶层比例为 则前10代人的阶层分布如下 第二代人是第一代任PI0，点乘以P（转移概率），第三代人是第二代人点乘以P 我们可以看到，在相同的转移矩阵作用下，状态变化最终会趋于平稳。对于第n代人的阶层分布，我们有 从表达式上我们可以看到，π是一维向量，P是两维矩阵，P进行足够多次自乘后，值趋于稳定。 3.2.1 马尔科夫的人类农村转城市人口分布模型假设城市化进程中，农村人转移为城市人的概率为0.5，城市人转移为农村人的概率为0.1。 人口 农村人 城市人 农村人 0.5 0.5 城市人 0.1 0.9 假设一开始有100个农村人，0个城市人，每代转移人数矩阵如下 代数 农村人 城市人 农村人转移为城市人 城市人转移为农村人 1 100 0 50 0 2 50 50 25 5 3 30 70 15 7 4 22 78 11 8 5 19 81 10 8 6 17 83 8 8 7 17 83 8 8 可以看到，城市化进程中马尔科夫平稳状态就是农村人转移为城市人的速度等于城市人转移为农村人的速度。对于上述转移矩阵P，平稳分布为农村人17%，城市人83%。如果我们可以得到当前中国城市化转移矩阵P，我们就可以算出中国最终城市化率大概为多少（这里不考虑P的变化）。同时如果我们知道了中国城市化人口比例，我们就能知道城市化进程还可以持续多少代人。 3.3 车站候车人数预测模型具体的实例过程请移步 [2.1.1 马尔科夫简单模型预测实战笔记] 章节部分 四、总结4.1 马尔科夫的平稳随机性 非周期马氏链：马氏链转移要收敛，就一定不能是周期性的。不做特别处理，我们处理的问题基本上都是非周期性的 存在概率转移矩阵P，任意两个状态是连通的，如上，例题中的每个不同的阶层人的角色通过某种方式，他们之间是可以相互转化，前后转化的两种状态是联通的可以转化的，底层人士可以转化成中层等。 不论初始状态是什么，经过足够多次概率转移后，会存在一个稳定的状态π。概率转移矩阵自乘足够多次后，每行值相等。即 显然，由于马氏链稳定后，所有状态转移到状态j的概率之和稳定。 则π为马氏链稳定状态，并且π是方程π=πP的唯一非负解。结合上面结论，很明显。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>马尔科夫模型实战</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.1 马尔科夫简单模型预测实战笔记]]></title>
    <url>%2F%2Fmaerkefuyuce%2F</url>
    <content type="text"><![CDATA[摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍马尔科夫相关实际应用搞得入门例子，很简单，但是能说明马尔科夫的原理相关。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook 马尔科夫简单模型预测实战笔记一、基于马尔可夫链的公交停靠站乘客数预测1.1 题设 假设站点乘客数的状态具有马尔可夫性，当某一时刻有公交车停靠时， 会有一些乘客上车， 则下一时刻车辆到达时停靠站的乘客数与这一时刻剩余的乘客相关， 这一特征符合了马尔可夫链的马尔可夫性，同时在任意时刻的候车乘客只与上一时刻的乘客数相关， 而与候车时间无关。—-满足马尔科夫。 数据 以该停靠站点的候车乘客数为统计对象， 按照离散时间， 在状态转移中将以时间间隔为五分钟而对停靠站点的乘客数进行计数。以工作日某一天的上午8∶ 00 ～ 10∶ 00 的两小时为统计的时间段， 其中第一组数据为时刻 8∶05 时的乘客数， 可得到 24 组数据。如下图所示： 图1-1 8-10点的24组数据 由表 1 可知， 该站点的乘客数区间为［12， 27］，为保证预测的准确性， 根据建模步骤可将站点的乘客数分为 3 种状态， 即状态空间为( E1， E2， E3 ) ， 其中 E1 表示乘客数为 11 ～ 16， E2 表示乘客数为 17 ～22， E3 表示乘客数为 23 ～ 28， 因此有乘客数状态空间的频数分布， 如表 2 所示。 于是得到对应上表的如下状态分布表 表二 时间点 乘客人数 时间表 乘客人数 时间表 乘客人数 时间表 乘客人数 1 E1 7 E2 13 E1 9 E2 2 E1 8 E3 14 E2 20 E1 3 E2 9 E2 15 E2 21 E1 4 E2 10 E2 16 E3 22 E1 5 E2 11 E1 17 E3 22 E1 6 E2 12 E2 18 E2 24 E1 于是可以得到状态转移频次表如下表所示： 表三 单位(人) E1 E2 E3 E1 5 3 0 E2 3 7 2 E3 0 2 1 1.2 计算模型根据马尔可夫变量的特征， 结合变量状态转移概率矩阵， 对站点乘客数的预测步骤如下: 统计时需注意: 引起乘客数状态变化的转入包括下车后仍留在站点候车的乘客; 引起乘客数状态变化的转出则包括经过停靠车辆后上车的乘客， 则有表 1。 由表二可统计得到如下信息： E1 E2 E3 当前统计总数(人) 8 12 3 由此可得到表三对应的转移概率矩阵，如下 转移概率 E1 E2 E3 E1 5/8 3/8 0/8 E2 3/12 7/12 2/12 E3 0/3 2/3 1/3 即： 转移概率 E1 E2 E3 E1 0.625 0.375 0 E2 0.25 0.58 0.17 E3 0 0.67 0.33 设初始时刻的状态分布为10点的时刻。由于10点出行人数是14人，在E1(11~16)之间，故设出事时刻的概率分布为: N(0)=(1, 0, 0) 由N(1)=N(0).*P(1)=(0.625, 0.375, 0) 12345678910111213import numpy as npdef markov(): init_array = np.array([1, 0, 0]) transfer_matrix = np.array([[0.625, 0.375, 0], [0.25, 0.58, 0.17], [0, 0.67, 0.33]]) restmp = init_array for i in range(25): res = np.dot(restmp, transfer_matrix) print('N(',i+1,')', "\t", res ) restmp = res markov() N(0), 代表10：00的乘客数。N(1)代表10:05分的乘客数.N(2)代表10:10分的乘客数，以此类推。 取上面设定的状态范围（11~16）， （17-22）， （18~28），分别对上面的取值区间做中值得到13.5， 19.5， 25.5； 设 E1=13.5, E2=19.5, E3=25.5. 由10:05分的站点乘客数量状态分布，N(1)=[0.625, 0.375, 0],和E=[13.5, 19.5, 25.5]可求得10:05的期望值Ex $$E_{x}=\sum_{i=1}^{3} (N(1,i)*E(i)) = 0.625\times 13.5 + 0.375\times19.5 + 0\times25.5 = 15.75$$ 在概率论和统计学中，数学期望(mean)（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。 即，在10:05的时刻，车站人数最可能有15.75个人在等车。 同理在10:10分，N(2)=[0.484375, 0.451875, 0.06375], 则此时刻（10:05），车站最可能（该时刻的期望值）出现的候车人数经计算为： 16.7503125（人），具体计算过程如下： $$E_{x}=\sum_{i=1}^{3} (N(1,i)*E(i)) = 0.484375\times 13.5 + 0.451875\times19.5 + 0.06375\times25.5 = 16.7503125$$ 推荐下在线Latex公式编辑网站 10:15时刻，10:20时刻，10:25时刻，……计算方法一次类推，于是可得到整个时间段站台候车人数的预测表，如下表： 时刻 状态 转移率 站台乘客数预测值 站台人数实际值 E1 0.625 — — 10:05 E2 0.375 15.75 14 E3 0 — — — — — — — E1 0.484375 — — 10:10 E2 0.50358792 16.7503125 16 E3 0.09785625 — — — — — — — E1 0.38142461 — — 10:15 E2 0.50358792 17.90137716 17 E3 0.11498747 — — — — — — — E1 0.36428736 — — 10:20 E2 0.51215683 18.0556107 18 E3 0.12355581 — — — — — — — E1 0.35571881 — — 10:25 E2 0.51644111 18.13272762 18 E3 0.12784008 — — — — — — — E1 0.35143453 — — 10:30 E2 0.51858325 18.17128614 18 E3 0.12998222 — — 以上的基于马尔科夫的模型预测和实际值的趋势图如下图所示： 图像在线生成：推荐下在线绘图做表的网站 预测结果表明在马尔可夫链理论下的预测会受到时间长短的影响， 在短时间内的统计， 预测结果与实际值间的误差较为明显， 当统计量足够多时， 预测的趋势会更加符合实际情况。 C-K方程( Chapman- Kolmogorov方程)-马尔可夫链定义如下: 参考文献：[1]刘哲华.基于马尔可夫链的公交停靠站乘客数预测[J].黑龙江交通科技,2018,41(11):155-157. 二、最佳经营策略应用]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>马尔科夫模型实战</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页设计基础笔记]]></title>
    <url>%2F%2Fwebdessignnotes%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要 网页效果图设计，可以Fireworks,也可以Photoshop以及其他的平面设计软件 根据网页效果图进行切图 为什么要切图：提高网站下载速率，规律：能用CSS效果表现出来的就少用图像，也是为了提高下载速率]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的方法，获取在线付费设计log的方法]]></title>
    <url>%2F%2Ffreelog%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要有时人穷则需要志坚，花别人返工心情的时间，做别人不愿做的尝试。 今天的目标对象是他：Log设计网 不是我不支持他，而是因为，太穷，没那么多钱钱，用到啥买啥，所以，看能省钱的地方就省了吧。 本文档是教如何免费获取99元套餐的log设计资源。 点击进入Log官网的个人中心 选择你目前编辑的Log 点击页面的分享 在浏览页面中鼠标右键，进入inspect界面 点击Source 查看源码 搜索关键字“jpg” 复制图片链接，下载，好了，这就是你自己的Log了 以上步骤结束，不贴图了，贴图影响不好了]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git中忽略提交项]]></title>
    <url>%2F%2FgitIgnore%2F</url>
    <content type="text"><![CDATA[摘要：本文记录了git的忽略提交的git规则配置，及一些举例。 参考博客资料 在Git项目中定义.gitignore文件对于经常使用Git的朋友来说，.gitignore配置一定不会陌生。这种方式通过在项目的某个文件夹下定义.gitignore文件，在该文件中定义相应的忽略规则，来管理当前文件夹下的文件的Git提交行为。.gitignore 文件是可以提交到公有仓库中，这就为该项目下的所有开发者都共享一套定义好的忽略规则。在.gitingore 文件中，遵循相应的语法，在每一行指定一个忽略规则。如： 123*.log*.temp/vendor 在Git项目的设置中指定排除文件这种方式只是临时指定该项目的行为，需要编辑当前项目下的 .git/info/exclude文件，然后将需要忽略提交的文件写入其中。需要注意的是，这种方式指定的忽略文件的根目录是项目根目录。 定义Git全局的 .gitignore 文件除了可以在项目中定义 .gitignore 文件外，还可以设置全局的git .gitignore文件来管理所有Git项目的行为。这种方式在不同的项目开发者之间是不共享的，是属于项目之上Git应用级别的行为。这种方式也需要创建相应的 .gitignore 文件，可以放在任意位置。然后在使用以下命令配置Git： 1# git config --global core.excludesfile ~/.gitignore 首先要强调一点，这个文件的完整文件名就是”.gitignore”，注意最前面有个“.”。一般来说每个Git项目中都需要一个“.gitignore”文件，这个文件的作用就是告诉Git哪些文件不需要添加到版本管理中。实际项目中，很多文件都是不需要版本管理的，比如Python的.pyc文件和一些包含密码的配置文件等等。这个文件的内容是一些规则，Git会根据这些规则来判断是否将文件添加到版本控制中。 Git忽略文件的原则 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 .gitignore文件的使用方法 首先，在你的工作区新建一个名称为.gitignore的文件。 然后，把要忽略的文件名填进去，Git就会自动忽略这些文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。 有时对于git项目下的某些文件，我们不需要纳入版本控制，比如日志文件或者IDE的配置文件，此时可以在项目的根目录下建立一个隐藏文件 .gitignore（linux下以.开头的文件都是隐藏文件），然后在.gitignore中写入需要忽略的文件。 1234[root@kevin ~]# cat .gitignore*.xml*.log*.apk .gitignore注释用’#’, *表示匹配0个或多个任意字符，所以上面的模式就是要忽略所有的xml文件,log文件和apk文件。 .gitignore配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为版本管理带来很大的便利。 .gitignore忽略规则的优先级在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）： 1）从命令行中读取可用的忽略规则 2）当前目录定义的规则 3）父级目录定义的规则，依次递推 4）$GIT_DIR/info/exclude 文件中定义的规则 5）core.excludesfile中定义的全局规则 .gitignore忽略规则的匹配语法在 .gitignore 文件中，每一行的忽略规则的语法如下：1）空格不匹配任意文件，可作为分隔符，可用反斜杠转义2）以“＃”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。3）可以使用标准的glob模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。4）以斜杠”/“开头表示目录；”/“结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；”/“开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。5）以星号”*”通配多个字符，即匹配多个任意字符；使用两个星号”“ 表示匹配任意中间目录，比如`a//z`可以匹配 a/z, a/b/z 或 a/b/c/z等。6）以问号”?”通配单个字符，即匹配一个任意字符；7）以方括号”[]”包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。8）以叹号”!”表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用”!”规则是不起作用的。也就是说”!”开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用”!”也不会再次被包含。可以使用反斜杠进行转义。 需要谨记：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； .gitignore忽略规则简单说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 表示此为注释,将被Git忽略*.a 表示忽略所有 .a 结尾的文件!lib.a 表示但lib.a除外/TODO 表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ 表示忽略 build/目录下的所有文件，过滤整个build文件夹；doc/*.txt 表示会忽略doc/notes.txt但不包括 doc/server/arch.txt bin/: 表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件/bin: 表示忽略根目录下的bin文件/*.c: 表示忽略cat.c，不忽略 build/cat.cdebug/*.obj: 表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj**/foo: 表示忽略/foo,a/foo,a/b/foo等a/**/b: 表示忽略a/b, a/x/b,a/x/y/b等!/bin/run.sh 表示不忽略bin目录下的run.sh文件*.log: 表示忽略所有 .log 文件config.php: 表示忽略当前路径的 config.php 文件 /mtk/ 表示过滤整个文件夹*.zip 表示过滤所有.zip文件/mtk/do.c 表示过滤某个具体文件 被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。 需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：!*.zip!/mtk/one.txt 唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：/mtk/*!/mtk/one.txt 假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！ ----------------------------------------------------------------------------------还有一些规则如下：fd1/*说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； /fd1/*说明：忽略根目录下的 /fd1/ 目录的全部内容； /*!.gitignore!/fw/ /fw/*!/fw/bin/!/fw/sf/说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。 温馨提示： 如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。简单来说出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。所以大家一定要养成在项目开始就创建.gitignore文件的习惯，否则一单push，处理起来会非常麻烦。 .gitignore忽略规则常用示例1）示例 比如你的项目是java项目，.java文件编译后会生成.class文件，这些文件多数情况下是不想被传到仓库中的文件。这时候你可以直接适用github的.gitignore文件模板将这些忽略文件信息复制到你的.gitignore文件中去： 1234567891011121314151617181920212223# Compiled class file*.class # Log file*.log # BlueJ files*.ctxt # Mobile Tools for Java (J2ME).mtj.tmp/ # Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar # virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid* 可以看到github为我们提供了最流行的.gitignore文件配置。保存.ignore文件后我们查看下git status，检查下是否还有我们不需要的文件会被添加到git中去：123456789101112131415$ git statusOn branch master Initial commit Changes to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: .gitignore new file: HelloWorld.java Untracked files: (use "git add &lt;file&gt;..." to include in what will be committed) Config.ini 比如我的项目目录下有一个Config.ini文件，这个是个本地配置文件我不希望上传到git中去，我们可以在gitignore文件中添加这样的配置：1Config.ini 或者你想忽略所有的.ini文件你可以这样写：1*.ini 如果有些文件已经被你忽略了，当你使用git add时是无法添加的，比如我忽略了*.class，现在我想把HelloWorld.class添加到git中去：1234$ git add HelloWorld.classThe following paths are ignored by one of your .gitignore files:HelloWorld.classUse -f if you really want to add them. git会提示我们这个文件已经被我们忽略了，需要加上-f参数才能强制添加到git中去：1234567891011$ git statusOn branch master Initial commit Changes to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: .gitignore new file: HelloWorld.class new file: HelloWorld.java 这样就能强制添加到缓存中去了。如果我们意外的将想要忽略的文件添加到缓存中去了，我们可以使用rm命令将其从中移除：12$ git rm HelloWorld.class --cachedrm 'HelloWorld.class' 如果你已经把不想上传的文件上传到了git仓库，那么你必须先从远程仓库删了它，我们可以从远程仓库直接删除然后pull代码到本地仓库这些文件就会本删除，或者从本地删除这些文件并且在.gitignore文件中添加这些你想忽略的文件，然后再push到远程仓库。 2）示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657下面是曾经线上使用过的一个gerrit里项目代码的.gitignore的配置（在项目中添加.gitignore过滤文件，在git push到gerrit里即可）[wangshibo@gerrit-server hq_ios]$ cat .gitignore#Built application files*.apk*.ap_ # Files for the Dalvik VM*.dex # Java class files*.class # Generated files*/bin/*/gen/*/out/ # Gradle files.gradle/build/*/build/gradlewgradlew.bat # Local configuration file (sdk path, etc)local.properties # Proguard folder generated by Eclipseproguard/ # Log Files*.log # Android Studio Navigation editor temp files.navigation/ # Android Studio captures foldercaptures/ # Intellij*.iml*/*.iml # Keystore files#*.jks#gradle wrappergradle/ #some local files*/.settings/*/.DS_Store.DS_Store*/.idea/.idea/gradlewgradlew.batunused.txt 3）示例123456789101112131415161718192021222324252627[wangshibo@gerrit-server hq_ios$ cat .gitignore# Lines that start with '#' are comments.# IntelliJ IDEA Project files.idea*.iml*.ipr*.iwsout # Eclipse Project files.classpath.project.settings/ bin/gen/local.properties .DS_StoreThumbs.db *.bak*.tem*.temp#.swp*.*~~*.* .gitignor忽略规则查看如果你发下.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：12$ git check-ignore -v HelloWorld.class.gitignore:1:*.class HelloWorld.class 可以看到HelloWorld.class匹配到了我们的第一条*.class的忽略规则所以文件被忽略了。 简单来说，要实现过滤掉Git里不想上传的文件，如上介绍三种方法能达到这种目的，只不过适用情景不一样：12345678910111213141516171819202122232425262728293031323334353637383940414243============第一种方法===========针对单一工程排除文件，这种方式会让这个工程的所有修改者在克隆代码的同时，也能克隆到过滤规则，而不用自己再写一份，这就能保证所有修改者应用的都是同一份规则，而不是张三自己有一套过滤规则，李四又使用另一套过滤规则，个人比较喜欢这个。 配置步骤如下：在工程根目录下建立.gitignore文件，将要排除的文件或目录 写到.gitignore这个文件中，其中有两种写入方法： a)使用命令行增加排除文件排除以.class结尾的文件 echo "*.class" &gt;.gitignore (&gt;&gt; 是在文件尾增加,&gt; 是删除已经存在的内容再增加)，之后会在当前目录下生成一个.gitignore的文件。排除bin目录下的文件 echo "bin/" &gt;.gitignore b)最方便的办法是，用记事本打开，增加需要排除的文件或目录，一行增加一个，例如：*.class*.apkbin/gen/.settings/proguard/ ===========第二种方法===========全局设置排除文件，这会在全局起作用，只要是Git管理的工程，在提交时都会自动排除不在控制范围内的文件或目录。这种方法对开发者来说，比较省事，只要一次全局配置，不用每次建立工程都要配置一遍过滤规则。但是这不保证其他的开发者在克隆你的代码后，他们那边的规则跟你的是一样的，这就带来了代码提交过程中的各种冲突问题。配置步骤如下：a）像方法（1）一样，也需要建立一个.gitignore文件，把要排除的文件写进去。b）但在这里，我们不规定一定要把.gitnore文件放到某个工程下面，而是任何地方，比如我们这里放到了Git默认的Home路径下，比如：/home/wangshibo/hqsb_iosc）使用命令方式可以配置全局排除文件: # git config --global core.excludesfile ~/.gitignore 你会发现在~/.gitconfig文件中会出现excludesfile = /home/wangshibo/hqsb_ios/.gitignore。 说明Git把文件过滤规则应用到了Global的规则中。 ===========第三种方法===========单个工程设置排除文件，在工程目录下找到.git/info/exclude，把要排除的文件写进去：*.class*.apkbin/gen/.settings/proguard/ 这种方法就不提倡了，只能针对单一工程配置，而且还不能将过滤规则同步到其他开发者，跟方法一和方法二比较起来没有一点优势。 Git忽略规则(.gitignore配置）不生效原因和解决12345678910111213141516171819第一种方法:.gitignore中已经标明忽略的文件目录下的文件，git push的时候还会出现在push的目录中，或者用git status查看状态，想要忽略的文件还是显示被追踪状态。原因是因为在git忽略目录中，新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行git的提交，这样就不会出现忽略的文件了。 解决方法: git清除本地缓存（改变成未track状态），然后再提交:[root@kevin ~]# git rm -r --cached .[root@kevin ~]# git add .[root@kevin ~]# git commit -m 'update .gitignore'[root@kevin ~]# git push -u origin master 需要特别注意的是：1）.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。2）想要.gitignore起作用，必须要在这些文件不在暂存区中才可以，.gitignore文件只是忽略没有被staged(cached)文件， 对于已经被staged文件，加入ignore文件时一定要先从staged移除，才可以忽略。 第二种方法:（推荐）在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。[root@kevin ~]# git update-index --assume-unchanged PATH //在PATH处输入要忽略的文件 在使用.gitignore文件后如何删除远程仓库中以前上传的此类文件而保留本地文件在使用git和github的时候，之前没有写.gitignore文件，就上传了一些没有必要的文件，在添加了.gitignore文件后，就想删除远程仓库中的文件却想保存本地的文件。这时候不可以直接使用”git rm directory”，这样会删除本地仓库的文件。可以使用”git rm -r –cached directory”来删除缓冲，然后进行”commit”和”push”，这样会发现远程仓库中的不必要文件就被删除了，以后可以直接使用”git add -A”来添加修改的内容，上传的文件就会受到.gitignore文件的内容约束。 额外说明：git库所在的文件夹中的文件大致有4种状态 123456789101112131415161718Untracked:未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify:文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改,而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified:文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态,使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 Staged:暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态.执行git reset HEAD filename取消暂存, 文件状态为Modified Git 状态 untracked 和 not staged的区别- [x] 1）untrack 表示是新文件，没有被add过，是为跟踪的意思。- [ ] 2）not staged 表示add过的文件，即跟踪文件，再次修改没有add，就是没有暂存的意思 文献参考来源：https://www.cnblogs.com/kevingrace/p/5690241.html]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3 matplotlib函数]]></title>
    <url>%2F%2FmatplotlibF%2F</url>
    <content type="text"><![CDATA[摘要本节主要是学习matplotlib的函数调用，主要是基础的学习路线，包括简单的实例笔记等。 摘要 interactive模式特点： plt.ion() plt.ioff() 常用函数 plt.figure() Parameters: Returns: plt.plot() Edit By Porter, 积水成渊,蛟龙生焉。 interactive模式特点：plt.ion()plt.ioff()开启interactive模式，用plt.ion()，放在绘图之前，关闭该模式用plt.ioff()； python可视化库matplotlib有两种显示模式： 阻塞（block）模式 交互（interactive）模式 在Python Consol命令行中，默认是交互模式。而在python脚本中，matplotlib默认是阻塞模式。 在交互模式下, plt.plot(x)或plt.imshow(x)是直接出图像，不需要plt.show()如果在脚本中使用ion()命令开启了交互模式，没有使用ioff()关闭的话，则图像会一闪而过，并不会常留。要想防止这种情况，需要在plt.show()之前加上ioff()命令。 在阻塞模式下, 打开一个窗口以后必须关掉才能打开下一个新的窗口。这种情况下，默认是不能像Matlab一样同时开很多窗口进行对比的。plt.plot(x)或plt.imshow(x)是直接出图像，需要plt.show()后才能显示图像 下面这个例子讲的是如何像matlab一样同时打开多个窗口显示图片或线条进行比较，同时也是在脚本中开启交互模式后图像一闪而过的解决办法： 12345678910import matplotlib.pyplot as pltplt.ion() # 打开交互模式# 同时打开两个窗口显示图片plt.figure()plt.imshow(i1)plt.figure()plt.imshow(i2)# 显示前关掉交互模式plt.ioff()plt.show() 常用函数plt.figure()Parameters: num : integer or string, optional, default: None If not provided, a new figure will be created, and the figure number will be incremented. The figure objects holds this number in a number attribute. If num is provided, and a figure with this id already exists, make it active, and returns a reference to it. If this figure does not exists, create it and returns it. If num is a string, the window title will be set to this figure’s num. figsize : (float, float), optional, default: None width, height in inches. If not provided, defaults to rcParams[“figure.figsize”] = [6.4, 4.8]. dpi : integer, optional, default: None resolution of the figure. If not provided, defaults to rcParams[“figure.dpi”] = 100. facecolor : the background color. If not provided, defaults to rcParams[“figure.facecolor”] = ‘w’. edgecolor : the border color. If not provided, defaults to rcParams[“figure.edgecolor”] = ‘w’. frameon : bool, optional, default: True If False, suppress drawing the figure frame. FigureClass : subclass of Figure Optionally use a custom Figure instance. clear : bool, optional, default: False If True and the figure already exists, then it is cleared. Returns: figure : Figure The Figure instance returned will also be passed to new_figure_manager in the backends, which allows to hook custom Figure classes into the pyplot interface. Additional kwargs will be passed to the Figure init function. plt.plot()]]></content>
      <categories>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[值得收藏的网站]]></title>
    <url>%2F%2Fusefullwebsite%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要本文主要是收集比较好用的网站。 包括学术，电影，音乐，下载资源，和用的网站 1、 虫部落搜索 2、 虫部落学术 3、 虫部落设计搜索 4、 latexstudio排版学习 5、 短网链生成 wailian suo 6、 盒子部落便民工具系列 7、 艺术字+ 二维码设计 艺术字设计 个性二维码 最终效果： 8、 图床 路过图床 SM.MS图床，生成后每次i.loli.net后缀的名字，更多可以参见百度搜索。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32串口通信配置（USART1+USART2+USART3+UART4）]]></title>
    <url>%2F%2Fstm32chuankou%2F</url>
    <content type="text"><![CDATA[摘要：本文是通过分享几个通用的串口函数，实现对STM32芯片的多个串口操作和多种收发数据方式，实现串口通信的功能，本文的各个驱动代码经测试都可以直接使用，本人写的这部分代码开源 (。^_^。) 一、串口一的配置 （初始化+中断配置+中断接收函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 配置独立看门狗初始化函数，在主函数中运行IWDG_ReloadCounter进行喂狗主函数必须在4s内进行一次喂狗不然系统会复位； 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#include "stm32f10x_iwdg.h"u8 USART1_RX_BUF[21]; u8 USART1_RX_CNT=0;void IWDG_Configuration(void); void Usart1_Init(u32 bound)&#123; //GPIO端口设置 GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOC, ENABLE);//使能USART1,GPIOA,C时钟 //USART1_TX GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.9 //USART1_RX GPIOA.10初始化 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.10 //Usart1 NVIC 配置 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 0-3; NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道使能 NVIC_Init(&amp;NVIC_InitStructure); //根据指定的参数初始化VIC寄存器 //USART 初始化设置 USART_InitStructure.USART_BaudRate = bound;//串口波特率 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口1 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断 USART_Cmd(USART1, ENABLE); //使能串口1 &#125;/*** USART1发送len个字节.* buf:发送区首地址* len:发送的字节数(为了和本代码的接收匹配,这里建议不要超过64个字节)**/void USART1_Send_Data(u8 *buf,u16 len)&#123; u16 t; GPIO_SetBits(GPIOC,GPIO_Pin_9);// RS485_TX_EN=1; //设置为发送模式 for(t=0;t&lt;len;t++) //循环发送数据 &#123; while(USART_GetFlagStatus(USART1,USART_FLAG_TC)==RESET); //循环发送,直到发送完毕 USART_SendData(USART1,buf[t]); &#125; while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET); GPIO_ResetBits(GPIOC,GPIO_Pin_9);// RS485_TX_EN=0; //设置为接收模式 &#125;void main(void)&#123; Usart1_Init(9600);//串口1波特率设置为9600 IWDG_Configuration(); while(1) &#123; IWDG_ReloadCounter();//4s内必须喂狗不然复位 if(USART1_RX_CNT==21)//数据接收完成 &#123; USART1_RX_CNT=0;//指针复位 //将接收到的数据发送出去 USART1_Send_Data(USART1_RX_BUF,21);//通过串口1将接收到的固定长度字符发送出去 &#125; &#125; &#125;/*** 接收指定长度的字符串* 比如接收固定大小为21个字节的字符串**/void USART1_IRQHandler(void) //串口1中断服务程序&#123; u8 Res; if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) &#123; Res =USART_ReceiveData(USART1); //读取接收到的数据 if(USART1_RX_CNT&lt;21)//对于接收指定长度的字符串 &#123; USART1_RX_BUF[USART1_RX_CNT]=Res; //记录接收到的值 USART1_RX_CNT++; //接收数据增加1 &#125; &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(USART1,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(USART1); USART_ClearFlag(USART1,USART_FLAG_ORE); &#125; USART_ClearFlag(UART1,USART_IT_RXNE); //一定要清除接收中断&#125;/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description:配置独立看门狗初始化函数，在主函数中运行IWDG_ReloadCounter进行喂狗 主函数必须在4s内进行一次喂狗不然系统会复位revise Description:===============================================================================*/void IWDG_Configuration(void) &#123; /* 写入0x5555,用于允许狗狗寄存器写入功能 */ IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable); /* 狗狗时钟分频,40K/256=156HZ(6.4ms)*/ IWDG_SetPrescaler(IWDG_Prescaler_256); /* 喂狗时间 5s/6.4MS=781 .注意不能大于0xfff*/ IWDG_SetReload(781);//781（5s时间） IWDG_SetReload(3125);//781（20s时间） IWDG_Enable();//启用定时器 IWDG_ReloadCounter();&#125; 二、串口二的配置 （初始化+中断配置+中断接收函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#include "stm32f10x_iwdg.h"u8 USART2_RX_BUF[250]; u8 USART2_RX_CNT=0;u16 USART2_RX_STA=0; //接收状态标记 void Usart2_Init(u32 bound)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; //|RCC_APB2Periph_AFIO RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);//使能GPIOA时钟 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);//使能USART2时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //PA2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//PA3 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2,ENABLE);//复位串口2 RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2,DISABLE);//停止复位 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 0-3; NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn; //使能串口2中断 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3; //先占优先级2级 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //从优先级2级 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 USART_InitStructure.USART_BaudRate = bound;//波特率设置 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//8位数据长度 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No;///奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式 USART_Init(USART2, &amp;USART_InitStructure); ; //初始化串口 USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//开启中断 USART_Cmd(USART2, ENABLE); //使能串口 &#125;/*** USART2发送len个字节.* buf:发送区首地址* len:发送的字节数(为了和本代码的接收匹配,这里建议不要超过64个字节)**/void USART2_Send_Data(u8 *buf,u16 len)&#123; u16 t; for(t=0;t&lt;len;t++) //循环发送数据 &#123; while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET); USART_SendData(USART2,buf[t]); &#125; while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET); &#125;/*** 这也是一个接收函数，可以用，也可以用下面main函数的方法调用* USART2查询接收到的数据* buf:接收缓存首地址* len:读到的数据长度**/void USART2_Receive_Data(u8 *buf)&#123; u8 rxlen=USART2_RX_CNT; u8 i=0; delay_ms(10); //等待10ms,连续超过10ms没有接收到一个数据,则认为接收结束 while(rxlen!=USART2_RX_CNT) &#123; rxlen=USART2_RX_CNT; delay_ms(10); &#125; for(i=0;i&lt;(USART2_RX_CNT);i++) &#123; buf[i] = USART2_RX_BUF[i]; USART2_RX_BUF[i] = 0; &#125; USART2_RX_CNT=0; //清零 &#125;void main(void)&#123; Usart2_Init(9600);//串口1波特率设置为9600 while(1) &#123; if(USART2_RX_STA)//数据接收完成 &#123; USART2_RX_STA=0; //将接收到的数据发送出去 USART2_Send_Data(USART2_RX_BUF,USART2_RX_CNT);//通过串口1将接收到的固定长度字符发送出去 USART2_RX_CNT=0;//指针复位 &#125; &#125; &#125;void USART2_IRQHandler(void)&#123; u8 res; if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) //接收到数据 &#123; res =USART_ReceiveData(USART2); //读取接收到的数据 if(USART2_RX_STA==0) &#123; USART2_RX_BUF[USART2_RX_CNT] = res; //记录接收到的值 //当数据结尾收到0xA0和0xA1代表数据接收完成，是一串完整的数据 if(USART2_RX_BUF[USART2_RX_CNT-1]==0xA0&amp;&amp;USART2_RX_BUF[USART2_RX_CNT]==0xA1) USART2_RX_STA=1;//表示接收数据结束 USART2_RX_CNT++; //接收数据增加1 &#125; &#125; &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(USART2,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(USART2); USART_ClearFlag(USART2,USART_FLAG_ORE); &#125; USART_ClearFlag(UART2,USART_IT_RXNE); //一定要清除接收中断 &#125; 三、串口三的配置 （初始化+中断配置+中断接收函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去 通过滴答定时器方式获取数据revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#define USART3_TIMEOUT_Setting 800 //(ms)u8 USART3_RX_BUF[250]; u16 USART3_RX_CNT=0;u16 USART3_RX_TIMEOUT=0; //接收状态标记 void Timer1CountInitial(void);void USART3_Init(u32 baud) &#123; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; //声明一个结构体变量，用来初始化GPIO //使能串口的RCC时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE); //使能UART3所在GPIOB的时钟 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE); //串口使用的GPIO口配置 // Configure USART3 Rx (PB.11) as input floating GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); // Configure USART3 Tx (PB.10) as alternate function push-pull GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //配置串口 USART_InitStructure.USART_BaudRate = baud; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_Parity = USART_Parity_No; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; // Configure USART3 USART_Init(USART3, &amp;USART_InitStructure);//配置串口3 // Enable USART3 Receive interrupts 使能串口接收中断 USART_ITConfig(USART3, USART_IT_RXNE, ENABLE); // Enable the USART3 USART_Cmd(USART3, ENABLE);//使能串口3 //串口中断配置 //Configure the NVIC Preemption Priority Bits NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); // Enable the USART3 Interrupt NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure); &#125; void USART3_Sned_Char(u8 temp) &#123; USART_SendData(USART3,(u8)temp); while(USART_GetFlagStatus(USART3,USART_FLAG_TXE)==RESET); &#125;void USART3_Sned_Char_Buff(u8 buf[],u32 len) &#123; u32 i; for(i=0;i&lt;len;i++) USART3_Sned_Char(buf[i]); &#125;void main(void)&#123; Timer1CountInitial(); Usart3_Init(9600);//串口1波特率设置为9600 while(1) &#123; if(USART3_RX_TIMEOUT==USART3_TIMEOUT_Setting) &#123; USART3_RX_TIMEOUT=0; USART3_Sned_Char_Buff(USART3_RX_BUF,USART3_RX_CNT);//将接收到的数据发送出去 USART3_RX_CNT=0; &#125; &#125; &#125;void USART3_IRQHandler(void) //串口3中断服务程序&#123; u8 Res; if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET) &#123; USART3_RX_TIMEOUT=0; USART3_RX_BUF[USART3_RX_CNT++] = USART_ReceiveData(USART3); //读取接收到的数据 &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(USART3,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(USART3); USART_ClearFlag(USART3,USART_FLAG_ORE); &#125; USART_ClearITPendingBit(USART3, USART_IT_RXNE);&#125;//放到主函数的初始化中初始化void Timer1CountInitial(void)&#123; //定时=36000/72000x2=0.001s=1ms; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; /////////////////////////////////////////////////////////////// RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE); TIM_TimeBaseStructure.TIM_Period = 100-1;//自动重装值（此时改为10ms） TIM_TimeBaseStructure.TIM_Prescaler = 7200-1;//时钟预分频 TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数 TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //时钟分频1 TIM_TimeBaseStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM1,&amp;TIM_TimeBaseStructure); TIM_ClearFlag(TIM1,TIM_FLAG_Update); TIM_ITConfig(TIM1,TIM_IT_Update,ENABLE); TIM_Cmd(TIM1, ENABLE);&#125;void TIM1_UP_IRQHandler(void)&#123; //TIM_TimeBaseStructure.TIM_Period = 100-1;//自动重装值（此时改为10ms） if (TIM_GetITStatus(TIM1, TIM_IT_Update) != RESET) &#123; if(USART3_RX_TIMEOUT&lt;USART3_TIMEOUT_Setting) USART3_RX_TIMEOUT++; &#125; TIM_ClearITPendingBit(TIM1,TIM_IT_Update);&#125; 四、串口四的配置 （初始化+中断配置+中断接收函数） 注意串口四的中断优先级没有贴出来，和前面的三个一样的配置，为了不占用过多的篇幅就不贴中断优先级配置了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去 通过滴答定时器方式获取数据revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#define USART4_TIMEOUT_Setting 800 //(ms)u8 USART4_RX_BUF[250]; u16 USART4_RX_CNT=0;u16 USART2_RX_STA=0; //接收状态标记void Systick_delay_init(u8 SYSCLK);u8 virtual_delay(u32 num,u8 unit);//通用异步收发器UART4void UART4_Init(u32 bound)&#123; USART_InitTypeDef USART_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; //used for USART3 full remap //GPIO_PinRemapConfig(GPIO_FullRemap_USART3, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);//for UART4 //Configure RS485_TX_EN PIN GPIO_InitStructure.GPIO_Pin = RS485_TX_EN_PIN; //PC9端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(RS485_TX_EN_PORT, &amp;GPIO_InitStructure); RS485_TX_EN=0; //设置485默认为接收模式 /* Configure USART Tx as alternate function push-pull */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); /* Configure USART Rx as input floating */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); USART_InitStructure.USART_BaudRate = bound; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_Parity = USART_Parity_No ; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; USART_Init(UART4, &amp;USART_InitStructure); //USART_Init(USART3, &amp;USART_InitStructure); /* Enable the USART */ USART_Cmd(UART4, ENABLE); USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);//开启串口接受中断 USART_ClearFlag(UART4,USART_FLAG_TC); &#125;//USART1查询接收到的数据//buf:接收缓存首地址//len:读到的数据长度void UART4_Receive_Data(u8 *buf)&#123; u8 rxlen=21; u8 i=0; delay_ms(10); //等待10ms,连续超过10ms没有接收到一个数据,则认为接收结束 RS485_RX_FLAG = 0; if((UART4_RX_BUF[0]==0x01)&amp;&amp;(UART4_RX_BUF[1]==0x03)) &#123; for(i=0;i&lt;rxlen;i++) &#123; buf[i]=UART4_RX_BUF[i]; UART4_RX_BUF[i] = 0; &#125; RS485_RX_FLAG = 1; &#125; UART4_RX_CNT=0; //清零&#125;//USART1发送len个字节.//buf:发送区首地址//len:发送的字节数(为了和本代码的接收匹配,这里建议不要超过64个字节)void UART4_Send_Data(u8 *buf,u16 len)&#123; u16 t; RS485_TX_EN=1; //设置为发送模式 for(t=0;t&lt;len;t++) //循环发送数据 &#123; while(USART_GetFlagStatus(UART4,USART_FLAG_TC)==RESET); //循环发送,直到发送完毕 USART_SendData(UART4,buf[t]); &#125; while(USART_GetFlagStatus(UART4, USART_FLAG_TC) == RESET); RS485_TX_EN=0; //设置为接收模式 &#125;void main(void)&#123; Systick_delay_init(72); Usart4_Init(9600);//串口1波特率设置为9600 while(1) &#123; if(USART2_RX_STA) &#123; if(virtual_delay(USART4_TIMEOUT_Setting,MS))//超过800ms空闲则可以读取数据 &#123; UART4_Send_Data(UART4_RX_BUF,UART4_RX_CNT); USART2_RX_STA=0; UART4_RX_CNT=0; &#125; &#125; &#125; &#125;void UART4_IRQHandler(void) //UART4 Receive Interrupt &#123; u8 Res; if(USART_GetITStatus(UART4, USART_IT_RXNE) != RESET) //接收中断(接收到的数据必须是0x0d 0x0a结尾) &#123; Res =USART_ReceiveData(UART4);//(USART1-&gt;DR); //读取接收到的数据 UART4_RX_BUF[UART4_RX_CNT&amp;0XFF]=Res; //回传的数据存入数组,0X3F限制为64个数值 UART4_RX_CNT++; USART2_RX_STA=1; &#125; if( USART_GetITStatus(UART4, USART_IT_TC) == SET ) &#123; USART_ClearFlag(UART4, USART_FLAG_TC); &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(UART4,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(UART4); USART_ClearFlag(UART4,USART_FLAG_ORE); &#125;// USART_ITConfig(UART4, USART_IT_RXNE, DISABLE);//临时关闭接收中断 USART_ClearFlag(UART4,USART_IT_RXNE); //一定要清除接收中断 &#125; //初始化延迟函数//SYSTICK的时钟固定为HCLK时钟的1/8//SYSCLK:系统时钟void Systick_delay_init(u8 SYSCLK)&#123; SysTick-&gt;CTRL&amp;=0xfffffffb;//bit2清空,选择外部时钟 HCLK/8// SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8); //选择外部时钟 HCLK/8 fac_us=SYSCLK/8; fac_ms=(u16)fac_us*1000;&#125;/*===============================================================================Author:peter panDate: Description: 查询式分时或叫做轮询式（近似延时）。本函数是用于执行高效率场合的查询延时，但是一个for or while 循环中只能用一次。revise Description: @ num : //分时查询的周期计数值 @ unit : //分时查询的周期单位 @@ParaValue ： MS //周期单位为MS毫秒级 US //周期单位为US微秒级@ virtual_delay_status : //静态变量 @@ParaValue ： SET //SYSTICK正在占用中，请勿用 RESET //SYSTICK空闲，可以使用@ReValue : with zero mean Time non-arrive ,one representative Time arrived ,you can do task;##example if(virtual_delay(1000,MS)) LedFlash(); //1000ms LED闪烁一下===============================================================================*/u8 virtual_delay(u32 num,u8 unit)&#123; u32 temp; if(virtual_delay_status==RESET) // SYSTICK空闲，可以使用 &#123; if(unit==MS) &#123; SysTick-&gt;LOAD=(u32)num*Delay_SYSCLK*125;//时间加载(SysTick-&gt;LOAD为24bit) SysTick-&gt;VAL =0x00; //清空计数器 SysTick-&gt;CTRL=0x01 ; //开始倒数 &#125;else if(unit==US) &#123; SysTick-&gt;LOAD=num*Delay_SYSCLK/8; //时间加载 SysTick-&gt;VAL=0x00; //清空计数器 SysTick-&gt;CTRL=0x01 ; //开始倒数 &#125; virtual_delay_status=SET; return 0; &#125; else &#123; //virtual_delay_status==SET SYSTICK被占用 temp=SysTick-&gt;CTRL; if(!(temp&amp;0x01&amp;&amp;!(temp&amp;(1&lt;&lt;16))))//等待时间到达 &#123; SysTick-&gt;CTRL=0x00; //关闭计数器 SysTick-&gt;VAL =0X00; //清空计数器 virtual_delay_status=RESET; return 1; &#125;else return 0; &#125;&#125; 附上本人这篇博客地址]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32复位及通过函数判断是何种条件出发的复位]]></title>
    <url>%2F%2Fstm32fuwei%2F</url>
    <content type="text"><![CDATA[摘要STM32F10xxx支持三种复位形式，分别为系统复位、上电复位和备份区域复位。本文将通过实际的代码来解释各种情况下，软、硬件导致芯片复位的判别和怎样采取措施。 一、系统复位系统复位将复位所有寄存器至它们的复位状态。 当发生以下任一事件时，产生一个系统复位： NRST引脚上的低电平(外部复位) 2. 窗口看门狗计数终止(WWDG复位) 独立看门狗计数终止(IWDG复位) 软件复位(SW复位) 低功耗管理复位 可通过查看RCC_CSR控制状态寄存器中的复位状态标志位识别复位事件来源。软件复位通过将Cortex™-M3中断应用和复位控制寄存器中的SYSRESETREQ位置’1’，可实现软件复位。请参考Cortex™-M3技术参考手册获得进一步信息。 1.1 低功耗管理复位在以下两种情况下可产生低功耗管理复位： 在进入待机模式时产生低功耗管理复位： 通过将用户选择字节中的nRST_STDBY位置’1’将使能该复位。这时，即使执行了进入待机模式的过程，系统将被复位而不是进入待机模式。 在进入停止模式时产生低功耗管理复位： 通过将用户选择字节中的nRST_STOP位置’1’将使能该复位。这时，即使执行了进入停机模式的过程，系统将被复位而不是进入停机模式。关于用户选择字节的进一步信息，请参考STM32F10xxx闪存编程手册。 电源复位电源复位当以下事件中之一发生时，产生电源复位： 上电/掉电复位(POR/PDR复位) 从待机模式中返回 图4) 电源复位将复位除了备份区域外的所有寄存器。(见图中复位源将最终作用于RESET引脚，并在复位过程中保持低电平。复位入口矢量被固定在地址0x0000_0004。 芯片内部的复位信号会在NRST引脚上输出，脉冲发生器保证每一个(外部或内部)复位源都能有至少20μs的脉冲延时；当NRST引脚被拉低产生外部复位时，它将产生复位脉冲。 三、备份域复位 备份区域拥有两个专门的复位，它们只影响备份区域(见图4)。 当以下事件中之一发生时，产生备份区域复位。 软件复位，备份区域复位可由设置备份域控制寄存器 (RCC_BDCR)(见6.3.9节)中的BDRST位产生。 在VDD和VBAT两者掉电的前提下，VDD或VBAT上电将引发备份区域复位。 四、复位的标志位 五、复位标志位检索/判断什么原因导致的复位标志位判断的代码由官方库中给定代码如下： FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)；//FlagStatus 分为SET和RESET两种； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * @brief Checks whether the specified RCC flag is set or not. * @param RCC_FLAG: specifies the flag to check. * * For @b STM32_Connectivity_line_devices, this parameter can be one of the * following values: * @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready * @arg RCC_FLAG_HSERDY: HSE oscillator clock ready * @arg RCC_FLAG_PLLRDY: PLL clock ready * @arg RCC_FLAG_PLL2RDY: PLL2 clock ready * @arg RCC_FLAG_PLL3RDY: PLL3 clock ready * @arg RCC_FLAG_LSERDY: LSE oscillator clock ready * @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready * @arg RCC_FLAG_PINRST: Pin reset * @arg RCC_FLAG_PORRST: POR/PDR reset * @arg RCC_FLAG_SFTRST: Software reset * @arg RCC_FLAG_IWDGRST: Independent Watchdog reset * @arg RCC_FLAG_WWDGRST: Window Watchdog reset * @arg RCC_FLAG_LPWRRST: Low Power reset * * For @b other_STM32_devices, this parameter can be one of the following values: * @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready * @arg RCC_FLAG_HSERDY: HSE oscillator clock ready * @arg RCC_FLAG_PLLRDY: PLL clock ready * @arg RCC_FLAG_LSERDY: LSE oscillator clock ready * @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready * @arg RCC_FLAG_PINRST: Pin reset * @arg RCC_FLAG_PORRST: POR/PDR reset * @arg RCC_FLAG_SFTRST: Software reset * @arg RCC_FLAG_IWDGRST: Independent Watchdog reset * @arg RCC_FLAG_WWDGRST: Window Watchdog reset * @arg RCC_FLAG_LPWRRST: Low Power reset * * @retval The new state of RCC_FLAG (SET or RESET). */FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)&#123; uint32_t tmp = 0; uint32_t statusreg = 0; FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_RCC_FLAG(RCC_FLAG)); /* Get the RCC register index */ tmp = RCC_FLAG &gt;&gt; 5; if (tmp == 1) /* The flag to check is in CR register */ &#123; statusreg = RCC-&gt;CR; &#125; else if (tmp == 2) /* The flag to check is in BDCR register */ &#123; statusreg = RCC-&gt;BDCR; &#125; else /* The flag to check is in CSR register */ &#123; statusreg = RCC-&gt;CSR; &#125; /* Get the flag position */ tmp = RCC_FLAG &amp; FLAG_Mask; if ((statusreg &amp; ((uint32_t)1 &lt;&lt; tmp)) != (uint32_t)RESET) &#123; bitstatus = SET; &#125; else &#123; bitstatus = RESET; &#125; /* Return the flag status */ return bitstatus;&#125; 当然判断完后，我们需要将复位类型的标志置位以防后期出现重复多次判断 void RCC_ClearFlag(void)；//清除复位执行函数 代码原型如下: 12345678910111213141516171819202122232425262728293031/** * @brief Clears the RCC reset flags. * @note The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST, RCC_FLAG_SFTRST, * RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST * @param None * @retval None */void RCC_ClearFlag(void)&#123; /* Set RMVF bit to clear the reset flags */ RCC-&gt;CSR |= CSR_RMVF_Set;&#125;``` * 在使用时，只需要执行如下语句即可：```Cif(RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET) &#123; //这是上电复位 &#125; else if (RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET) &#123; //这是外部RST管脚复位 &#125; else if (RCC_GetFlagStatus(RCC_FLAG_SFTRST)!= RESET) &#123; //这是外部RST管脚复位 &#125; RCC_ClearFlag();//清除RCC中复位标志 六、STM32软件复位方法在Cortex-M3权威指南中有这么一句话这里有一个要注意的问题：从SYSRESETREQ 被置为有效，到复位发生器执行复位命令，往往会有一个延时。在此延时期间，处理器仍然可以响应中断请求。但我们的本意往往是要让此次执行到此为止，不要再做任何其它事情了。所以，最好在发出复位请求前，先把FAULTMASK 置位。所以最好在将FAULTMASK 置位才万无一失。 12345void mcuRestart(void)&#123; __set_FAULTMASK(1); //关闭所有中断 NVIC_SystemReset(); //复位｝]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之tkinter入坑Pack]]></title>
    <url>%2F%2Ftkinternote%2F</url>
    <content type="text"><![CDATA[摘要：python 中写GUI界面还是有很多方法的，下面我就说说这个tkinter吧，感觉刚上手不久，感觉不好用的样子，可能是我自己的原因导致的用不顺手。这篇主要写tkinter的pack（）方法。 tkinter 的pack()可以设置的属性 我从官网帮助手册中看到的是这样 pack_configure(self, cnf={}, **kw)Pack a widget in the parent widget. Use as options: 12345678910111213after=widget - pack it after you have packed widgetanchor=NSEW (or subset) - position widget according to given directionbefore=widget - pack it before you will pack widgetexpand=bool - expand widget if parent size growsfill=NONE or X or Y or BOTH - fill widget if widget growsin=master - use master to contain this widgetin_=master - see 'in' option descriptionipadx=amount - add internal padding in x directionipady=amount - add internal padding in y directionpadx=amount - add padding in x directionpady=amount - add padding in y directionside=TOP or BOTTOM or LEFT or RIGHT - where to add this widget. 上面的部分中文意思是说 12anchor=NSEW,表示设置我们要加的当前部件的位置side=TOP or BOTTOM or LEFT or RIGHT 表示在父类容器的什么地方家我们的部件 上面的界面代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#coding:utf-8import tkinter# 导入TK的符号常亮from tkinter.constants import *def sendStr(): print('Data Send Ok!')# 实例化TK类，主窗口必须为.TK(),而其他子窗口为.Toplevel()top = tkinter.Tk()# 设置窗口的尺寸大小top.wm_geometry('320x480+1000+100')# 不允许 改变 窗口的宽和高top.wm_resizable(False,False)# 设置窗口标题top.title('TCP Server')# 设置label标签L1 = tkinter.Label(top, text='TCP Sever;\n20108/09/15', width=15, justify=LEFT, relief=RIDGE, background='#6699ff', )\ .pack_configure(anchor=S, side=TOP, ipady=2, pady=2, fill=NONE)# 设置容器frame1 = tkinter.Frame(top,height=80,width=60,relief=RIDGE, bg='#ff3399',bd=5,borderwidth=4)# 设置填充和布局frame1.pack(fill=NONE,ipady=2,expand=False)# 添加接收区文字标签L2 = tkinter.Label(frame1,text='接\n收\n区',width=2, justify=LEFT, font=("宋体", 12, "bold"),)\ .pack(padx=2,pady=40,side=LEFT,anchor=N)# 添加接收区的文本框txt1 = tkinter.Text(frame1,width = 40, height = 10).pack(padx=2,pady=10,side=RIGHT,anchor=N)frame2 = tkinter.Frame(top, relief=RIDGE,bg='#3366ff')frame2.pack(fill=X, padx=2,pady=10,side=TOP)# 加一个复选框，一个按键chk_text = 'Hex Display'int_if_choise = tkinter.IntVar()chk1 = tkinter.Checkbutton(frame2,text=chk_text,font=('黑体',12),variable=int_if_choise,onvalue='OK',offvalue='NO')chk1.pack(fill=NONE,side=LEFT,padx=2,pady=10)print('shuchu:',int_if_choise)# 设置容器frame3 = tkinter.Frame(top,height=120,width=60,relief=RIDGE, bg='#ff3399',bd=5,borderwidth=4)# 设置填充和布局frame3.pack(fill=X,ipady=2,expand=False)# 设置字符串变量ServerReceiveVar = tkinter.StringVar(top,'')L3 = tkinter.Label(frame3, text='Cache&amp;Input:',font=('黑体',12))L3.pack(fill=NONE, expand=NO, side=TOP, anchor=W, padx=2,pady=10)txt2 = tkinter.Text(frame3, height = 2, width = 30).pack(padx=2, pady=2, ipady=4, side=LEFT, anchor=N)button1 = tkinter.Button(frame3,text='Send Str', command=sendStr).pack(side=TOP, anchor=W, padx=2, pady=4)# IP 列表button2 = tkinter.Button(frame3,text="Exit",command=top.destroy).pack(side=TOP, anchor=N, padx=2, pady=10)top.mainloop() 123456789101112from Tkinter import *root = Tk()w = Label(root, text="red", bg="red", fg="white")w.pack(padx=5, pady=10, side=LEFT)w = Label(root, text="green", bg="green", fg="black")w.pack(padx=5, pady=20, side=LEFT)w = Label(root, text="blue", bg="blue", fg="white")w.pack(padx=5, pady=20, side=LEFT)mainloop()]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[故事1：老者病危，不思乡]]></title>
    <url>%2F%2Ftooold%2F</url>
    <content type="text"><![CDATA[# 摘要 关于我的信息没什么可说的，但是这部分是博主平时无聊记录的部分内容。 - [x] Edit By Porter, 积水成渊,蛟龙生焉。 # 老者病危不思乡 * &emsp;&emsp;omega：好久没回家了，不回家看看，找小伙伴叙叙？ * &emsp;&emsp;小豌豆：ememem，不回，今年公司忙，还有其他事，脱不了身。 ------- > 你内心是这样的：以我目前的现状，没成功，没事业，更没兑象，这个标准三霉啊，就这标准屌丝样，我还赶回去吗，多丢人啊，想想那个邻家的小妹，谁来着，已经年薪估计得半掰弯以上了吧. &emsp;&emsp;你呢，自己还穷得吃土，回去乡里香歪的，又得叽叽歪歪，“你看，傻二蛋回来了”恩恩，出去这么多年，穿着品味好接土气啊”,"衣服还有如今潮流的洞洞眼，裤脚布料还是专门有岁月漂洗后留下的流梭子"，"鞋子上专门漏了个大脚拇指，像极了电视里的流浪汉装饰"，"就差顶着个脸，没挨家挨户要饭吃了，不过也是，这年代城市里垃圾桶的剩余实物残渣很丰富，养活一个人还是可以的涩“ - [x] &emsp;&emsp;小豌豆点评：瓜皮知道了吧，我不会去，并不是我忙啊，是没脸回去。 .... 故事独白时刻： &emsp;&emsp;话说若干年后，你事业有成了，准备风光回老家看看曾经一直没脸回去见下的老人。 &emsp;&emsp;这天你回到小时候居住的镇上，也是你想给证明的那个他生活的镇上。几经波折你才了解到这些年因为长时间没回家，你直想给他证明什么的那个他，已经不在了。 &emsp;&emsp;你看周边并没有一个熟悉的面孔，这时你极力冷静，试图问问这曾经你想证明给他看的那个他的邻居，问为什么他走了的消息都没人通知你，然而，这个你所谓的那个他的邻居并不是他的邻居，这个你所谓他的他邻居，并不认识你所想证明给他看的他，这个所谓的邻居只是因为做生意，刚在这里租下的门面，这里早年的房屋早已大变样，那个曾经你想证明给他看的他的房子早已被这高楼所替代，说实话你来这里问事，你也只能大概记得是这个位置。物是人非，你最终几经打听才从几位镇上的老人那知道了你所挂念着的他，早年已经离开，具体埋葬的地方也是无人能想起。当时离世时也没啥人去，你听到这心头一整揪心的痛，你压抑心中的痛苦回到那个他曾经住过的想在被高楼替换掉的楼房前，你想着曾经那个他给你的好，想到某些不甘心，又想到因为自己碍于面子，迟迟不见老人，想着想着，实在压抑不住内心的痛苦，压抑不住的流着眼泪，静静地坐着，此时你才后悔，曾经的你太过于意他人的眼光，做着强撑这无畏的面子，做了多么荒唐的决定。 &emsp;&emsp;正是因为你曾经放不下的面子，你所思念，你所至高崇敬的人已经。。。。对的都已经物是人非了，也是此时，你才尝试着放下面子，你开始哭泣，大神的哭泣，仿佛你置身于辽阔的草原，你不能注释到你身边围上来，看你莫名其妙的一群人，无视所有的存在，你任由你的鼻涕因为痛哭呛入你的肺腑，然后你无视周围的一切，你不再像曾经那样有鼻涕会文雅的擦掉，这时，因感肺腑的鼻涕躺入，你不得已，一声响亮的咳嗽声，鼻涕开始从你的嘴里躺出，似如绵绵的胶水涟漪，一丝丝垂下，却不曾断开，你此刻只能弯腰垂头俯面大地，最终形成口中鼻涕和地面相粘络络不绝，丝丝相连。你此刻已经不在乎任何的颜面，你只顾悲伤逆流成河，只顾让鼻涕，口水和眼泪来释放自己的痛，也只顾让这不绝的泪花，不断流的口水夹杂涕沫与大地来场永久的牵链不断，让悲伤逆流成和。此时你不再管周围视你莫名其妙的路人，不管一群上来或者是安慰，或者是嘲笑你，或者是假装安慰你，或者是严肃指责你太窝囊。。。。 &emsp;&emsp;这一切周边因你而产生的异象你都不再关心，你只是泪水和口水鼻涕不止地往外涌，只顾宣泄自己的痛。。。。。好长时间你终于发泄的差不多，恍然醒来，定神一看，似乎异常的围观人群早已失因为失去等待的耐心而离去，此时也已快天黑，黄昏晓。 &emsp;&emsp;你此刻只能从你周遭的近似围绕你的圆弧垃圾或者碎屑痕迹了解到，曾经你的周遭是有过很多人的逗留，你也发现你面前也多了几个铜板放在不知哪来的碗里，当然你也不确信这是人家为你的募捐，当然经过多个年头你一直不愿回家，并一直在拼搏的你看来这些募捐还是那么可笑，你只知道你并不需要。此时的黄昏胜似美景风清扬，你此刻终于明白，你一直很在乎的东西也是你自己一手造就了悲惨的结局，你想到这，无心似有心的望天长笑了三声，然后踉跄着绕着曾经你为了向他证明的他曾经生活了一辈子孤苦而终的城市彳亍着，直到夜半三更你都不愿离去。 &emsp;&emsp;直到关心你的爱人和孩子，寻找你也晚上，也正是在这寻找到深夜的此刻才找到你，你的爱人看了一眼你满脸的早已干了的尘土和涕泪痕迹，似乎欲言又止，只能默默地看着你一脸悲伤的样，几个人扶着你一拐一踉跄地将你扶上早已为你准备好的1000万FI小跑车上，此时，你却意识到忘掉了什么，坚持要从曾经你所爱的这两跑车上下来，因为，你不想忘记曾经你想证明给他看的他，此刻你决定只要人还在这座城市里，你就要自己走着，想多感受一下，你想证明的他存曾经存在过的气息，虽然你明白他早已不再。 &emsp;&emsp;夜晚深沉，似乎半夜的夜景比黄昏更加沉重，一路上你的专车司机也慢慢开着车，在你后面跟着，似乎害怕因你的以想不开，丢了这份为世界500强企业老总开车的诱人待遇岗位。你的爱人和孩子一人一遍搀扶着你，像是扶着一位身受重创的病着，但是都不敢说话，只是都静静的走着，关心你的人似乎都不愿打破这沉寂的夜晚，想跟清晰的听你心跳，听你呼吸声，确认你还有生命的气息。。。。。苍茫夜空，静静的一群人，，，，，，，，静静的离去。（无聊的人编写无聊的故事，只为证明，时光不待，莫自找多愁善感，做自己想做的事，不要被面子腰斩了青春。） &emsp;&emsp;..........未完，不待续。]]></content>
      <categories>
        <category>summary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++ MFC 界面实现套接字（socket) 通信]]></title>
    <url>%2F%2FcplusMFC%2F</url>
    <content type="text"><![CDATA[摘要 Socket 套接字的概念 Socket 函数功能 MFC 介绍 TCP 变成步骤 TCP 上位机实现 Socket 套接字的概念引用百度百科的一句话：网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。 一段形象的比喻： 建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。 Socket的英文原义是“孔”或“插座”。在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供220伏交流电， 有的提供110伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。 SuperSocke,可扩展的 Socket 服务器框架 socket.io github 网页或者官网 Socket 函数功能具体函数如下： socket()函数 bind()函数 connect()函数 listen()函数 accept()函数 send()和recv()函数 sendto()和recvfrom()函数 close()和shutdown()函数 getpeername()函数 gethostname()函数 socket() 函数1int socket(int domine,int type,int protocol); 参数(int domin)： 函数参数，即协议域，又称为协议族。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET(IPV4)、AF_INET6(IPV6)、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。通常情况下我们使用AF_INET。 AF_INET的定义是：#define AF_INET 2，所以这里的参数都是int型的 参数(int type)： :是套接口类型，主要SOCK_STREAM(建立TCP连接)、SOCK_DGRAM（建立UDP）、SOCK_RAW；SOCK_STREAM(建立TCP连接)：提供面向连接的可靠的数据传输服务。数据被看作是字节流，无长度限制。例如FTP协议就采用这种。SOCK_DGRAM（建立UDP）：提供无连接的数据传输服务，不保证可靠性。 SOCK_RAW：该接口允许对较低层次协议，如IP，ICMP直接访问。 参数(int protocole)： 指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。通常情况系设为0。 注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。 函数返回值(int): 成功：返回套接字描述符（套接字的索引） 失败：返回-1 bind() 函数一旦你有一个套接字，你可能要将套接字和机器上的一定的端口关联 起来。(如果你想用listen()来侦听一定端口的数据，这是必要一步–MUD 告 诉你说用命令 “telnet x.y.z 6969”。)如果你只想用 connect()，那么这个步 骤没有必要。但是无论如何，请继续读下去。 1int bind(int sockfd, struct sockaddr *my_addr, int addrlen); 参数(int sockfd)： sockfd 是调用 socket 返回的文件描述符。 参数(struct sockaddr *my_addr)： my_addr 是指向数据结构 struct sockaddr 的指针，它保存你的地址(即端口和 IP 地址) 信息。 参数(int addrlen)： addrlen 设置为 sizeof(struct sockaddr)。 connect()函数现在我们假设你是个 telnet 程序。你的用户命令你得到套接字的文件 描述符。你听从命令调用了socket()。下一步，你的用户告诉你通过端口 23(标准 telnet 端口)连接到”132.241.5.10”。你该怎么做呢? 幸运的是，你正在阅读 connect()–如何连接到远程主机这一章。你可 不想让你的用户失望。 1int connect(int sockfd, struct sockaddr *serv_addr, int addrlen); 参数(int sockfd)： sockfd 是系统调用 socket() 返回的套接字文件描述符。 参数(struct sockaddr *serv_addr)： serv_addr 是 保存着目的地端口和 IP 地址的数据结构 struct sockaddr。 参数(int addrlen)： addrlen 设置 为 sizeof(struct sockaddr)。 listen()函数是换换内容得时候了。假如你不希望与远程的一个地址相连，或者说， 仅仅是将它踢开，那你就需要等待接入请求并且用各种方法处理它们。处 理过程分两步：首先，你听–listen()，然后，你接受–accept() (请看下面的 内容)。 1int listen(int sockfd, int backlog); 参数(int sockfd)： sockfd 是调用 socket() 返回的套接字文件描述符。 参数(int backlog)： backlog 是在进入 队列中允许的连接数目。 accept()函数send()和recv()函数sendto()和recvfrom()函数close()和shutdown()函数getpeername()函数gethostname()函数本节参考了博文 MFC 介绍TCP 上位机实现]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Socket</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章 深度学习框架学习]]></title>
    <url>%2F%2FDLindex%2F</url>
    <content type="text"><![CDATA[摘要Welcome to My site IODT! This is your very first visit. Check home page of book for more info. If you get any problems when reading, you can find the answer in google or you can contact me on :by @zf_pertor. Edit By Porter, 积水成渊,蛟龙生焉。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vultr+freenom实现主机域名的绑定]]></title>
    <url>%2F%2FvultrFreenom%2F</url>
    <content type="text"><![CDATA[vultr+freenom实现主机域名的绑定 摘要本文将通过实例进行演示，给大家介绍如何用免费的域名，绑定我们的云主机，只需要登录Freenom注册个账号就可以免费申请免备案域名了，心动请先不要忙行动，点击阅读更多，先看看本文的免费域名申请绑定主机的方法吧。 1、注册freenom域名 进入 freenom 网站,在界面的菜单中选择“Servers”–&gt;”Register a New Domains”，如下图所示: 可能在此之前需要先注册一个账号，具体网站的账号怎么注册，自己摸索下，并不复杂，这里我们只讲怎么注册域名并解析到你的主机。 接下来在“My Domains”页面上的输入框中输入你想注册的免费域名，并搜索下是否已经被注册了，输入框在如下图中的红框所示，例如我输入：smriti 搜索结果显示，好几个是免费的，我们只需要选择一个就行，如下截图所示： 随便选择一个，“Get it now” 即可比如我选择TK域名，然后进入我的购物车，选择免费12个月，如下图： 接下来在USE DNS处选择自己需要解析到的主机IP地址上，也就是把你的云服务器的主机地址填到下图的红框中，Hostname不要动，保持默认（ 一个是yourdot.tk,另一个是www.yourdot.tk ），如下图： 接下来点击“COntinue”即可。 注意如果你现在没有主机IP，你可以先不填，后期再填写，后期填写只需要进入“My Domains” 选择你注册的域名，点击右边的“Manage Domain”，然后选择第四个菜单，”Manage Freenom DNS”,然后添加域名解析到主机，如下图所示： 接下来就是等待，因为域名解析，不会一下子就解析成功的所以你需要等5-30分钟不等，如果一个小时后还是解析不成功，可能就是你的主机IP填写错误 重要的事情再说一遍，就是以上域名解析填写完成后，还需要进行等待，一般5-30分钟。5分钟内访问该网站可能提示解析错误，所以要等待啊。 有的需要主机上面也要填写DNS绑定域名,比如阿里云主机,但是我这是国外的主机和国外的免费域名，好像不要要云主机上面操作，直接在域名服务商网页上绑定主机IP就成功访问了。 2、主机注册 推荐好用的还便宜的云主机：vultr 、 和 搬瓦工 加入你已经购买了云虚拟主机，点击进入主机管理，如下图所示： 添加主机域名绑定 最后一步，主机中绑定域名，如下图：]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Chrome67版本以后不能离线安装插件的情况]]></title>
    <url>%2F%2Finstallplugbychrome%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要通过本文安装方法可以快速，解决Chrome67版本以后不能离线安装插件的情况。 一般情况下，我们如果使用的Chrome版本为67以后的版本，安装离线插件会出现如下图信息 但是这样我们就真的没法安装离线插件了吗？特别是对想安装翻墙的插件 Proxy SwitchyOmega 的同学来说是一件噩梦。这篇文章讲会告诉读者，这个问题是可以解决的 解决方法如下： 首代开终端输入以下代码 /opt/google/chrome/google-chrome –enable-easy-off-store-extension-install 将会打开google Chrome 浏览器，然后进入浏览器的扩展插件工具界面，如下图所示： 此时请再次将离线下载的插件拖进去，看看是不是能够安装了。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F%2FhexoHello%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1 PyTorch 学习]]></title>
    <url>%2F%2FpytorchNotes%2F</url>
    <content type="text"><![CDATA[摘要本节主要是学习PyTorch相关的学习，主要是基础的学习路线，包括简单的实例笔记等。 Edit By Porter, 积水成渊,蛟龙生焉。 帮助文档见PyTorch官网 一、张量(tensor)和变量(Variable)PyTorch的官方介绍是一个拥有强力GPU加速的张量和动态构建网络的库，其主要构建是张量，所以可以把PyTorch当做Numpy来用，Pytorch的很多操作好比Numpy都是类似的，但是其能够在GPU上运行，所以有着比Numpy快很多倍的速度。 12345678910import torchimport numpy as npnumpy_tensor = np.random.randn(3, 4)pytorch_tensor1 = torch.Tensor(numpy_tensor)pytorch_tensor2 = torch.from_numpy(numpy_tensor)print(pytorch_tensor1)print(pytorch_tensor2) 输出结果： 12345pytorch_tensor1:tensor([[ 1.3511, 0.2016, -0.9728, 0.7997], [-1.0706, -0.0768, -1.3627, -0.8809], [-0.6040, -0.0030, 0.4871, 0.6634]]) 12345pytorch_tensor2:tensor([[ 1.3511, 0.2016, -0.9728, 0.7997], [-1.0706, -0.0768, -1.3627, -0.8809], [-0.6040, -0.0030, 0.4871, 0.6634]], dtype=torch.float64) 使用以上两种方法进行转换的时候，会直接将Numpy ndarray的数据类型转换为对应的Pytorch Tensor数据类型,同时我们也可以使用下面的方法将pytorch tensor转换为numpy ndarray 12345678910111213import torchimport numpy as npnumpy_tensor = np.random.randn(3, 4)pytorch_tensor1 = torch.Tensor(numpy_tensor)pytorch_tensor2 = torch.from_numpy(numpy_tensor)# 如果pytorch tensor在cpu上numpy_array1 = pytorch_tensor1.numpy()numpy_array2 = pytorch_tensor2.cpu().numpy()print(numpy_array1)print(numpy_array2) 1234567891011numpy_array1:[[ 0.9646071 1.0680387 -1.4145772 -1.1733457 ] [ 0.14683424 0.15183815 0.3256755 2.5129247 ] [-1.0027096 0.02551154 -0.60790646 -0.22400694]] numpy_array2:[[-2.09633392 -2.08986247 0.02169762 0.15833546] [ 1.24929483 -1.3953018 1.03153148 -0.06309232] [ 0.24348084 -1.42512446 1.45863934 0.92882537]] 需要注意GPU上的Tensor不能直接转换为Numpy ndarray，需要使用.cpu()先将GPU上的Tensor转到CPU上 PyTorch Tensor 使用GPU加速可以使用下面两种方法将Tensor放到GPU上. 1234567# 第一种方式是定义cuda数据类型dtype = torch.cuda.FloatTensorgpu_tensor = torch.randn(10,20).type(dtype)# 第二种方式更简单，推荐使用gpu_tensor = torch.randn(10,20).cuda(0) # 将tensor放到第一个GPU上gpu_tensor = torch.randn(10,20).cuda(1) # 将tensor放到第二个GPU上 使用第一种方式将tensor放到GPU上的时候会将数据类型转换成定义的类型。 而使用第二种方式能够直接将tensor放到GPU上，类型跟之前保持一致。 推荐在定义tensor的时候就明确数据类型，然后直接使用第二种方法将tensor放到GPU上 我的测试代码： 12345678910111213141516171819202122232425import torchimport numpy as npnumpy_tensor = np.random.randn(3, 4)pytorch_tensor1 = torch.Tensor(numpy_tensor)pytorch_tensor2 = torch.from_numpy(numpy_tensor)# 如果pytorch tensor在cpu上numpy_array1 = pytorch_tensor1.numpy()numpy_array2 = pytorch_tensor2.cpu().numpy()print(numpy_array1)print(numpy_array2)print("输出数据模式1：")# 第一种方式是定义cuda数据类型dtype = torch.cuda.FloatTensorgpu_tensor1 = torch.randn(3,4).type(dtype)print(gpu_tensor1)gpu_tensor2 = torch.randn(3,4).cuda(0) # 将tensor放到第一个GPU上print("输出数据模式2：")print(gpu_tensor2) 二、Torch的数据类型2.1 torch.Tensor torch.Tensor是一种包含单一数据类型元素的多维矩阵。 Torch定义了七种CPU tensor类型和八种GPU tensor类型： Data tyoe CPU tensor GPU tensor 32-bit floating point torch.FloatTensor torch.cuda.FloatTensor 64-bit floating point torch.DoubleTensor torch.cuda.DoubleTensor 16-bit floating point N/A torch.cuda.HalfTensor 8-bit integer (unsigned) torch.ByteTensor torch.cuda.ByteTensor 8-bit integer (signed) torch.CharTensor torch.cuda.CharTensor 16-bit integer (signed) torch.ShortTensor torch.cuda.ShortTensor 32-bit integer (signed) torch.IntTensor torch.cuda.IntTensor 64-bit integer (signed) torch.LongTensor torch.cuda.LongTensor torch.Tensor是默认的tensor类型（torch.FlaotTensor）的简称。 一个张量tensor可以从Python的list或序列构建： 1234&gt;&gt;&gt; torch.FloatTensor([[1, 2, 3], [4, 5, 6]])1 2 34 5 6[torch.FloatTensor of size 2x3] 一个空张量tensor可以通过规定其大小来构建： 1234&gt;&gt;&gt; torch.IntTensor(2, 4).zero_()0 0 0 00 0 0 0[torch.IntTensor of size 2x4] 三、 Torch 的多种数学操作3.1 Torch包torch包含了多维张量的数据结构以及基于其上的多种数学操作。另外，它也提供了多种工具，其中一些可以更有效地对张量和任意类型进行序列化。 它有CUDA 的对应实现，可以在NVIDIA GPU上进行张量运算(计算能力&gt;=2.0)。 3.2 张量 Tensors3.2.1 torch.is_tensor[source]1torch.is_tensor(obj) 如果obj 是一个pytorch张量，则返回True 参数： obj (Object) – 判断对象 3.2.2 torch.is_storage1torch.is_storage(obj) 如何obj 是一个pytorch storage对象，则返回True 参数： input (Object) – 判断对象 3.2.3 torch.set_default_tensor_type[source]1torch.set_default_tensor_type(t) 3.2.4 torch.numel1torch.numel(input)-&gt;int 返回input 张量中的元素个数 例子: 123456&gt;&gt;&gt; a = torch.randn(1,2,3,4,5)&gt;&gt;&gt; torch.numel(a)120&gt;&gt;&gt; a = torch.zeros(4,4)&gt;&gt;&gt; torch.numel(a)16 3.2.5 torch.set_printoptions[source]1torch.set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, profile=None) 设置打印选项。 完全参考自 Numpy。 参数: precision – 浮点数输出的精度位数 (默认为8 ) threshold – 阈值，触发汇总显示而不是完全显示(repr)的数组元素的总数 （默认为1000） edgeitems – 汇总显示中，每维（轴）两端显示的项数（默认值为3） linewidth – 用于插入行间隔的每行字符数（默认为80）。Thresholded matricies will ignore this parameter. profile – pretty打印的完全默认值。 可以覆盖上述所有选项 (默认为short, full) 3.3 创建操作 Creation Ops3.3.1 torch.eye1torch.eye(n, m=None, out=None) 返回一个2维张量，对角线位置全1，其它位置全0 参数: n (int ) – 行数 m (int, optional) – 列数.如果为None,则默认为n out (Tensor, optinal) - Output tensor 返回值: 对角线位置全1，其它位置全0的2维张量 返回值类型: Tensor 例子: 12345&gt;&gt;&gt; torch.eye(3) 1 0 0 0 1 0 0 0 1[torch.FloatTensor of size 3x3] 更多参考Pytorch 文档]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F%2Fhelloindex%2F</url>
    <content type="text"><![CDATA[摘要 基于这章节的想法和具体需要完成的任务如下： 首先是基于深度学习的歌曲分类 基于深度学习的目标检测 基于深度学习的手写字计算速度改进 基于深度学习的人脸识别等例子实现界面设计 Edit By Porter, 积水成渊,蛟龙生焉。 优秀学者/资源学者、教授 徐志强副教授(Associate Professor Richard Xu),其 github主页 an AI Professor in Machine Learning at UTS.]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博文]]></title>
    <url>%2F%2Fthefirstarticle%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要欢迎来到我的博文主页，你可以进一步了解我，通过聚水渊主页 Hexo !和我的github 写作目的 为了更好的学习 每天总结 看到自己每天的进步 遇见最优秀的自己，下面是我的其他博客地址 我的博客园 我的CSDN 新浪博客 网易博客 说说我之前的英文名和现在的英文名之前我的firstname 是pertor 现在是porter，不是一个人 ？不，是一个人的，因为pertor是西班牙的名字，porter是英文名字。都是一个人。 我的网易云最后我贴下我的网易笔记]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.4 numpy函数]]></title>
    <url>%2F%2FnumpyFunc%2F</url>
    <content type="text"><![CDATA[摘要本节主要是学习numpy的函数调用，主要是基础的学习路线，包括简单的实例笔记等。 摘要- [np.random.rand()函数](#nprandomrand函数) - [语法：](#语法) - [np.random.randn()函数](#nprandomrandn函数) - [语法：](#语法-1) - [np.random.randint()函数](#nprandomrandint函数) - [语法：](#语法-2) np堆叠数组 numpy.vstack(tup) 语法： numpy.stack() Edit By Porter, 积水成渊,蛟龙生焉。 np.random.rand()函数语法： np.random.rand(d0,d1,d2……dn) 注：使用方法与np.random.randn()函数相同 返回值： 通过本函数可以返回一个或一组服从“0~1”均匀分布的随机样本值。随机样本取值范围是[0,1)，不包括1。 np.random.randn()函数语法： np.random.randn(d0,d1,d2……dn) 1) 当函数括号内没有参数时，则返回一个浮点数； 2) 当函数括号内有一个参数时，则返回秩为1的数组，不能表示向量和矩阵； 3) 当函数括号内有两个及以上参数时，则返回对应维度的数组，能表示向量或矩阵； 4) np.random.standard_normal（）函数与np.random.randn()类似，但是np.random.standard_normal（）的输入参数为元组（tuple）. 5) np.random.randn()的输入通常为整数，但是如果为浮点数，则会自动直接截断转换为整数。 返回值： 通过本函数可以返回一个或一组服从标准正态分布的随机样本值。 特点： 标准正态分布是以0为均值、以1为标准差的正态分布，记为N($\mu, \sigma$)～（0，1）。对应的正态分布曲线如下所示，即 更为具体的示意图如下 代码输出效果如下 np.random.randint()函数语法： numpy.random.randint(low, high=None, size=None, dtype=’l’) 输入： low—–为最小值 high—-为最大值 size—–为数组维度大小 dtype—为数据类型，默认的数据类型是np.int。 返回值： 返回随机整数或整型数组，范围区间为[low,high），包含low，不包含high； high没有填写时，默认生成随机数的范围是[0，low） np堆叠数组 stack()，hstack()，vstack()函数 numpy.vstack(tup)语法：np.vstack((a,b)) Parameters: tup : sequence of ndarrays The arrays must have the same shape along all but the first axis. 1-D arrays must have the same length. Returns: stacked : ndarray The array formed by stacking the given arrays, will be at least 2-D. 123456789&gt;&gt;&gt; a = np.array([[1], [2], [3]])&gt;&gt;&gt; b = np.array([[2], [3], [4]])&gt;&gt;&gt; np.vstack((a,b))array([[1], [2], [3], [2], [3], [4]]) numpy.stack()]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 中安装sublime_text3]]></title>
    <url>%2F%2Fsublime_text3%2F</url>
    <content type="text"><![CDATA[摘要Porter PanEnter “Alt+m” will show Markdown Preview 安装 输入注册码 汉化 安装插件 中文输入bug修复 1.1 安装&emsp;&emsp;建议和我一样初学的直接安装，不要直接下载官方的离线包解压了，不然还得自己配置什么dash中显示，什么的环境配置乱七八糟的 123451、 wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -2、 sudo apt-get install apt-transport-https3、 echo &quot;deb https://download.sublimetext.com/ apt/stable/&quot; | sudo tee /etc/apt/sources.list.d/sublime-text.list4、 sudo apt-get update5、 sudo apt-get install sublime-text 1.2 输入注册码&emsp;&emsp;在输入注册码之前先更改hosts，ubuntu中hosts位于： vim /etc/hosts或者gedit /etc/hosts,然后加入如下两行 121、 127.0.0.1 www.sublimetext.com2、 127.0.0.1 license.sublimehq.com &emsp;&emsp;然后保存，此时dash中输入sublime，找到我们安装的软件，打开后在界面菜单中选择help–&gt;enter license，然后输入如下注册码12345678910111213----- BEGIN LICENSE -----sgbteamSingle User LicenseEA7E-11532598891CBB9 F1513E4F 1A3405C1 A865D53F115F202E 7B91AB2D 0D2A40ED 352B269B76E84F0B CD69BFC7 59F2DFEF E267328F215652A3 E88F9D8F 4C38E3BA 5B2DAAE4969624E7 DC9CD4D5 717FB40C 1B9738CF20B3C4F1 E917B5B3 87C38D9C ACCE7DD85F7EF854 86B9743C FADC04AA FB0DA5C0F913BE58 42FEA319 F954EFDD AE881E0B------ END LICENSE ------ 点击确定，然后就可以 enjoy it! 在这还没结束，下面开始汉化 1.3 汉化 &emsp;&emsp;打开软件，直接按下“shift+ctrl+p”在弹出的框内输入ip,然后点击”package control：install pakage”,出来后输入”Chinese​Localizations”来安装Chinese​Localizations插件，然后重启，至此汉化结束。 1.4 安装markdown插件 &emsp;&emsp;在软件界面输入“shift+ctrl+p”,然后输入“ip”，然后选择，packageinstall ，然后输入“Markdown Editing“ + ”MarkdownLivePreview”,分别安装上，然后新建md文件，在编辑界面输入“alt+m”,则进入markdown preview实时显示模式。 1.5 解决Markdown不能输入汉字的问题打开终端： 在终端中输入以下代码12git clone https://github.com/lyfeyaj/sublime-text-imfix.gitcd sublime-text-imfix &amp;&amp; ./sublime-imfix 或者直接进入github的这个仓库：直接下载这个zip包，然后解压，然后在终端中cd到这个解压后的文件夹路径中，最后是在终端中输入1./sublime-imfix 此时重启sublimetext3 然后就可以进行汉字的输入了。 参考：https://blog.csdn.net/qq_41590417/article/details/80461075 https://blog.csdn.net/woaidouya123/article/details/81476551 https://www.cnblogs.com/james-lee/p/6847906.html]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>sublime-text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 每次写好后deploy博客]]></title>
    <url>%2F%2FhexoDeploy%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要：github page 结合Hexo-Yelee或者Next主题,搭建个人博客主页，是很不错的一个选择，个人使用情况，感觉Yelee界面布局啥的还是很不错的。 这篇文章中我将介绍每次我们写好的md博文怎么部署到github page 上去。 本文主要使用的命令行如下： 1、直接部署到网站 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 也可以本地部署，查看浏览效果 2、部署到本地，查看浏览效果 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 我们每次写好的博文如何正确推送至github每次我们写好了博文后，需要上传至我们的github空间中,只需要每次将我们写好的博文放到文件路径：1D:\Github\smritipertor.github.io\source\_posts 如果之前没有安装过 hexo-deployer-git 的话，先执行： 1npm install hexo-deployer-git --save 然后执行如下命令操作： 首先在你之前建好的博文路径：比如我的是 12345hexo generatehexo s //(或者:hexo server)hexo deploy //(或者:hexo d) 说明 一般我们在站点根目录中的“_config.yml”中的文件中设定我们hexo d，的部署文件到那个ID和分支中，设置内容如下： 1234deploy: type: git repository: https://github.com/smritipertor/smritipertor.github.io.git branch: master 以上内容表示，不管我们当前工作在那个分区，只要站点根目录中的“_config.yml”中branch 分区设置好，直接 1hexo d 就可以发布了。 如果你执行：1hexo generate -d 常见错误及解决办法第一种，部署出错出现错误提示，如下：1fatal: in unpopulated submodule '.deploy_git' FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html Error: fatal: in unpopulated submodule '.deploy_git' at ChildProcess.&lt;anonymous&gt; (D:\GitWebsite\smritipertor.github.io\node_modules\hexo-util\lib\spawn.js:37:17) at ChildProcess.emit (events.js:182:13) at ChildProcess.cp.emit (D:\GitWebsite\smritipertor.github.io\node_modules\cross-spawn\lib\enoent.js:40:29) at maybeClose (internal/child_process.js:962:16) at Process.ChildProcess._handle.onexit (internal/child_process.js:251:5) 则你可以直接执行以下命令即可： 12rm -rf .deploy_githexo generate -d 即，删除地电脑本地的.deploy_git文件夹（可能是你上个版本是另一台电脑），然后再生成、部署即可。 至此你的网站上就有了网站数据]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索技巧]]></title>
    <url>%2F%2Fsearchskill%2F</url>
    <content type="text"><![CDATA[摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍百度搜索技巧和google的搜索技巧。 Edit By Porter, 积水成渊,蛟龙生焉。 关于搜索技巧 &copy;date:2017年9月1日 1 百度搜索技巧1.1 高级搜索语法 1.1 英文短语搜索（” ”） 引号中的关键词将作为一个整体在搜索结果中出现。双引号中的词语（比如”like this”） 1.2 指定网域 有一些词后面加上冒号对Google有特殊的含义。其中有一个词是“site:”。要在某个特定的域或站点中进行搜索，可以在Google搜索框“site xxxx.com”。 例如，要在Google 站点上查找新闻，可以输入：新闻site:www.google.com 1.3 查找特定文件 Google已经可以支持13种非HTML文件的搜索:PDF文件、Microsoft Office (doc, ppt, xls, rtf）、Shockwave Flash (swf)PostScript(ps)和其它类型文档。 新的文档类型只要与用户的搜索相关，就会自动显示在搜索结果中。例如，如果您只想查找PDF或Flash 文件，而不要一般网页，只需搜索 “关键词filetype:pdf” 或 “关键词filetype:swf” 就可以了。 1.4 按链接搜索 例如，“link:www.google.com”将找出所有指向Google主页的网页。不能将link:搜索与普通关键词搜索结合使用。 1.5 限定关键词只在标题中 &emsp;&emsp;例如“allintitle：中国苹果”表示“中国”和“苹果”都必须出现在标题中“intitle：中国苹果”表示“中国”必须出现在标题中，“苹果”可以出现在网页的任意位置，可以是标题也可以不是。。 1.6 限定关键词只在URL中 &emsp;&emsp;例如 “allinURL：koko com” 表示 “koko” 和 “com“ 都必须出现在URL中 “inURL：koko com” 表示 “koko” 必须出现在URL中， “com” 可以出现在网页的任意位置，可以是URL也可以不是。。 1.7 Info用来显示与某链接相关的一系列搜索提供cache、link、related和完全包含该链接的网页的功能。 1.8 Related &emsp;&emsp;用来搜索结构内容方面相似的网页例:搜索所有与中文新浪网主页相似的页面(如网易首页，搜狐首页，中华网首页等)，“related:www.sina.com.cn”。.9、Cache用来搜索GOOGLE服务器上某页面的缓存这个功能同“网页快照”，通常用于查找某些已经被删除的死链接网页，相当于使用普通搜索结果页面中的“网页快照”功能。 二、百度（baidu）搜索高级语法2.1 把搜索范围限定在网页标题中——intitle网页标题通常是对网页内容提纲挈领式的归纳。把查询内容范围限定在网页标题中，有时能获得良好的效果。使用的方式，是把查询内容中，特别关键的部分，用“intitle:”领起来。例如，找林青霞的写真，就可以这样查询：写真intitle:林青霞注意，intitle:和后面的关键词之间，不要有空格。 2.2 把搜索范围限定在特定站点中——site有时候，您如果知道某个站点中有自己需要找的东西，就可以把搜索范围限定在这个站点中，提高查询效率。使用的方式，是在查询内容的后面，加上“site:站点域名”。例如，天空网下载软件不错，就可以这样查询：msn site:skycn.com 注意，“site:”后面跟的站点域名，不要带“http://”；另外site:和站点名之间，不要带空格。 2.3 把搜索范围限定在url链接中——inurl网页url中的某些信息，常常有某种有价值的含义。于是，您如果对搜索结果的url做某种限定，就可以获得良好的效果。实现的方式，是用“inurl:”，后跟需要在url中出现的关键词。例如，找关于photoshop的使用技巧，可以这样查询：photoshop inurl:jiqiao 上面这个查询串中的“photoshop”，是可以出现在网页的任何位置，而“jiqiao”则必须出现在网页url中。注意，inurl:语法和后面所跟的关键词，不要有空格。 2.4 精确匹配——双引号和书名号 双引号和书名号如果输入的查询词很长，百度在经过分析后，给出的搜索结果中的查询词，可能是拆分的。如果您对这种情况不满意，可以尝试让百度不拆分查询词。给查询词加上双引号，就可以达到这种效果。 &emsp;&emsp;例如，搜索上海科技大学，如果不加双引号，搜索结果被拆分，效果不是很好，但加引号后，“上海科技大学”，获得的结果就全是符合要求的了。 &emsp;&emsp;书名号是百度独有的一个特殊查询语法。在其他搜索引擎中，书名号会被忽略，而在百度，中文书名号是可被查询的。 &emsp;&emsp;加上书名号的查询词，有两层特殊功能，一是书名号会出现在搜索结果中；二是被书名号扩起来的内容，不会被拆分。书名号在某些情况下特别有效果，例如，查名字很通俗和常用的那些电影或者小说。比如，查电影“手机”，如果不加书名号，很多情况下出来的是通讯工具——手机，而加上书名号后，《手机》结果就都是关于电影方面的了。 2.5 要求搜索结果中不含特定查询词&emsp;&emsp;如果您发现搜索结果中，有某一类网页是您不希望看见的，而且，这些网页都包含特定的关键词，那么用减号语法，就可以去除所有这些含有特定关键词的网页。 &emsp;&emsp;例如，搜神雕侠侣，希望是关于武侠小说方面的内容，却发现很多关于电视剧方面的网页。那么就可以这样查询：神雕侠侣-电视剧。 注意，前一个关键词，和减号之间必须有空格，否则，减号会被当成连字符处理，而失去减号语法功能。减号和后一个关键词之间，有无空格均可。 2.6 专业文档搜索&emsp;&emsp;很多有价值的资料，在互联网上并非是普通的网页，而是以Word、PowerPoint、PDF等格式存在。百度支持对Office文档（包括Word、 Excel、Powerpoint）、Adobe PDF文档、RTF文档进行了全文搜索。要搜索这类文档，很简单，在普通的查询词后面，加一个“filetype：”文档类型限定。“Filetype:”后可以跟以下文件格式：DOC、XLS、PPT、PDF、RTF、ALL。其中，ALL表示搜索所有这些文件类型。例如，查找张五常关于交易费用方面的经济学论文。“交易费用张五常filetype:doc”，点击结果标题，直接下载该文档，也可以点击标题后的“HTML版”快速查看该文档的网页格式内容。]]></content>
      <categories>
        <category>summary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git 推送新的文章到github其他分支上]]></title>
    <url>%2F%2Fgitpush%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要每次编辑博文并通过命令部署网站到github page上时，我们想每天都能将改动后的博文备份到github的一个分支上，实现本地数据同步到云仓库中。 实现本地博客云同步到github page其他分支上 实现本地博客部署到github page上的master分支上 网站部署（建议隔段时间再部署到网站上，短时间内直接部署本地，本地浏览下就好部署到网上 直接部署到github page的master上 123451 git clone -b proworking &lt;我的github网站仓库:proworking&gt;2 git pull origin proworking #从我的工作分支更新最新的博文和站点配置文件3 git checkout master #将我们的本地切换到master分支4 #此处开始加入你的博文.md到站点的：\source\_posts文件夹中5 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 部署到本地 本地部署，本地浏览效果 12341 git clone -b proworking &lt;我的github网站仓库:proworking&gt;2 git checkout master #将我们的本地切换到master分支3 #此处开始加入你的博文.md到站点的：\source\_posts文件夹中4 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 实现从github上获取我仓库中的Proworking分支数据，病拉取到我的本地 将本地的博文再重新push到我的云仓库（proworking) 123git add .git commit -m "添加了：file1.md\file2.md"git push origin HEAD:proworking #一定要添加HEAD 不然会 其他注意事项 下面贴上我遇到的问题 [1] 若果你直接输入命令：1$ git push proworking 可能会出现如下的不正常信息： 12345678Pertor@Pertor-PC MINGW64 /d/Github/smritipertor.github.io (master)$ git push proworkingfatal: 'proworking' does not appear to be a git repositoryfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 正确的解决办法是，命令中输入如下代码（加HEAD) 12Pertor@Pertor-PC MINGW64 /d/Github/smritipertor.github.io (master)$ git push origin HEAD:proworking 此时会输出正确的提示，具体提示信息如下： 123456789Enumerating objects: 1498, done.Counting objects: 100% (1480/1480), done.Delta compression using up to 4 threadsCompressing objects: 100% (1219/1219), done.Writing objects: 100% (1461/1461), 1.17 MiB | 390.00 KiB/s, done.Total 1461 (delta 187), reused 1300 (delta 139)remote: Resolving deltas: 100% (187/187), completed with 10 local objects.To https://github.com/smritipertor/smritipertor.github.io.git 06b21dd..1ff56b7 HEAD -&gt; proworking]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18 正确 安装ShadowSocket]]></title>
    <url>%2F%2Ffanqiangss%2F</url>
    <content type="text"><![CDATA[ubuntu18 正确安装shadowsocket 摘要为达到能够自由访问全球学习资料，我可谓是绞尽脑汁莫寻方法，目前能做到的除了付费包月的vpn代理机构的，就只能是自己动手自己干的了，但是自己搞旺旺会出很多问题，本文结合晴子实践的经验，将所遇到的问题都一一列下并解决。 1、正常的安装步骤（ubuntu16版本）1234* Ctrl+Alt+T打开终端，输入以下命令安装好GUI界面shadowsocks-qt5* sudo add-apt-repository ppa:hzwhuang/ss-qt5* sudo apt-get update* sudo apt-get install shadowsocks-qt5 但是Ubuntu18.04在安装shadowsocks-qt5时就会出现错误 1仓库 “http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu bionic Release” 没有 Release 文件 原因： ppa:hzwhuang/ss-qt5 并没有18.04版本的源 解决方法：第一步、修改sources.list.d下文件名修改/etc/apt/sources.list.d/hzwhuang-ubuntu-ss-qt5-bionic.list文件，将bionic（18.04版本代号）改成xenial（16.04版本代号） 第二步、设置如下图 bash 中打开软件更新器 —&gt; 设置 —&gt; 其他软件 –&gt; 编辑：http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu 将发行版改为xenial ,如上图所示。 然后再执行 sudo apt-get update sudo apt-get install shadowsocks-qt5]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Socket5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python Tkinter 界面实现套接字（socket) 通信]]></title>
    <url>%2F%2Fpyqttkinter%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>GUI</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.8 深度学习环境搭建]]></title>
    <url>%2F%2FDLenviremment%2F</url>
    <content type="text"><![CDATA[摘要本文记录了1.8 深度学习环境搭建，安装CUDA，安装NVIDIA驱动，pytorch，caffe框架等等。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook 深度学习环境搭建一、安装CUDA运算平台+NVIDIA驱动这些安装的方法很简单，官方网站有具体的安装过程，这里一步带过 1.1 软件简介1.2 安装步骤二、安装PyTorch2.1 环境简介CUDA（Compute Unified Device Architecture），是显卡厂商NVIDIA推出的运算平台。CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。 它包含了CUDA指令集架构（ISA）以及GPU内部的并行计算引擎。 开发人员现在可以使用C语言来为CUDA™架构编写程序，C语言是应用最广泛的一种高级编程语言。所编写出的程序可以在支持CUDA™的处理器上以超高性能运行。CUDA3.0已经开始支持C++和FORTRAN。 —-来自百度百科 NVIDIA（纳斯达克股票代码：NVDA）是一家人工智能计算公司 。公司创立于 1993 年，总部位于美国加利福尼亚州圣克拉拉市。Jensen Huang (黄仁勋) 是创始人兼首席执行官。 Ultra：Nvidia的旗舰级产品，为本系列中的最强者。 GTX：其性能介于GTS和Ultra之间。一般为Nvidia首发的高端产品。 GTS：始终为Nvidia第三强的产品(GeForce 2 GTS与GeForce 8800GTS均可展示出来)，性能处于GTX之下，与GT相比有些模糊。 GT：频率提升版本”GeForce Technology”的缩写，频率和管线都较LE GS SE XT有较大的提升 GS：相比GT，渲染管线或者显存位宽的缩减，频率一般在GT之下，并且由于规格限制，性能在GT之下。 LE:”Limit Edition”的缩写，表示限制版本，代表某一产系列中的入门级产品，主要是频率和规格均与标准版本相比有一定的下降。 SE：在Nvidia卡中不常出现，与LE相似。 XT:”Cost Down”表示降频率版本，将标准版的频率降低，部分产品削减了管线。 由于我在笔记本上安装的，是NVIDIA GeForce 系列，所以不介绍其他的了。 配有NVIDIA GeForce 系列GPU的台式电脑和笔记本电脑带给用户无法比拟的性能，明快的照片，高清晰的视频回放，和超真实效果的游戏。GeForce 系列的笔记本GPU还包括先进的耗电管理技术，这种技术可以在不过分耗费电池的前提下保证高性能。 2.2 安装方法CUDA安装方法:linux中打开终端按照下面代码这个过程走完就好了CUDA 平台网站 12345Installation Instructions:`sudo dpkg -i cuda-repo-ubuntu1804-10-0-local-10.0.130-410.48_1.0-1_amd64.deb``sudo apt-key add /var/cuda-repo-&lt;version&gt;/7fa2af80.pub``sudo apt-get update``sudo apt-get install cuda` NVIDIA驱动 -[x] Ubuntu装好CUDA之后过段时间提示NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver. 直接进入boot引导界面，选择关闭安全模式即可解决。 2.3 使用说明三、 caffe框架安装]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.7 gitbook 插件等相关设置]]></title>
    <url>%2F%2Fgitbookplugset%2F</url>
    <content type="text"><![CDATA[摘要本文记录了1.7 gitbook 插件等相关设置，解决gitbook不支持latex公式等问题。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook gitbook 插件等相关配置插件安装配置方法在你gitbook更目录中编辑book.json文件，文件配置好后，不会生效，需要先执行命令 1gitbook install # 安装命令 然后执行如下命令进行编译 1gitbook build Mermaid 图和流程图(甘特图之类的) Mermaid 的 plugins地址, Mermaid 的github地址 安装方法，在book.json加入以下内容，然后gitbook install { “plugins”: [“mermaid”]} graph TD; A–&gt;B; A–&gt;C; B–&gt;D; C–&gt;D; classDiagramClass01 &lt;|– AveryLongClass : CoolClass03 – Class04Class05 o– Class06Class07 .. Class08Class09 –&gt; C2 : Where am i?Class09 – C3Class09 –|&gt; Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 C2: Cool label 具体使用帮助文档请移步github KaTex为了支持数学公式, 我们可以使用KaTex和MathJax插件, 官网上说Katex速度要快于MathJax 插件地址 123"plugins": [ "katex"] 用法： 1234567891011Inline math: $$\int_&#123;-\infty&#125;^\infty g(x) dx$$Block math:$$\int_&#123;-\infty&#125;^\infty g(x) dx$$Or using the templating syntax:&#123;% math %&#125;\int_&#123;-\infty&#125;^\infty g(x) dx&#123;% endblock %&#125; 安装视屏播放插件chinese-video InstallAdd the below to your book.json file, then run gitbook install : 123&#123; "plugins": ["chinese-video"]&#125; UsageCurrently, This plugin support: BilibiliYoukuIqiyiQQSohuMgtvPPTVThere are each methods which you should use to insert matched website’s video. Tips: [xxx] is optional parameter. You can ignore it but don’t ignore any @.The width x height, which is defined by you, is the largest size of the player and if you have a small screen to look through the page, Page will zoom the player with the scale of your width x height.Bilibilihtml5 https 1&#123;% bilibili %&#125; avCode @ [section] @ [width x height] &#123;% endbilibili %&#125; avCode is bilibili video’s serial number. Just like this: https://www.bilibili.com/video/av 170001 avCode should be a number. Don’t attach “av” to it. section is matched video’s sub video’s serial number. width x height is player’s size. Youkuhtml5 flash https 1&#123;% youku %&#125; videoCode @ [mode] @ [width x height] &#123;% endyouku %&#125; mode is player’s mode. js(html5) or flash. videoCode just like this: https://v.youku.com/v_show/id_ XNDU4MjQ3MzA0 .html width x height is player’s size. Iqiyihtml5 flash https(HTML5 player) http(Flash player) Iqiyi’s parameter just like shit!!! Flash player 1&#123;% iqiyi %&#125; flash @ parameter1 @ video @ albumId @ tvId @ [width x height] &#123;% endiqiyi %&#125; flash is key word. Don’t change it. You only can visit Iqiyi’s video’s Sharing page and copy its HTML to get these parameters. It just like this: 1&#123;% bilibili %&#125; 170001 @ [section] @ [640 x 480] &#123;% endbilibili %&#125;]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>Gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1.2 Pytorch 之MNIST手写字识别分类.md]]></title>
    <url>%2F%2FpytorchMNIST%2F</url>
    <content type="text"><![CDATA[摘要本文记录的是学习Pytorch 之MNIST手写字识别分类过程实现的笔记，包括MNIST分类实现的算法定义和代码实现。 Edit By Porter, 积水成渊,蛟龙生焉。 一、MNISTMNIST数据集是一个关于手写的数字识别的数据集，详见MNIST数据集官网 1.1 数据集介绍 数据集分为4个部分： Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本) Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签) Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本) Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签) MNIST 数据集来自美国国家标准与技术研究所, National Institute of Standards and Technology (NIST). 训练集 (training set) 由来自 250 个不同人手写的数字构成, 其中 50% 是高中学生, 50% 来自人口普查局 (the Census Bureau) 的工作人员. 测试集(test set) 也是同样比例的手写数字数据. 数据集并非-常规的文本文件或者图片文件，值得注意的是，我们下载解压后会发现文件是二进制的文件，如下图所示： MNIST（Mixed National Institute of Standards and Technology database）是一个计算机视觉数据集，它包含70000张手写数字的灰度图片，其中每一张图片包含 28 X 28 个像素点。可以用一个数字数组来表示这张图片： 每一张图片都有对应的标签，也就是图片对应的数字，例如上面这张图片的标签就是 1 数据集被分成两部分： 60000 行的训练数据集（mnist.train）和10000行的测试数据集（mnist.test）。 其中：60000 行的训练集分拆为 55000 行的训练集和 5000 行的验证集。 60000行的训练数据集是一个形状为 [60000, 784] 的张量，第一个维度数字用来索引图片，第二个维度数字用来索引每张图片中的像素点。（28x28=784）在此张量里的每一个元素，都表示某张图片里的某个像素的强度值，值介于 0 和 1 之间。 1.2]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>MNIST</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2 tensorflow1.x常用函数使用]]></title>
    <url>%2F%2FtfComFunction%2F</url>
    <content type="text"><![CDATA[摘要本文记录tensorflow的学习入门过程，主要是tensorflow中的常用函数的介绍。 Tensorflow的设计理念称之为计算流图，在编写程序时，首先构筑整个系统的graph，代码并不会直接生效，这一点和python的其他数值计算库（如Numpy等）不同，graph为静态的，类似于docker中的镜像。 然后，在实际的运行时，启动一个session，程序才会真正的运行。这样做的好处就是：避免反复地切换底层程序实际运行的上下文，tensorflow帮你优化整个系统的代码。我们知道，很多python程序的底层为C语言或者其他语言，执行一行脚本，就要切换一次，是有成本的，tensorflow通过计算流图的方式，帮你优化整个session需要执行的代码，还是很有优势的。 所以placeholder()函数是在神经网络构建graph的时候在模型中的占位，此时并没有把要输入的数据传入模型，它只会分配必要的内存。等建立session，在会话中，运行模型的时候通过feed_dict()函数向占位符喂入数据。 作者：清晨的光明来源：CSDN原文：https://blog.csdn.net/kdongyi/article/details/82343712版权声明：本文为博主原创文章，转载请附上博文链接！ tf.Session()TensorFlow 运行模型 — 会话 会话拥有并管理TensrFlow程序运行的所有资源。 tf.placeholder()12345tf.placeholder( dtype, shape=None, name=None) 参数： dtype： 数据类型。常用的是tf.float32,tf.float64等数值类型 shape： 数据形状。默认是None，就是一维值，也可以是多维（比如[2,3], [None, 3]表示列是3，行不定） name： 名称 placeholder()函数是在神经网络构建graph的时候在模型中的占位，此时并没有把要输入的数据传入模型，它只会分配必要的内存。等建立session，在会话中，运行模型的时候通过feed_dict()函数向占位符喂入数据。 例子12345678910import tensorflow as tfimport numpy as np input1 = tf.placeholder(tf.float32)input2 = tf.placeholder(tf.float32) output = tf.multiply(input1, input2) with tf.Session() as sess: print sess.run(output, feed_dict = &#123;input1:[3.], input2: [4.]&#125;) tf.truncated_normaltf.greater()123def greater(x: Any, y: Any, name: Any = None) -&gt; object Returns the truth value of (x &gt; y) element-wise.NOTE: math.greater supports broadcasting. More tf.greater(x,y), 即和c语言的条件语句 x&gt;y?True:Flase;但是不用的是，这个函数返回bool值。 tf.where()1234def where(condition: Any, x: Any = None, y: Any = None, name: Any = None) -&gt; Any Return the elements, either from x or y, depending on the condition. tf.train.exponential_decay()tf.train.exponential_decay(LEARNING_RATE_BASE, global_step, LEARNING_RATE_STEP,LEARNING_RATE_DECAY, staircase=True)]]></content>
      <categories>
        <category>tf</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.1 tensorflow之MNIST]]></title>
    <url>%2F%2FtfMNIST%2F</url>
    <content type="text"><![CDATA[摘要本文记录tensorflow的学习入门过程，主要是MNIST在tensorflow中完成的整个过程进行笔记的记录。 读取数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# coding: utf-8import tensorflow as tfimport os# 在不使用keras的情况下from tensorflow.examples.tutorials.mnist import input_dataimport scipy.miscimport matplotlib.pyplot as pltimport matplotlib.image as mpimg # mpimg 用于读取图片import numpy as np# 从MNIST_data/中读取数据，如果不存在就会自动下载# 这个input_data在mnist文件夹下mnist = input_data.read_data_sets("MNIST_data/", one_hot=True)# print(mnist.train.images.shape)# print(mnist.train.labels.shape)# print(mnist.validation.images.shape)# print(mnist.validation.labels.shape)# print(mnist.test.images.shape)# print(mnist.test.labels.shape)# 查看print(mnist.__dir__())# print(dir(mnist))# 把原始图片存在这个路径下save_dir = 'MNIST_data/raw/'if os.path.exists(save_dir) is False: os.makedirs(save_dir)# 保存图片for i in range(20): # 请注意，mnist.train.images[i, :]就表示第i张图片 image_arry = mnist.train.images[i, :] image_arry = image_arry.reshape(28, 28) # 保存文件的格式为: # mnist_train_0.jpg, mnist_train_1.jpg, ..., mnist_train_19.jpg filename = save_dir + 'mnist_train_%d.jpg' % i # 将iamge_array 保存为图片 scipy.misc.toimage(image_arry, cmin=0.0, cmax=1.0).save(filename)# 看前10张图片的样子fig = plt.figure()plotwindow = fig.add_subplot(111)plt.axis('off')for i in range(10): # 得到的都是one-hot 表示 one_hot_label = mnist.train.labels[i, :] label = np.argmax(one_hot_label) print('mnist_train_%d.jpg label:%d' % (i, label)) file = mpimg.imread('MNIST_data/raw/mnist_train_%d.jpg' % i) plt.imshow(file, cmap='gray') plt.title(u'image-%i' % label, loc='left') plt.show() plt.clf() plt.close() 一般国内上google是上不了的，所以如果你先前没在MNIST_data/ 文件路径下放好这四个压缩包，一般会提示网络连接超时。此时自己去百度下载好这四个训练样本。 结果出来想问下这个数字到底是几啊，我没看出来，但是标签里写的是7]]></content>
      <categories>
        <category>MNIST</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>MNIST</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.6 win10+ubuntu双系统修复ubuntu启动引导]]></title>
    <url>%2F%2FdoubleSysRepair%2F</url>
    <content type="text"><![CDATA[摘要本文记录了win10+ubuntu双系统修复ubuntu启动引导，解决最新版win10系统的UEFI快速启动带来的双系统安装启动问题（开机引导无法修复的解决方法）。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook win10+ubuntu双系统修复ubuntu启动引导摘要我的环境是：uefi启动模式下的win10 + ubutu18.04，其中win10 安装在 128G固态硬盘上，Ubuntu18.04LTS 安装在1T 机械硬盘上，由于我已安装好的ubuntu18 没有UEFI，但是ubuntu18确实是支持UEFI的，难道我必须要重新安装下ubuntu系统吗？（我ubuntu上好不容易安装好了好多软件，此时内心是崩溃的） 一、啥都不用改的解决办法（有点不推荐） 每次打开电脑后狂按F12按键，会进入Boot引导管理，然后选择你的Ubuntu系统进入即可打开ubuntu，如果你要打开window10 你可以按下开机电源后啥都不做就能进入，或者，也是狂按F12进入Boot管理界面，选择windows。 每次开机都得这么累，所以不推荐 二、先进入Ubuntu 然后执行如下命令（就是安装Ubuntu的引导修复工具软件）1234567$ sudo su# sudo add-apt-repository ppa:yannubuntu/boot-repair# apt-get update# apt-get install boot-repair1.在dash中搜索boot-repair2.点recommand repair 之后会自动执行 执行完以上步骤后会出现如下图所示的信息： 然后重启电脑，然后狂按F2,进入BOOT设置界面，设置UEFI 和 Enable。 接下来设置个Supervisor密码，注意后期退出并保存这个boot配置时，要重新设置这个密码，新密码直接全敲回车（这样代表不设置密码，面对你以后密码忘记了）如下图： 设置密码后，下面灰色的选项就可以用了。此时进入 Select an UEFI file as trust executing ,进入的界面如下图 || || || 接下来，回到Boot设置栏，讲EFI 的Ubuntu 重新排序，排到最高优先级，我这排到了我的windows启动选项的前面的，如果你了解你的windows启动标志，直接放到windows启动选项前也就可以的。 到此设置结束，但是不要忘了，把你之前的Security选项里的密码重新清楚掉哦，就是重新设置新密码，新密码内容设置为回车就好了，下次你要使用就会直接提示你输入新密码。 接下来F10保存并退出。然后启动你的电脑，会直接进入linux的引导界面，还包括了Windows的启动界面选项，这时你想进Ubuntu还是windows都是很好选择的。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>系统引导</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.5 Ubuntu下常用工具软件配置安装]]></title>
    <url>%2F%2Flinuxcommontool%2F</url>
    <content type="text"><![CDATA[摘要本文记录了Ubuntu下常用工具软件配置、安装，包括高速下载的工具安装使用，具体安装和介绍见文章内容所述。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook Ubuntu下常用工具软件配置安装 终端打开软件，不占用终端的方法是在命令后面加&amp; 1sudo matlab &amp; 一、安装高速下载工具uGet：是一款图形化界面软件， 支持队列下载和恢复下载的功能。uGet官网aira2：是一个命令行下载工具，使用不方便，需要配合其他图形界面的下载软件使用。其下载原理类似于Windows上的迅雷，通过搜索资源、为己所用，而不是仅仅从原始地址这单一资源处下载。uGet采用aria2作为后端，安装aria2插件后可与其进行交互。支持的下载协议包括：HTTP，HTTPS，FTP，BitTorrent和Metalink。 作者：Geroff来源：CSDN原文：https://blog.csdn.net/fengyulinde/article/details/78309314版权声明：本文为博主原创文章，转载请附上博文链接！ 1.1 安装步骤 安装 uget aria2 123sudo add-apt-repository ppa:plushuang-tw/uget-stablesudo apt updatesudo apt install uget aria2 1.2卸载 1.如果要移除uGet和aria2，可执行如下命令 1sudo apt-get remove --purge uget aria2 2.移除相应ppa，执行如下步骤 先安装ppa-purge 1sudo apt-get install ppa-purge 接着删除相应ppa 1sudo ppa-purge ppa:plushuang-tw/uget-stable 1.3 uGet设置如图界面选择插件–&gt; aria2即可，更多的帮助请在终端中输入，aria2c -h即可看到。 二、终端相关的配置 终端打开软件，但当软件打开后，不想让终端占用软件的方法 1software &amp; 即在软件的后面加上 &amp; 符号]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.4 Latex 排版使用笔记]]></title>
    <url>%2F%2Flatexnotes%2F</url>
    <content type="text"><![CDATA[摘要本文记录了Latex排版相关的语法句法使用，是对latex学习中的一种总结，笔记，具体笔记见文中内容所描述。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook Latex 排版使用笔记一、 简单的介绍 LaTeX（LATEX，音译“拉泰赫”）是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。 LaTeX 是一款非常优秀的科技论文排版系统，除了编写学术论文、幻灯片、书籍、报告等之外，甚至可以画矢量图。尤其在学术界非常认可，各个主流的学术期刊都提供了相应的 latex 模板。与 word 排版不同，它不是一个所见即所得的编辑器，而是基于许多的规范的 TeX 语法。正是基于此，LaTeX 在使用时可以让作者花更少的时间在文章的格式排版上，而是更关注与内容的编辑。 1.1 TeXLiveTeXLive 是一款经典的官方发布的 TeX 系统，特点是跨平台（Unix、Linux、Windows 操作系统均可）安装，不断有开发人员在维护和更新，解决BUG。缺点是软件仅仅是一个编译系统，与 CTeX 相比缺少了编译器和查看器，需要另外安装； 当然也可以不使用编辑软件，直接使用命令行（command line）或记事本编辑，再使用命令行的指令进行编译（latex、pdflatex、bibtex、dvi2ps 等），一般人当然接受不了（只有极少数程序员会这么做），开发也不方便。 1.2 CTeX CTeX 环境（适合中国人使用的 Chinese TeX 环境）中文套装是基于 Windows 下的 MiKTeX 系统，集成了编辑器 WinEdt 和 PostScript 处理软件 Ghostscript 和 GSview 等主要工具。 CTeX 中文套装在 MiKTeX 的基础上增加了对中文的完整支持。 WinEdt 一款 CTeX 自带的编辑软件，并不是免费的软件，需要（和谐）之后才好使用，否则会不断提示你进行 register。 WinEdt 提供了许多按钮式的数学符号、运算、字母提示，不需要记忆很多命令； 1.3 TexStudio [推荐]TeXstudio 是一款非常精良的 LaTeX 免费开发软件（不包括 TeX 编译环境，需要另外安装 CTeX 或 TeXLive），有着许多实用、便捷的功能： 配置非常简单，基本使用默认的配置即可，个人喜欢修改字体为 Consolas，编译方式 DVI-&gt;PS-&gt;PDF，编码 UTF-8（对中文兼容）、加入英语拼写检查（Spell Check，en_US）； 自带 PDF 查看器，即界面左边为编辑文档，右边显示编译生成的 PDF 文档，在 pdflatex 编译之后，支持对象反查（代码 –&gt; PDF（右键 Go to PDF）、PDF–&gt; 代码（右键 Go to Source））； 代码自动提示，可以自动补全，菜单里含有丰富的命令； 二、Latex基本语法三、Latex 在线参考资料]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.3 Ubuntu18 git命令使用总结]]></title>
    <url>%2F%2Fgitcommand%2F</url>
    <content type="text"><![CDATA[摘要本文记录了 Ubuntu18 git命令使用总结，主要包括git的指令使用帮助，本文不是指导如何调试代码和修复代码，具体内容见文中内容所示。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook git 相关命令学习一、git remote 命令用法1.1 git remote 命令用法12345678910111213git remote [-v | --verbose] #不带参数，列出已经存在的远程分支git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;git remote rename &lt;old&gt; &lt;new&gt;git remote remove &lt;name&gt;git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…​git remote get-url [--push] [--all] &lt;name&gt;git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;git remote [-v | --verbose] show [-n] &lt;name&gt;…​git remote prune [-n | --dry-run] &lt;name&gt;…​git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​] 二、例程代码2.1 例程代码 查看当前的远程库 12345678910111213$ git remote -v origin git://github.com/schacon/ticgit.git如果有多个远程仓库,此命令将全部列出.比如在我的 Grit 项目中,可以看到.$ git remote #不带参数，列出已经存在的远程分支 origin# 如果提示：error: 无法推送一些引用到 'https://github.com/porterpan/gitbook-tutorial.git'# 提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。# 提示：再次推送前，先与远程变更合并（如 'git pull ...'）。详见# 提示：'git push --help' 中的 'Note about fast-forwards' 小节。$ git fetch origin$ git merge origin/mastergit 正常流程 如果都是自己在开发的类，当然优先使用pull-&gt;commit-&gt;push，为什么我更倾向这种方式呢，因为这样会减少Git没有必要的merge。 如果有冲突的情况下，先pull了会出现什么问题呢？如果你的判断失误，在本地修改与远程代码有冲突的情况下，先执行了git-pull，即使是这样也不用担心，git会给你一个错误提示，这时候你再去执行commit-&gt;pull-&gt;push也是没有问题的。 git代理配置git设置代理 代理类型是socks5 12git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080 代理类型是普通的http/https 12git config --global https.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080 git取消代理12git config --global --unset http.proxygit config --global --unset https.proxy]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.2 Ubuntu18安装Gitbook]]></title>
    <url>%2F%2Finstallgitbook%2F</url>
    <content type="text"><![CDATA[摘要本文记录了 Ubuntu18安装Gitbook的相关步骤，和某些关键的终点输入指令，本文不是指导如何调试代码和修复代码，本文给出了一种安装的方法，具体修复方法见文中内容所示。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook Ubuntu18 安装Gitbook 记录1. 安装nodejs 进入nodejs官网，选择10.15.0 LTS下面的other Downloads. 然后进入下载界面 解压，开始安装 安装就是直接把解压后的放到你想安装的位置，我们直接解压到 /usr/local路径中。这就安装好了，不需要运行，直接执行下面步骤。 1sudo ln -s /usr/local/node-v4.2.4-linux-x64/bin/node /usr/local/bin/node sudo ln -s /usr/local/node-v4.2.4-linux-x64/bin/npm /usr/local/bin/npm 至此nodejs安装完成 #2. 安装gitbook 1npm install -g gitbook-cli 之后在终端输入以下命令，否则，你在终端执行 gitbook -V 会提示命令不存在。 12sudo ln -s /usr/local/node-v4.2.4-linux-x64/bin/gitbook /usr/local/bin/gitbookgitbook -v # 输出安装后的版本信息 安装结束然后 3. Gitbook使用教程3.1 gitbook 命令123456gitbook -V 检测安装成功 gitbook init 初始化 gitbook build 编译当前的生成网页，但是不启动本地服务器gitbook serve -p 8080 . 编译当前的生成网页，启动本地服务器gitbook serve . 启动本地服务器gitbook update 更新软件 README.md是关于你的书的介绍，而SUMMARY.md中则包含了书目，即章节结构，它的格式大致是： 1234* [第1章](./绪论/c1.md) # 注意章的要顶格写,此处第一章全放在根目录的绪论文件夹中的 * [第1节](c1s1.md) # 注意节要有空格号 * [第2节](c1s2.md) # 注意节要有空格号* [第2章](c2.md) # 注意章的要顶格写 剩下的东西就很好理解了，你只需要编写相应章节即可。在编辑完README.md和SUMMARY.md后，你可以运行以下命令： 1$ gitbook serve -p 8080 . Gitbook首先把你的Markdown文件编译为HTML文件，并根据SUMMARY.md生成书的目录。所有生存的文件都保存在当前目录下的一个名为_book的子目录中。完成这些工作后，Gitbook会作为一个HTTP Server运行，并在8080端口监听HTTP请求。 运行以上命令后，打开浏览器，在地址栏输入：http://localhost:8080即可看到你的书页了。 其中位于左侧书目顶部的Introduction一节就编译自README.md，而书目本身自编译自SUMMARY.md。你要在自己的网站上发布新书，只需把_book目录复制到服务器相应目录即可。至此Gitbook的基本用法就介绍完毕。 3.2 Gitbook的插件支持Gitbook可以生成HTML，因此它支持一些外部的JavaScript文件嵌入到HTML中，例如Google统计、Disqus评论系统等。以下以页面中嵌入Disqus评论为例。 首先是安装Gitbook的Disqus插件。 1234$ npm install gitbook-plugin-disqus或者先写好book.json 然后执行gitbook install #推荐这种方法 然后建立一个book.json文件，其格式如下： 12345678&#123; &quot;plugins&quot;: [&quot;disqus&quot;], &quot;pluginsConfig&quot;: &#123; &quot;disqus&quot;: &#123; &quot;shortName&quot;: &quot;NAME-FROM-DISQUS&quot; &#125; &#125;&#125; 把上面的 NAME-FROM-DISQUS 修改为你在Disqus上的项目名即可。 要卸载的话（假如我要卸载的插件是：gitchinese-video），执行如下命令 1npm uninstall gitchinese-video 再次运行命令： 1$ gitbook serve -p 8080 . 并刷新浏览器，即可看到附加了Disqus评论的页面。 3.3 生成图书当你在自己的电脑上编辑好图书之后，你可以使用Gitbook的命令行进行本地预览： 1$ gitbook serve . 然后浏览器中输入 http://localhost:4000 就可以预览生成的以网页形式组织的书籍。这里你会发现，你在你的图书项目的目录中多了一个名为_book的文件目录，而这个目录中的文件，即是生成的静态网站内容。使用build参数生成到指定目录与直接预览生成的静态网站文件不一样的是，使用这个命令，你可以将内容输入到你所想要的目录中去： 12$ mkdir /tmp/gitbook$ gitbook build --output=/tmp/gitbook 3.4 输出PDF文件输入为PDF文件，需要先使用NPM安装上gitbook pdf： 1$ sudo npm install gitbook-pdf -g 4 更多的gitbook 插件支持请访问 gitbook官方插件库参考来源]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1 Ubuntu18下有道词典的配置]]></title>
    <url>%2F%2Fyoudaoconf%2F</url>
    <content type="text"><![CDATA[摘要本文记录了ubuntu 17+，Debian 等新版本的linux系统中有道词典不能安装的问题修复，由于官方提供的deb安装文件，可以解包调试，会发现Qt5版本低的原因导致的出错，本文不是指导如何调试代码和修复代码，本文给出了一种修复的方法，具体修复方法见文中内容所示。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook 有道词典解包dep，修改源码接着玩Ubnutu18 安装有道词典 若要成功安装Ubuntu18下的有道词典，请移步大牛的仓库，配置下就好 大牛Ubuntu16后都支持的有道词典安装包和安装方法,这个支持Qt5.5 到我的是Qt5.9也支持，貌似以后版本这个可能也支持的，移步去安装吧。 提示，建议你不要开有道词典的划词，因为会卡死你，太占内存了，你ps下会发现好多的啊，全是ORC识别的进程tesseract 进程,就是这句话 12#安装ORC插件，支持有道划词，桌面翻译功能apt install tesseract-ocr tesseract-ocr-eng tesseract-ocr-chi-sim tesseract-ocr-chi-tra 说实话，不知道怎么生成那么多进程，卡死了，所以我没装这个插件，也没用划词，划词我直接浏览器安装插件解决。仅供参考。 本来准备安装有道云笔记的，但是我的linux是ubuntu18的Qt是5.9 用不了啊，他的Qt是哪个版本的没弄清楚，好像是5.4的，结果就是我安装不上，做这个笔记就是为了想办法重新改写他的源码看看能不能好点支持。 文章参考来源 该版本依赖于python3，需要如下依赖包： 1Depends: python3, python3-pyqt5, python3-requests, python3-xlib, tesseract-ocr, tesseract-ocr-eng, tesseract-ocr-chi-sim, tesseract-ocr-chi-tra, python3-pil, ttf-wqy-microhei, python3-lxml, python3-xdg, python3-pyqt5.qtmultimedia, python3-pyqt5.qtquick, python3-pyqt5.qtwebkit, gir1.2-appindicator3-0.1, python3-dbus, qtdeclarative5-controls-plugin, libqt5multimedia5-plugins,gstreamer0.10-plugins-ugly gstreamer0.10-plugins-ugly 这个可以不用，用这个替换 这个模块主要用于单词的发音： sudo apt-get install gstreamer1.0-libav Ok， 没有条件我们开始创造条件 第一步、下载有道词典的dep包进入官网，然后选择ubuntu的包下载 下载的是deb包，文件名为：youdao-dict_1.1.0-0-ubuntu_amd64.deb 。 第二步、解包1234#解压deb包到youdao-dict目录dpkg -X youdao-dict_1.1.0-0-ubuntu_amd64.deb youdao-dict#解压deb包中的control信息，control中写有该软件的依赖信息dpkg -e youdao-dict_1.1.0-0-ubuntu_amd64.deb youdao-dict/DEBIAN 第三步、修改1234cd youdao-dictcd DEBIANvim control#进入解压目录，编辑control文件，删除文件中Depends：后面的gstreamer0.10-plugins-ugly，并保存 [v] 接着就是修改工程中的源码 [v] 接着就是保存修改 第四步、重新打包123cd ~/下载#将修改后的安装文件重新打包dpkg-deb -b youdao-dict youdao-dict_new.deb 第五步、重新安装 12#安装重新打包的deb包sudo dpkg -i youdao-dict_new.deb]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>有道词典</tag>
      </tags>
  </entry>
</search>
